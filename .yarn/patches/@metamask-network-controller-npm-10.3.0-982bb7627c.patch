diff --git a/dist/NetworkController.d.ts b/dist/NetworkController.d.ts
index 8398ad54deb30c4abc0128c483e197517ab0df70..968951bf22e556e0dc644d4896f6c5cba56eca9f 100644
--- a/dist/NetworkController.d.ts
+++ b/dist/NetworkController.d.ts
@@ -259,7 +259,7 @@ export declare class NetworkController extends BaseControllerV2<typeof name, Net
      * @returns A promise that resolves to true if the network supports EIP-1559
      * and false otherwise.
      */
-    getEIP1559Compatibility(): Promise<boolean>;
+    getEIP1559Compatibility(): Promise<boolean | undefined>;
     /**
      * Re-initializes the provider and block tracker for the current network.
      */
diff --git a/dist/NetworkController.d.ts.map b/dist/NetworkController.d.ts.map
index 97ee09a38ac939ba1d16a87a2785c73d9380f18b..504d0f7d189a1762c10b2b84289e081d162edb7d 100644
--- a/dist/NetworkController.d.ts.map
+++ b/dist/NetworkController.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.d.ts","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"NetworkController.d.ts","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/NetworkController.js b/dist/NetworkController.js
index 1cca18beade6114458ab3ffef9255742c96fe530..4efa279e289d35a9be40133621f073486b535013 100644
--- a/dist/NetworkController.js
+++ b/dist/NetworkController.js
@@ -22,7 +22,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _NetworkController_instances, _NetworkController_ethQuery, _NetworkController_infuraProjectId, _NetworkController_trackMetaMetricsEvent, _NetworkController_previousProviderConfig, _NetworkController_providerProxy, _NetworkController_provider, _NetworkController_blockTrackerProxy, _NetworkController_autoManagedNetworkClientRegistry, _NetworkController_refreshNetwork, _NetworkController_getNetworkId, _NetworkController_getLatestBlock, _NetworkController_determineEIP1559Compatibility, _NetworkController_ensureAutoManagedNetworkClientRegistryPopulated, _NetworkController_createAutoManagedNetworkClientRegistry, _NetworkController_buildIdentifiedInfuraNetworkClientConfigurations, _NetworkController_buildIdentifiedCustomNetworkClientConfigurations, _NetworkController_buildIdentifiedNetworkClientConfigurationsFromProviderConfig, _NetworkController_applyNetworkSelection;
+var _NetworkController_instances, _NetworkController_ethQuery, _NetworkController_infuraProjectId, _NetworkController_trackMetaMetricsEvent, _NetworkController_previousProviderConfig, _NetworkController_providerProxy, _NetworkController_provider, _NetworkController_blockTrackerProxy, _NetworkController_autoManagedNetworkClientRegistry, _NetworkController_refreshNetwork, _NetworkController_getNetworkId, _NetworkController_getLatestBlockWithRetry, _NetworkController_getLatestBlock, _NetworkController_determineEIP1559Compatibility, _NetworkController_ensureAutoManagedNetworkClientRegistryPopulated, _NetworkController_createAutoManagedNetworkClientRegistry, _NetworkController_buildIdentifiedInfuraNetworkClientConfigurations, _NetworkController_buildIdentifiedCustomNetworkClientConfigurations, _NetworkController_buildIdentifiedNetworkClientConfigurationsFromProviderConfig, _NetworkController_applyNetworkSelection;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.NetworkController = exports.defaultState = exports.knownKeysOf = void 0;
 const assert_1 = require("assert");
@@ -475,7 +475,9 @@ class NetworkController extends base_controller_1.BaseControllerV2 {
             }
             const isEIP1559Compatible = yield __classPrivateFieldGet(this, _NetworkController_instances, "m", _NetworkController_determineEIP1559Compatibility).call(this);
             this.update((state) => {
-                state.networkDetails.EIPS[1559] = isEIP1559Compatible;
+                if (isEIP1559Compatible !== undefined) {
+                    state.networkDetails.EIPS[1559] = isEIP1559Compatible;
+                }
             });
             return isEIP1559Compatible;
         });
@@ -677,6 +679,19 @@ _NetworkController_ethQuery = new WeakMap(), _NetworkController_infuraProjectId
         });
         return convertNetworkId(possibleNetworkId);
     });
+}, _NetworkController_getLatestBlockWithRetry = function _NetworkController_getLatestBlockWithRetry(maxAttempts = 3) {
+    return __awaiter(this, void 0, void 0, function* () {
+        let latestBlock;
+        const retryInterval = 500;
+        for (let attempts = 0; attempts <= maxAttempts; attempts++) {
+            latestBlock = yield __classPrivateFieldGet(this, _NetworkController_instances, "m", _NetworkController_getLatestBlock).call(this);
+            if (latestBlock) {
+                return latestBlock;
+            }
+            yield new Promise((resolve) => setTimeout(resolve, retryInterval));
+        }
+        return null;
+    });
 }, _NetworkController_getLatestBlock = function _NetworkController_getLatestBlock() {
     return new Promise((resolve, reject) => {
         if (!__classPrivateFieldGet(this, _NetworkController_ethQuery, "f")) {
@@ -695,7 +710,10 @@ _NetworkController_ethQuery = new WeakMap(), _NetworkController_infuraProjectId
 }, _NetworkController_determineEIP1559Compatibility = function _NetworkController_determineEIP1559Compatibility() {
     return __awaiter(this, void 0, void 0, function* () {
         const latestBlock = yield __classPrivateFieldGet(this, _NetworkController_instances, "m", _NetworkController_getLatestBlock).call(this);
-        return (latestBlock === null || latestBlock === void 0 ? void 0 : latestBlock.baseFeePerGas) !== undefined;
+        if (!latestBlock) {
+            return undefined;
+        }
+        return latestBlock.baseFeePerGas !== undefined;
     });
 }, _NetworkController_ensureAutoManagedNetworkClientRegistryPopulated = function _NetworkController_ensureAutoManagedNetworkClientRegistryPopulated() {
     var _a;
diff --git a/dist/NetworkController.js.map b/dist/NetworkController.js.map
index 871ebc90841fc6cf112020c65ead90edb233fac3..d4b27b7daf826cff165fc426de1b668f77a175bd 100644
--- a/dist/NetworkController.js.map
+++ b/dist/NetworkController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NetworkController.js","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import { strict as assert } from 'assert';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport EthQuery from 'eth-query';\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { v4 as random } from 'uuid';\nimport type { Patch } from 'immer';\nimport { errorCodes } from 'eth-rpc-errors';\nimport {\n  BUILT_IN_NETWORKS,\n  convertHexToDecimal,\n  NetworksTicker,\n  ChainId,\n  InfuraNetworkType,\n  NetworkType,\n  isSafeChainId,\n} from '@metamask/controller-utils';\nimport {\n  Hex,\n  assertIsStrictHexString,\n  hasProperty,\n  isPlainObject,\n  isStrictHexString,\n} from '@metamask/utils';\nimport { INFURA_BLOCKED_KEY, NetworkStatus } from './constants';\nimport { projectLogger, createModuleLogger } from './logger';\nimport {\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n  NetworkClientType,\n} from './types';\nimport type { BlockTracker, Provider } from './types';\nimport {\n  AutoManagedNetworkClient,\n  createAutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\n\nconst log = createModuleLogger(projectLogger, 'NetworkController');\n\n/**\n * @type ProviderConfig\n *\n * Configuration passed to web3-provider-engine\n * @property rpcUrl - RPC target URL.\n * @property type - Human-readable network name.\n * @property chainId - Network ID as per EIP-155.\n * @property ticker - Currency ticker.\n * @property nickname - Personalized network name.\n * @property id - Network Configuration Id.\n */\nexport type ProviderConfig = {\n  rpcUrl?: string;\n  type: NetworkType;\n  chainId: Hex;\n  ticker?: string;\n  nickname?: string;\n  rpcPrefs?: { blockExplorerUrl?: string };\n  id?: NetworkConfigurationId;\n};\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about the network not held by any other part of state. Currently\n * only used to capture whether a network supports EIP-1559.\n */\nexport type NetworkDetails = {\n  /**\n   * EIPs supported by the network.\n   */\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n};\n\n/**\n * Custom RPC network information\n *\n * @property rpcUrl - RPC target URL.\n * @property chainId - Network ID as per EIP-155\n * @property nickname - Personalized network name.\n * @property ticker - Currency ticker.\n * @property rpcPrefs - Personalized preferences.\n */\nexport type NetworkConfiguration = {\n  rpcUrl: string;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: {\n    blockExplorerUrl: string;\n  };\n};\n\n/**\n * The collection of network configurations in state.\n */\ntype NetworkConfigurations = Record<\n  NetworkConfigurationId,\n  NetworkConfiguration & { id: NetworkConfigurationId }\n>;\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<K extends PropertyKey>(\n  object: Partial<Record<K, any>>,\n) {\n  return Object.keys(object) as K[];\n}\n\n/**\n * Asserts that the given value is of the given type if the given validation\n * function returns a truthy result.\n *\n * @param value - The value to validate.\n * @param validate - A function used to validate that the value is of the given\n * type. Takes the `value` as an argument and is expected to return true or\n * false.\n * @param message - The message to throw if the function does not return a\n * truthy result.\n * @throws if the function does not return a truthy result.\n */\nfunction assertOfType<Type>(\n  value: unknown,\n  validate: (value: unknown) => boolean,\n  message: string,\n): asserts value is Type {\n  assert.ok(validate(value), message);\n}\n\n/**\n * Returns a portion of the given object with only the given keys.\n *\n * @param object - An object.\n * @param keys - The keys to pick from the object.\n * @returns the portion of the object.\n */\nfunction pick<Obj extends Record<any, any>, Keys extends keyof Obj>(\n  object: Obj,\n  keys: Keys[],\n): Pick<Obj, Keys> {\n  const pickedObject = keys.reduce<Partial<Pick<Obj, Keys>>>(\n    (finalObject, key) => {\n      return { ...finalObject, [key]: object[key] };\n    },\n    {},\n  );\n  assertOfType<Pick<Obj, Keys>>(\n    pickedObject,\n    () => keys.every((key) => key in pickedObject),\n    'The reduce did not produce an object with all of the desired keys.',\n  );\n  return pickedObject;\n}\n\n/**\n * Convert the given value into a valid network ID. The ID is accepted\n * as either a number, a decimal string, or a 0x-prefixed hex string.\n *\n * @param value - The network ID to convert, in an unknown format.\n * @returns A valid network ID (as a decimal string)\n * @throws If the given value cannot be safely parsed.\n */\nfunction convertNetworkId(value: unknown): NetworkId {\n  if (typeof value === 'number' && !Number.isNaN(value)) {\n    return `${value}`;\n  } else if (isStrictHexString(value)) {\n    return `${convertHexToDecimal(value)}`;\n  } else if (typeof value === 'string' && /^\\d+$/u.test(value)) {\n    return value as NetworkId;\n  }\n  throw new Error(`Cannot parse as a valid network ID: '${value}'`);\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Returns whether the given argument is a type that our Infura middleware\n * recognizes.\n *\n * @param type - A type to compare.\n * @returns True or false, depending on whether the given type is one that our\n * Infura middleware recognizes.\n */\nfunction isInfuraProviderType(type: string): type is InfuraNetworkType {\n  return Object.keys(InfuraNetworkType).includes(type);\n}\n\n/**\n * Builds an identifier for an Infura network client for lookup purposes.\n *\n * @param infuraNetworkOrProviderConfig - The name of an Infura network or a\n * provider config.\n * @returns The built identifier.\n */\nfunction buildInfuraNetworkClientId(\n  infuraNetworkOrProviderConfig:\n    | InfuraNetworkType\n    | (ProviderConfig & { type: InfuraNetworkType }),\n): BuiltInNetworkClientId {\n  if (typeof infuraNetworkOrProviderConfig === 'string') {\n    return infuraNetworkOrProviderConfig;\n  }\n  return infuraNetworkOrProviderConfig.type;\n}\n\n/**\n * Builds an identifier for a custom network client for lookup purposes.\n *\n * @param args - This function can be called two ways:\n * 1. The ID of a network configuration.\n * 2. A provider config and a set of network configurations.\n * @returns The built identifier.\n */\nfunction buildCustomNetworkClientId(\n  ...args:\n    | [NetworkConfigurationId]\n    | [\n        ProviderConfig & { type: typeof NetworkType.rpc; rpcUrl: string },\n        NetworkConfigurations,\n      ]\n): CustomNetworkClientId {\n  if (args.length === 1) {\n    return args[0];\n  }\n  const [{ id, rpcUrl }, networkConfigurations] = args;\n  if (id === undefined) {\n    const matchingNetworkConfiguration = Object.values(\n      networkConfigurations,\n    ).find((networkConfiguration) => {\n      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();\n    });\n    if (matchingNetworkConfiguration) {\n      return matchingNetworkConfiguration.id;\n    }\n    return rpcUrl.toLowerCase();\n  }\n  return id;\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isInfuraProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: InfuraNetworkType } {\n  return isInfuraProviderType(providerConfig.type);\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isCustomProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: typeof NetworkType.rpc } {\n  return providerConfig.type === NetworkType.rpc;\n}\n\n/**\n * As a provider config represents the settings that are used to interface with\n * an RPC endpoint, it must have both a chain ID and an RPC URL if it represents\n * a custom network. These properties _should_ be set as they are validated in\n * the UI when a user adds a custom network, but just to be safe we validate\n * them here.\n *\n * In addition, historically the `rpcUrl` property on the ProviderConfig type\n * has been optional, even though it should not be. Making this non-optional\n * would be a breaking change, so this function types the provider config\n * correctly so that we don't have to check `rpcUrl` in other places.\n *\n * @param providerConfig - A provider config.\n * @throws if the provider config does not have a chain ID or an RPC URL.\n */\nfunction validateCustomProviderConfig(\n  providerConfig: ProviderConfig & { type: typeof NetworkType.rpc },\n): asserts providerConfig is typeof providerConfig & { rpcUrl: string } {\n  if (providerConfig.chainId === undefined) {\n    throw new Error('chainId must be provided for custom RPC endpoints');\n  }\n  if (providerConfig.rpcUrl === undefined) {\n    throw new Error('rpcUrl must be provided for custom RPC endpoints');\n  }\n}\n\n/**\n * The network ID of a network.\n */\nexport type NetworkId = `${number}`;\n\n/**\n * @type NetworkState\n *\n * Network controller state\n * @property network - Network ID as per net_version of the currently connected network\n * @property providerConfig - RPC URL and network name provider settings of the currently connected network\n * @property properties - an additional set of network properties for the currently connected network\n * @property networkConfigurations - the full list of configured networks either preloaded or added by the user.\n */\nexport type NetworkState = {\n  networkId: NetworkId | null;\n  networkStatus: NetworkStatus;\n  providerConfig: ProviderConfig;\n  networkDetails: NetworkDetails;\n  networkConfigurations: NetworkConfigurations;\n};\n\nconst name = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = {\n  type: `NetworkController:stateChange`;\n  payload: [NetworkState, Patch[]];\n};\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent;\n\nexport type NetworkControllerGetStateAction = {\n  type: `NetworkController:getState`;\n  handler: () => NetworkState;\n};\n\nexport type NetworkControllerGetProviderConfigAction = {\n  type: `NetworkController:getProviderConfig`;\n  handler: () => ProviderConfig;\n};\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetProviderConfigAction\n  | NetworkControllerGetEthQueryAction;\n\nexport type NetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  NetworkControllerActions,\n  NetworkControllerEvents,\n  string,\n  string\n>;\n\nexport type NetworkControllerOptions = {\n  messenger: NetworkControllerMessenger;\n  trackMetaMetricsEvent: () => void;\n  infuraProjectId: string;\n  state?: Partial<NetworkState>;\n};\n\nexport const defaultState: NetworkState = {\n  networkId: null,\n  networkStatus: NetworkStatus.Unknown,\n  providerConfig: {\n    type: NetworkType.mainnet,\n    chainId: ChainId.mainnet,\n  },\n  networkDetails: {\n    EIPS: {},\n  },\n  networkConfigurations: {},\n};\n\ntype MetaMetricsEventPayload = {\n  event: string;\n  category: string;\n  referrer?: { url: string };\n  actionId?: number;\n  environmentType?: string;\n  properties?: unknown;\n  sensitiveProperties?: unknown;\n  revenue?: number;\n  currency?: string;\n  value?: number;\n};\n\ntype NetworkConfigurationId = string;\n\n/**\n * The string that uniquely identifies an Infura network client.\n */\ntype BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\ntype CustomNetworkClientId = string;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\ntype AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseControllerV2<\n  typeof name,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  #infuraProjectId: string;\n\n  #trackMetaMetricsEvent: (event: MetaMetricsEventPayload) => void;\n\n  #previousProviderConfig: ProviderConfig;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #provider: ProxyWithAccessibleTarget<Provider> | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  constructor({\n    messenger,\n    state,\n    infuraProjectId,\n    trackMetaMetricsEvent,\n  }: NetworkControllerOptions) {\n    super({\n      name,\n      metadata: {\n        networkId: {\n          persist: true,\n          anonymous: false,\n        },\n        networkStatus: {\n          persist: true,\n          anonymous: false,\n        },\n        networkDetails: {\n          persist: true,\n          anonymous: false,\n        },\n        providerConfig: {\n          persist: true,\n          anonymous: false,\n        },\n        networkConfigurations: {\n          persist: true,\n          anonymous: false,\n        },\n      },\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n    this.#infuraProjectId = infuraProjectId;\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getProviderConfig`,\n      () => {\n        return this.state.providerConfig;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEthQuery`,\n      () => {\n        return this.#ethQuery;\n      },\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns The proxy and block tracker proxies.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Returns all of the network clients that have been created so far, keyed by\n   * their identifier in the network client registry. This collection represents\n   * not only built-in networks but also any custom networks that consumers have\n   * added.\n   *\n   * @returns The list of known network clients.\n   */\n  getNetworkClientsById(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Executes a series of steps to apply the changes to the provider config:\n   *\n   * 1. Notifies subscribers that the network is about to change.\n   * 2. Clears state associated with the current network.\n   * 3. Looks up a known and preinitialized network client matching the provider\n   * config and re-points the provider and block tracker proxy to it.\n   * 4. Notifies subscribers that the network has changed.\n   */\n  async #refreshNetwork() {\n    this.messagingSystem.publish('NetworkController:networkWillChange');\n    this.update((state) => {\n      state.networkId = null;\n      state.networkStatus = NetworkStatus.Unknown;\n      state.networkDetails = {\n        EIPS: {},\n      };\n    });\n    this.#applyNetworkSelection();\n    this.messagingSystem.publish('NetworkController:networkDidChange');\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Populates the network clients and establishes the initial network based on\n   * the provider configuration in state.\n   */\n  async initializeProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#applyNetworkSelection();\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Fetches the network ID for the network, ensuring that it is a hex string.\n   *\n   * @returns A promise that either resolves to the network ID, or rejects with\n   * an error.\n   * @throws If the network ID of the network is not a valid hex string.\n   */\n  async #getNetworkId(): Promise<NetworkId> {\n    const possibleNetworkId = await new Promise<string>((resolve, reject) => {\n      if (!this.#ethQuery) {\n        throw new Error('Provider has not been initialized');\n      }\n\n      this.#ethQuery.sendAsync(\n        { method: 'net_version' },\n        (error: unknown, result?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(result as string);\n          }\n        },\n      );\n    });\n\n    return convertNetworkId(possibleNetworkId);\n  }\n\n  /**\n   * Performs side effects after switching to a network. If the network is\n   * available, updates the network state with the network ID of the network and\n   * stores whether the network supports EIP-1559; otherwise clears said\n   * information about the network that may have been previously stored.\n   *\n   * @fires infuraIsBlocked if the network is Infura-supported and is blocking\n   * requests.\n   * @fires infuraIsUnblocked if the network is Infura-supported and is not\n   * blocking requests, or if the network is not Infura-supported.\n   */\n  async lookupNetwork() {\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    const isInfura = isInfuraProviderConfig(this.state.providerConfig);\n\n    let networkChanged = false;\n    const listener = () => {\n      networkChanged = true;\n      this.messagingSystem.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    };\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedNetworkId: NetworkId | null = null;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      const [networkId, isEIP1559Compatible] = await Promise.all([\n        this.#getNetworkId(),\n        this.#determineEIP1559Compatibility(),\n      ]);\n      updatedNetworkStatus = NetworkStatus.Available;\n      updatedNetworkId = networkId;\n      updatedIsEIP1559Compatible = isEIP1559Compatible;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n    this.messagingSystem.unsubscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    this.update((state) => {\n      state.networkId = updatedNetworkId;\n      state.networkStatus = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete state.networkDetails.EIPS[1559];\n      } else {\n        state.networkDetails.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n\n    if (isInfura) {\n      if (updatedNetworkStatus === NetworkStatus.Available) {\n        this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n      } else if (updatedNetworkStatus === NetworkStatus.Blocked) {\n        this.messagingSystem.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   */\n  async setProviderType(type: InfuraNetworkType) {\n    assert.notStrictEqual(\n      type,\n      NetworkType.rpc,\n      `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n    );\n    assert.ok(\n      isInfuraProviderType(type),\n      `Unknown Infura provider type \"${type}\".`,\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    // If testnet the ticker symbol should use a testnet prefix\n    const ticker =\n      type in NetworksTicker && NetworksTicker[type].length > 0\n        ? NetworksTicker[type]\n        : 'ETH';\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig.type = type;\n      state.providerConfig.ticker = ticker;\n      state.providerConfig.chainId = ChainId[type];\n      state.providerConfig.rpcPrefs = BUILT_IN_NETWORKS[type].rpcPrefs;\n      state.providerConfig.rpcUrl = undefined;\n      state.providerConfig.nickname = undefined;\n      state.providerConfig.id = undefined;\n    });\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Convenience method to update provider RPC settings.\n   *\n   * @param networkConfigurationId - The unique id for the network configuration to set as the active provider.\n   */\n  async setActiveNetwork(networkConfigurationId: string) {\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    const targetNetwork =\n      this.state.networkConfigurations[networkConfigurationId];\n\n    if (!targetNetwork) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig.type = NetworkType.rpc;\n      state.providerConfig.rpcUrl = targetNetwork.rpcUrl;\n      state.providerConfig.chainId = targetNetwork.chainId;\n      state.providerConfig.ticker = targetNetwork.ticker;\n      state.providerConfig.nickname = targetNetwork.nickname;\n      state.providerConfig.rpcPrefs = targetNetwork.rpcPrefs;\n      state.providerConfig.id = targetNetwork.id;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(): Promise<Block> {\n    return new Promise((resolve, reject) => {\n      if (!this.#ethQuery) {\n        throw new Error('Provider has not been initialized');\n      }\n\n      this.#ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * and false otherwise.\n   */\n  async getEIP1559Compatibility() {\n    const { EIPS } = this.state.networkDetails;\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility();\n    this.update((state) => {\n      state.networkDetails.EIPS[1559] = isEIP1559Compatible;\n    });\n    return isEIP1559Compatible;\n  }\n\n  /**\n   * Retrieves the latest block from the currently selected network; if the\n   * block has a `baseFeePerGas` property, then we know that the network\n   * supports EIP-1559; otherwise it doesn't.\n   *\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * and false otherwise.\n   */\n  async #determineEIP1559Compatibility(): Promise<boolean> {\n    const latestBlock = await this.#getLatestBlock();\n    return latestBlock?.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Re-initializes the provider and block tracker for the current network.\n   */\n  async resetConnection() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Adds a new custom network or updates the information for an existing\n   * network.\n   *\n   * This may involve updating the `networkConfigurations` property in\n   * state as well and/or adding a new network client to the network client\n   * registry. The `rpcUrl` and `chainId` of the given object are used to\n   * determine which action to take:\n   *\n   * - If the `rpcUrl` corresponds to an existing network configuration\n   * (case-insensitively), then it is overwritten with the object. Furthermore,\n   * if the `chainId` is different from the existing network configuration, then\n   * the existing network client is replaced with a new one.\n   * - If the `rpcUrl` does not correspond to an existing network configuration\n   * (case-insensitively), then the object is used to add a new network\n   * configuration along with a new network client.\n   *\n   * @param networkConfiguration - The network configuration to add or update.\n   * @param options - Additional configuration options.\n   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.\n   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).\n   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).\n   * @returns The ID for the added or updated network configuration.\n   */\n  async upsertNetworkConfiguration(\n    networkConfiguration: NetworkConfiguration,\n    {\n      referrer,\n      source,\n      setActive = false,\n    }: {\n      referrer: string;\n      source: string;\n      setActive?: boolean;\n    },\n  ): Promise<string> {\n    const sanitizedNetworkConfiguration: NetworkConfiguration = pick(\n      networkConfiguration,\n      ['rpcUrl', 'chainId', 'ticker', 'nickname', 'rpcPrefs'],\n    );\n    const { rpcUrl, chainId, ticker } = sanitizedNetworkConfiguration;\n\n    assertIsStrictHexString(chainId);\n    if (!isSafeChainId(chainId)) {\n      throw new Error(\n        `Invalid chain ID \"${chainId}\": numerical value greater than max safe value.`,\n      );\n    }\n    if (!rpcUrl) {\n      throw new Error(\n        'An rpcUrl is required to add or update network configuration',\n      );\n    }\n    if (!referrer || !source) {\n      throw new Error(\n        'referrer and source are required arguments for adding or updating a network configuration',\n      );\n    }\n    try {\n      new URL(rpcUrl);\n    } catch (e: any) {\n      if (e.message.includes('Invalid URL')) {\n        throw new Error('rpcUrl must be a valid URL');\n      }\n    }\n    if (!ticker) {\n      throw new Error(\n        'A ticker is required to add or update networkConfiguration',\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const existingNetworkConfiguration = Object.values(\n      this.state.networkConfigurations,\n    ).find(\n      (networkConfig) =>\n        networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase(),\n    );\n    const upsertedNetworkConfigurationId = existingNetworkConfiguration\n      ? existingNetworkConfiguration.id\n      : random();\n    const networkClientId = buildCustomNetworkClientId(\n      upsertedNetworkConfigurationId,\n    );\n\n    this.update((state) => {\n      state.networkConfigurations[upsertedNetworkConfigurationId] = {\n        id: upsertedNetworkConfigurationId,\n        ...sanitizedNetworkConfiguration,\n      };\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    const shouldDestroyExistingNetworkClient =\n      existingAutoManagedNetworkClient &&\n      existingAutoManagedNetworkClient.configuration.chainId !== chainId;\n    if (shouldDestroyExistingNetworkClient) {\n      existingAutoManagedNetworkClient.destroy();\n    }\n    if (\n      !existingAutoManagedNetworkClient ||\n      shouldDestroyExistingNetworkClient\n    ) {\n      customNetworkClientRegistry[networkClientId] =\n        createAutoManagedNetworkClient({\n          type: NetworkClientType.Custom,\n          chainId,\n          rpcUrl,\n        });\n    }\n\n    if (!existingNetworkConfiguration) {\n      this.#trackMetaMetricsEvent({\n        event: 'Custom Network Added',\n        category: 'Network',\n        referrer: {\n          url: referrer,\n        },\n        properties: {\n          chain_id: chainId,\n          symbol: ticker,\n          source,\n        },\n      });\n    }\n\n    if (setActive) {\n      await this.setActiveNetwork(upsertedNetworkConfigurationId);\n    }\n\n    return upsertedNetworkConfigurationId;\n  }\n\n  /**\n   * Removes a custom network from state.\n   *\n   * This involves updating the `networkConfigurations` property in state as\n   * well and removing the network client that corresponds to the network from\n   * the client registry.\n   *\n   * @param networkConfigurationId - The ID of an existing network\n   * configuration.\n   */\n  removeNetworkConfiguration(networkConfigurationId: string) {\n    if (!this.state.networkConfigurations[networkConfigurationId]) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);\n\n    this.update((state) => {\n      delete state.networkConfigurations[networkConfigurationId];\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    existingAutoManagedNetworkClient.destroy();\n    delete customNetworkClientRegistry[networkClientId];\n  }\n\n  /**\n   * Switches to the previously selected network, assuming that there is one\n   * (if not and `initializeProvider` has not been previously called, then this\n   * method is equivalent to calling `resetConnection`).\n   */\n  async rollbackToPreviousProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = this.#previousProviderConfig;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  async destroy() {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Updates the controller using the given backup data.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurations - Network configurations in the backup.\n   */\n  loadBackup({\n    networkConfigurations,\n  }: {\n    networkConfigurations: NetworkState['networkConfigurations'];\n  }): void {\n    this.update((state) => {\n      state.networkConfigurations = {\n        ...state.networkConfigurations,\n        ...networkConfigurations,\n      };\n    });\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClients` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#autoManagedNetworkClientRegistry ??\n      this.#createAutoManagedNetworkClientRegistry();\n    this.#autoManagedNetworkClientRegistry = autoManagedNetworkClientRegistry;\n    return autoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of built-in\n   * networks as well as the custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    return [\n      ...this.#buildIdentifiedInfuraNetworkClientConfigurations(),\n      ...this.#buildIdentifiedCustomNetworkClientConfigurations(),\n      ...this.#buildIdentifiedNetworkClientConfigurationsFromProviderConfig(),\n    ].reduce(\n      (\n        registry,\n        [networkClientType, networkClientId, networkClientConfiguration],\n      ) => {\n        const autoManagedNetworkClient = createAutoManagedNetworkClient(\n          networkClientConfiguration,\n        );\n        if (networkClientId in registry[networkClientType]) {\n          return registry;\n        }\n        return {\n          ...registry,\n          [networkClientType]: {\n            ...registry[networkClientType],\n            [networkClientId]: autoManagedNetworkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Infura]: {},\n        [NetworkClientType.Custom]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the list of network clients for built-in networks (that is,\n   * the subset of the networks we know Infura supports that consumers do not\n   * need to explicitly add).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedInfuraNetworkClientConfigurations(): [\n    NetworkClientType.Infura,\n    BuiltInNetworkClientId,\n    InfuraNetworkClientConfiguration,\n  ][] {\n    return knownKeysOf(InfuraNetworkType).map((network) => {\n      const networkClientId = buildInfuraNetworkClientId(network);\n      const networkClientConfiguration: InfuraNetworkClientConfiguration = {\n        type: NetworkClientType.Infura,\n        network,\n        infuraProjectId: this.#infuraProjectId,\n      };\n      return [\n        NetworkClientType.Infura,\n        networkClientId,\n        networkClientConfiguration,\n      ];\n    });\n  }\n\n  /**\n   * Constructs the list of network clients for custom networks (that is, those\n   * which consumers have added via `networkConfigurations`).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedCustomNetworkClientConfigurations(): [\n    NetworkClientType.Custom,\n    CustomNetworkClientId,\n    CustomNetworkClientConfiguration,\n  ][] {\n    return Object.entries(this.state.networkConfigurations).map(\n      ([networkConfigurationId, networkConfiguration]) => {\n        if (networkConfiguration.chainId === undefined) {\n          throw new Error('chainId must be provided for custom RPC endpoints');\n        }\n        if (networkConfiguration.rpcUrl === undefined) {\n          throw new Error('rpcUrl must be provided for custom RPC endpoints');\n        }\n        const networkClientId = buildCustomNetworkClientId(\n          networkConfigurationId,\n        );\n        const networkClientConfiguration: CustomNetworkClientConfiguration = {\n          type: NetworkClientType.Custom,\n          chainId: networkConfiguration.chainId,\n          rpcUrl: networkConfiguration.rpcUrl,\n        };\n        return [\n          NetworkClientType.Custom,\n          networkClientId,\n          networkClientConfiguration,\n        ];\n      },\n    );\n  }\n\n  /**\n   * Converts the provider config object in state to a network client\n   * configuration object.\n   *\n   * @returns The network client config.\n   * @throws If the provider config is of type \"rpc\" and lacks either a\n   * `chainId` or an `rpcUrl`.\n   */\n  #buildIdentifiedNetworkClientConfigurationsFromProviderConfig():\n    | [\n        [\n          NetworkClientType.Custom,\n          CustomNetworkClientId,\n          CustomNetworkClientConfiguration,\n        ],\n      ]\n    | [] {\n    const { providerConfig } = this.state;\n\n    if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const networkClientConfiguration: CustomNetworkClientConfiguration = {\n        chainId: providerConfig.chainId,\n        rpcUrl: providerConfig.rpcUrl,\n        type: NetworkClientType.Custom,\n      };\n      return [\n        [NetworkClientType.Custom, networkClientId, networkClientConfiguration],\n      ];\n    }\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      return [];\n    }\n\n    throw new Error(`Unrecognized network type: '${providerConfig.type}'`);\n  }\n\n  /**\n   * Uses the information in the provider config object to look up a known and\n   * preinitialized network client. Once a network client is found, updates the\n   * provider and block tracker proxy to point to those from the network client,\n   * then finally creates an EthQuery that points to the provider proxy.\n   *\n   * @throws If no network client could be found matching the current provider\n   * config.\n   */\n  #applyNetworkSelection() {\n    if (!this.#autoManagedNetworkClientRegistry) {\n      throw new Error(\n        'initializeProvider must be called first in order to switch the network',\n      );\n    }\n\n    const { providerConfig } = this.state;\n\n    let autoManagedNetworkClient: AutoManagedNetworkClient<NetworkClientConfiguration>;\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      const networkClientType = NetworkClientType.Infura;\n      const networkClientId = buildInfuraNetworkClientId(providerConfig);\n      const builtInNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = builtInNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find custom network matching ${networkClientId}`,\n        );\n      }\n    } else if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientType = NetworkClientType.Custom;\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const customNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find built-in network matching ${networkClientId}`,\n        );\n      }\n    } else {\n      throw new Error('Could not determine type of provider config');\n    }\n\n    const { provider, blockTracker } = autoManagedNetworkClient;\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(provider);\n    } else {\n      this.#providerProxy = createEventEmitterProxy(provider);\n    }\n    this.#provider = provider;\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: 'skipInternal',\n      });\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"NetworkController.js","sourceRoot":"","sources":["../src/NetworkController.ts"],"names":[],"mappings":"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","sourcesContent":["import { strict as assert } from 'assert';\nimport { createEventEmitterProxy } from '@metamask/swappable-obj-proxy';\nimport type { SwappableProxy } from '@metamask/swappable-obj-proxy';\nimport EthQuery from 'eth-query';\nimport {\n  BaseControllerV2,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport { v4 as random } from 'uuid';\nimport type { Patch } from 'immer';\nimport { errorCodes } from 'eth-rpc-errors';\nimport {\n  BUILT_IN_NETWORKS,\n  convertHexToDecimal,\n  NetworksTicker,\n  ChainId,\n  InfuraNetworkType,\n  NetworkType,\n  isSafeChainId,\n} from '@metamask/controller-utils';\nimport {\n  Hex,\n  assertIsStrictHexString,\n  hasProperty,\n  isPlainObject,\n  isStrictHexString,\n} from '@metamask/utils';\nimport { INFURA_BLOCKED_KEY, NetworkStatus } from './constants';\nimport { projectLogger, createModuleLogger } from './logger';\nimport {\n  CustomNetworkClientConfiguration,\n  InfuraNetworkClientConfiguration,\n  NetworkClientConfiguration,\n  NetworkClientType,\n} from './types';\nimport type { BlockTracker, Provider } from './types';\nimport {\n  AutoManagedNetworkClient,\n  createAutoManagedNetworkClient,\n  ProxyWithAccessibleTarget,\n} from './create-auto-managed-network-client';\n\nconst log = createModuleLogger(projectLogger, 'NetworkController');\n\n/**\n * @type ProviderConfig\n *\n * Configuration passed to web3-provider-engine\n * @property rpcUrl - RPC target URL.\n * @property type - Human-readable network name.\n * @property chainId - Network ID as per EIP-155.\n * @property ticker - Currency ticker.\n * @property nickname - Personalized network name.\n * @property id - Network Configuration Id.\n */\nexport type ProviderConfig = {\n  rpcUrl?: string;\n  type: NetworkType;\n  chainId: Hex;\n  ticker?: string;\n  nickname?: string;\n  rpcPrefs?: { blockExplorerUrl?: string };\n  id?: NetworkConfigurationId;\n};\n\nexport type Block = {\n  baseFeePerGas?: string;\n};\n\n/**\n * Information about the network not held by any other part of state. Currently\n * only used to capture whether a network supports EIP-1559.\n */\nexport type NetworkDetails = {\n  /**\n   * EIPs supported by the network.\n   */\n  EIPS: {\n    [eipNumber: number]: boolean;\n  };\n};\n\n/**\n * Custom RPC network information\n *\n * @property rpcUrl - RPC target URL.\n * @property chainId - Network ID as per EIP-155\n * @property nickname - Personalized network name.\n * @property ticker - Currency ticker.\n * @property rpcPrefs - Personalized preferences.\n */\nexport type NetworkConfiguration = {\n  rpcUrl: string;\n  chainId: Hex;\n  ticker: string;\n  nickname?: string;\n  rpcPrefs?: {\n    blockExplorerUrl: string;\n  };\n};\n\n/**\n * The collection of network configurations in state.\n */\ntype NetworkConfigurations = Record<\n  NetworkConfigurationId,\n  NetworkConfiguration & { id: NetworkConfigurationId }\n>;\n\n/**\n * `Object.keys()` is intentionally generic: it returns the keys of an object,\n * but it cannot make guarantees about the contents of that object, so the type\n * of the keys is merely `string[]`. While this is technically accurate, it is\n * also unnecessary if we have an object that we own and whose contents are\n * known exactly.\n *\n * TODO: Move to @metamask/utils.\n *\n * @param object - The object.\n * @returns The keys of an object, typed according to the type of the object\n * itself.\n */\nexport function knownKeysOf<K extends PropertyKey>(\n  object: Partial<Record<K, any>>,\n) {\n  return Object.keys(object) as K[];\n}\n\n/**\n * Asserts that the given value is of the given type if the given validation\n * function returns a truthy result.\n *\n * @param value - The value to validate.\n * @param validate - A function used to validate that the value is of the given\n * type. Takes the `value` as an argument and is expected to return true or\n * false.\n * @param message - The message to throw if the function does not return a\n * truthy result.\n * @throws if the function does not return a truthy result.\n */\nfunction assertOfType<Type>(\n  value: unknown,\n  validate: (value: unknown) => boolean,\n  message: string,\n): asserts value is Type {\n  assert.ok(validate(value), message);\n}\n\n/**\n * Returns a portion of the given object with only the given keys.\n *\n * @param object - An object.\n * @param keys - The keys to pick from the object.\n * @returns the portion of the object.\n */\nfunction pick<Obj extends Record<any, any>, Keys extends keyof Obj>(\n  object: Obj,\n  keys: Keys[],\n): Pick<Obj, Keys> {\n  const pickedObject = keys.reduce<Partial<Pick<Obj, Keys>>>(\n    (finalObject, key) => {\n      return { ...finalObject, [key]: object[key] };\n    },\n    {},\n  );\n  assertOfType<Pick<Obj, Keys>>(\n    pickedObject,\n    () => keys.every((key) => key in pickedObject),\n    'The reduce did not produce an object with all of the desired keys.',\n  );\n  return pickedObject;\n}\n\n/**\n * Convert the given value into a valid network ID. The ID is accepted\n * as either a number, a decimal string, or a 0x-prefixed hex string.\n *\n * @param value - The network ID to convert, in an unknown format.\n * @returns A valid network ID (as a decimal string)\n * @throws If the given value cannot be safely parsed.\n */\nfunction convertNetworkId(value: unknown): NetworkId {\n  if (typeof value === 'number' && !Number.isNaN(value)) {\n    return `${value}`;\n  } else if (isStrictHexString(value)) {\n    return `${convertHexToDecimal(value)}`;\n  } else if (typeof value === 'string' && /^\\d+$/u.test(value)) {\n    return value as NetworkId;\n  }\n  throw new Error(`Cannot parse as a valid network ID: '${value}'`);\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property, such as an instance of Error.\n *\n * TODO: Move this to @metamask/utils.\n *\n * @param error - The object to check.\n * @returns True if `error` has a `code`, false otherwise.\n */\nfunction isErrorWithCode(error: unknown): error is { code: string | number } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Returns whether the given argument is a type that our Infura middleware\n * recognizes.\n *\n * @param type - A type to compare.\n * @returns True or false, depending on whether the given type is one that our\n * Infura middleware recognizes.\n */\nfunction isInfuraProviderType(type: string): type is InfuraNetworkType {\n  return Object.keys(InfuraNetworkType).includes(type);\n}\n\n/**\n * Builds an identifier for an Infura network client for lookup purposes.\n *\n * @param infuraNetworkOrProviderConfig - The name of an Infura network or a\n * provider config.\n * @returns The built identifier.\n */\nfunction buildInfuraNetworkClientId(\n  infuraNetworkOrProviderConfig:\n    | InfuraNetworkType\n    | (ProviderConfig & { type: InfuraNetworkType }),\n): BuiltInNetworkClientId {\n  if (typeof infuraNetworkOrProviderConfig === 'string') {\n    return infuraNetworkOrProviderConfig;\n  }\n  return infuraNetworkOrProviderConfig.type;\n}\n\n/**\n * Builds an identifier for a custom network client for lookup purposes.\n *\n * @param args - This function can be called two ways:\n * 1. The ID of a network configuration.\n * 2. A provider config and a set of network configurations.\n * @returns The built identifier.\n */\nfunction buildCustomNetworkClientId(\n  ...args:\n    | [NetworkConfigurationId]\n    | [\n        ProviderConfig & { type: typeof NetworkType.rpc; rpcUrl: string },\n        NetworkConfigurations,\n      ]\n): CustomNetworkClientId {\n  if (args.length === 1) {\n    return args[0];\n  }\n  const [{ id, rpcUrl }, networkConfigurations] = args;\n  if (id === undefined) {\n    const matchingNetworkConfiguration = Object.values(\n      networkConfigurations,\n    ).find((networkConfiguration) => {\n      return networkConfiguration.rpcUrl === rpcUrl.toLowerCase();\n    });\n    if (matchingNetworkConfiguration) {\n      return matchingNetworkConfiguration.id;\n    }\n    return rpcUrl.toLowerCase();\n  }\n  return id;\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isInfuraProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: InfuraNetworkType } {\n  return isInfuraProviderType(providerConfig.type);\n}\n\n/**\n * Returns whether the given provider config refers to an Infura network.\n *\n * @param providerConfig - The provider config.\n * @returns True if the provider config refers to an Infura network, false\n * otherwise.\n */\nfunction isCustomProviderConfig(\n  providerConfig: ProviderConfig,\n): providerConfig is ProviderConfig & { type: typeof NetworkType.rpc } {\n  return providerConfig.type === NetworkType.rpc;\n}\n\n/**\n * As a provider config represents the settings that are used to interface with\n * an RPC endpoint, it must have both a chain ID and an RPC URL if it represents\n * a custom network. These properties _should_ be set as they are validated in\n * the UI when a user adds a custom network, but just to be safe we validate\n * them here.\n *\n * In addition, historically the `rpcUrl` property on the ProviderConfig type\n * has been optional, even though it should not be. Making this non-optional\n * would be a breaking change, so this function types the provider config\n * correctly so that we don't have to check `rpcUrl` in other places.\n *\n * @param providerConfig - A provider config.\n * @throws if the provider config does not have a chain ID or an RPC URL.\n */\nfunction validateCustomProviderConfig(\n  providerConfig: ProviderConfig & { type: typeof NetworkType.rpc },\n): asserts providerConfig is typeof providerConfig & { rpcUrl: string } {\n  if (providerConfig.chainId === undefined) {\n    throw new Error('chainId must be provided for custom RPC endpoints');\n  }\n  if (providerConfig.rpcUrl === undefined) {\n    throw new Error('rpcUrl must be provided for custom RPC endpoints');\n  }\n}\n\n/**\n * The network ID of a network.\n */\nexport type NetworkId = `${number}`;\n\n/**\n * @type NetworkState\n *\n * Network controller state\n * @property network - Network ID as per net_version of the currently connected network\n * @property providerConfig - RPC URL and network name provider settings of the currently connected network\n * @property properties - an additional set of network properties for the currently connected network\n * @property networkConfigurations - the full list of configured networks either preloaded or added by the user.\n */\nexport type NetworkState = {\n  networkId: NetworkId | null;\n  networkStatus: NetworkStatus;\n  providerConfig: ProviderConfig;\n  networkDetails: NetworkDetails;\n  networkConfigurations: NetworkConfigurations;\n};\n\nconst name = 'NetworkController';\n\n/**\n * Represents the block tracker for the currently selected network. (Note that\n * this is a proxy around a proxy: the inner one exists so that the block\n * tracker doesn't have to exist until it's used, and the outer one exists so\n * that the currently selected network can change without consumers needing to\n * refresh the object reference to that network.)\n */\nexport type BlockTrackerProxy = SwappableProxy<\n  ProxyWithAccessibleTarget<BlockTracker>\n>;\n\n/**\n * Represents the provider for the currently selected network. (Note that this\n * is a proxy around a proxy: the inner one exists so that the provider doesn't\n * have to exist until it's used, and the outer one exists so that the currently\n * selected network can change without consumers needing to refresh the object\n * reference to that network.)\n */\nexport type ProviderProxy = SwappableProxy<ProxyWithAccessibleTarget<Provider>>;\n\nexport type NetworkControllerStateChangeEvent = {\n  type: `NetworkController:stateChange`;\n  payload: [NetworkState, Patch[]];\n};\n\n/**\n * `networkWillChange` is published when the current network is about to be\n * switched, but the new provider has not been created and no state changes have\n * occurred yet.\n */\nexport type NetworkControllerNetworkWillChangeEvent = {\n  type: 'NetworkController:networkWillChange';\n  payload: [];\n};\n\n/**\n * `networkDidChange` is published after a provider has been created for a newly\n * switched network (but before the network has been confirmed to be available).\n */\nexport type NetworkControllerNetworkDidChangeEvent = {\n  type: 'NetworkController:networkDidChange';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published after the network is switched to an Infura\n * network, but when Infura returns an error blocking the user based on their\n * location.\n */\nexport type NetworkControllerInfuraIsBlockedEvent = {\n  type: 'NetworkController:infuraIsBlocked';\n  payload: [];\n};\n\n/**\n * `infuraIsBlocked` is published either after the network is switched to an\n * Infura network and Infura does not return an error blocking the user based on\n * their location, or the network is switched to a non-Infura network.\n */\nexport type NetworkControllerInfuraIsUnblockedEvent = {\n  type: 'NetworkController:infuraIsUnblocked';\n  payload: [];\n};\n\nexport type NetworkControllerEvents =\n  | NetworkControllerStateChangeEvent\n  | NetworkControllerNetworkWillChangeEvent\n  | NetworkControllerNetworkDidChangeEvent\n  | NetworkControllerInfuraIsBlockedEvent\n  | NetworkControllerInfuraIsUnblockedEvent;\n\nexport type NetworkControllerGetStateAction = {\n  type: `NetworkController:getState`;\n  handler: () => NetworkState;\n};\n\nexport type NetworkControllerGetProviderConfigAction = {\n  type: `NetworkController:getProviderConfig`;\n  handler: () => ProviderConfig;\n};\n\nexport type NetworkControllerGetEthQueryAction = {\n  type: `NetworkController:getEthQuery`;\n  handler: () => EthQuery | undefined;\n};\n\nexport type NetworkControllerActions =\n  | NetworkControllerGetStateAction\n  | NetworkControllerGetProviderConfigAction\n  | NetworkControllerGetEthQueryAction;\n\nexport type NetworkControllerMessenger = RestrictedControllerMessenger<\n  typeof name,\n  NetworkControllerActions,\n  NetworkControllerEvents,\n  string,\n  string\n>;\n\nexport type NetworkControllerOptions = {\n  messenger: NetworkControllerMessenger;\n  trackMetaMetricsEvent: () => void;\n  infuraProjectId: string;\n  state?: Partial<NetworkState>;\n};\n\nexport const defaultState: NetworkState = {\n  networkId: null,\n  networkStatus: NetworkStatus.Unknown,\n  providerConfig: {\n    type: NetworkType.mainnet,\n    chainId: ChainId.mainnet,\n  },\n  networkDetails: {\n    EIPS: {},\n  },\n  networkConfigurations: {},\n};\n\ntype MetaMetricsEventPayload = {\n  event: string;\n  category: string;\n  referrer?: { url: string };\n  actionId?: number;\n  environmentType?: string;\n  properties?: unknown;\n  sensitiveProperties?: unknown;\n  revenue?: number;\n  currency?: string;\n  value?: number;\n};\n\ntype NetworkConfigurationId = string;\n\n/**\n * The string that uniquely identifies an Infura network client.\n */\ntype BuiltInNetworkClientId = InfuraNetworkType;\n\n/**\n * The string that uniquely identifies a custom network client.\n */\ntype CustomNetworkClientId = string;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedBuiltInNetworkClientRegistry = Record<\n  BuiltInNetworkClientId,\n  AutoManagedNetworkClient<InfuraNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks.\n */\ntype AutoManagedCustomNetworkClientRegistry = Record<\n  CustomNetworkClientId,\n  AutoManagedNetworkClient<CustomNetworkClientConfiguration>\n>;\n\n/**\n * The collection of auto-managed network clients that map to Infura networks\n * as well as custom networks that users have added.\n */\ntype AutoManagedNetworkClientRegistry = {\n  [NetworkClientType.Infura]: AutoManagedBuiltInNetworkClientRegistry;\n  [NetworkClientType.Custom]: AutoManagedCustomNetworkClientRegistry;\n};\n\n/**\n * Controller that creates and manages an Ethereum network provider.\n */\nexport class NetworkController extends BaseControllerV2<\n  typeof name,\n  NetworkState,\n  NetworkControllerMessenger\n> {\n  #ethQuery?: EthQuery;\n\n  #infuraProjectId: string;\n\n  #trackMetaMetricsEvent: (event: MetaMetricsEventPayload) => void;\n\n  #previousProviderConfig: ProviderConfig;\n\n  #providerProxy: ProviderProxy | undefined;\n\n  #provider: ProxyWithAccessibleTarget<Provider> | undefined;\n\n  #blockTrackerProxy: BlockTrackerProxy | undefined;\n\n  #autoManagedNetworkClientRegistry?: AutoManagedNetworkClientRegistry;\n\n  constructor({\n    messenger,\n    state,\n    infuraProjectId,\n    trackMetaMetricsEvent,\n  }: NetworkControllerOptions) {\n    super({\n      name,\n      metadata: {\n        networkId: {\n          persist: true,\n          anonymous: false,\n        },\n        networkStatus: {\n          persist: true,\n          anonymous: false,\n        },\n        networkDetails: {\n          persist: true,\n          anonymous: false,\n        },\n        providerConfig: {\n          persist: true,\n          anonymous: false,\n        },\n        networkConfigurations: {\n          persist: true,\n          anonymous: false,\n        },\n      },\n      messenger,\n      state: { ...defaultState, ...state },\n    });\n    if (!infuraProjectId || typeof infuraProjectId !== 'string') {\n      throw new Error('Invalid Infura project ID');\n    }\n    this.#infuraProjectId = infuraProjectId;\n    this.#trackMetaMetricsEvent = trackMetaMetricsEvent;\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getProviderConfig`,\n      () => {\n        return this.state.providerConfig;\n      },\n    );\n\n    this.messagingSystem.registerActionHandler(\n      `${this.name}:getEthQuery`,\n      () => {\n        return this.#ethQuery;\n      },\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n  }\n\n  /**\n   * Accesses the provider and block tracker for the currently selected network.\n   *\n   * @returns The proxy and block tracker proxies.\n   */\n  getProviderAndBlockTracker(): {\n    provider: SwappableProxy<ProxyWithAccessibleTarget<Provider>> | undefined;\n    blockTracker:\n      | SwappableProxy<ProxyWithAccessibleTarget<BlockTracker>>\n      | undefined;\n  } {\n    return {\n      provider: this.#providerProxy,\n      blockTracker: this.#blockTrackerProxy,\n    };\n  }\n\n  /**\n   * Returns all of the network clients that have been created so far, keyed by\n   * their identifier in the network client registry. This collection represents\n   * not only built-in networks but also any custom networks that consumers have\n   * added.\n   *\n   * @returns The list of known network clients.\n   */\n  getNetworkClientsById(): AutoManagedBuiltInNetworkClientRegistry &\n    AutoManagedCustomNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    return Object.assign(\n      {},\n      autoManagedNetworkClientRegistry[NetworkClientType.Infura],\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom],\n    );\n  }\n\n  /**\n   * Executes a series of steps to apply the changes to the provider config:\n   *\n   * 1. Notifies subscribers that the network is about to change.\n   * 2. Clears state associated with the current network.\n   * 3. Looks up a known and preinitialized network client matching the provider\n   * config and re-points the provider and block tracker proxy to it.\n   * 4. Notifies subscribers that the network has changed.\n   */\n  async #refreshNetwork() {\n    this.messagingSystem.publish('NetworkController:networkWillChange');\n    this.update((state) => {\n      state.networkId = null;\n      state.networkStatus = NetworkStatus.Unknown;\n      state.networkDetails = {\n        EIPS: {},\n      };\n    });\n    this.#applyNetworkSelection();\n    this.messagingSystem.publish('NetworkController:networkDidChange');\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Populates the network clients and establishes the initial network based on\n   * the provider configuration in state.\n   */\n  async initializeProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.#applyNetworkSelection();\n    await this.lookupNetwork();\n  }\n\n  /**\n   * Fetches the network ID for the network, ensuring that it is a hex string.\n   *\n   * @returns A promise that either resolves to the network ID, or rejects with\n   * an error.\n   * @throws If the network ID of the network is not a valid hex string.\n   */\n  async #getNetworkId(): Promise<NetworkId> {\n    const possibleNetworkId = await new Promise<string>((resolve, reject) => {\n      if (!this.#ethQuery) {\n        throw new Error('Provider has not been initialized');\n      }\n\n      this.#ethQuery.sendAsync(\n        { method: 'net_version' },\n        (error: unknown, result?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(result as string);\n          }\n        },\n      );\n    });\n\n    return convertNetworkId(possibleNetworkId);\n  }\n\n  /**\n   * Performs side effects after switching to a network. If the network is\n   * available, updates the network state with the network ID of the network and\n   * stores whether the network supports EIP-1559; otherwise clears said\n   * information about the network that may have been previously stored.\n   *\n   * @fires infuraIsBlocked if the network is Infura-supported and is blocking\n   * requests.\n   * @fires infuraIsUnblocked if the network is Infura-supported and is not\n   * blocking requests, or if the network is not Infura-supported.\n   */\n  async lookupNetwork() {\n    if (!this.#ethQuery) {\n      return;\n    }\n\n    const isInfura = isInfuraProviderConfig(this.state.providerConfig);\n\n    let networkChanged = false;\n    const listener = () => {\n      networkChanged = true;\n      this.messagingSystem.unsubscribe(\n        'NetworkController:networkDidChange',\n        listener,\n      );\n    };\n    this.messagingSystem.subscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    let updatedNetworkStatus: NetworkStatus;\n    let updatedNetworkId: NetworkId | null = null;\n    let updatedIsEIP1559Compatible: boolean | undefined;\n\n    try {\n      const [networkId, isEIP1559Compatible] = await Promise.all([\n        this.#getNetworkId(),\n        this.#determineEIP1559Compatibility(),\n      ]);\n      updatedNetworkStatus = NetworkStatus.Available;\n      updatedNetworkId = networkId;\n      updatedIsEIP1559Compatible = isEIP1559Compatible;\n    } catch (error) {\n      if (isErrorWithCode(error)) {\n        let responseBody;\n        if (\n          isInfura &&\n          hasProperty(error, 'message') &&\n          typeof error.message === 'string'\n        ) {\n          try {\n            responseBody = JSON.parse(error.message);\n          } catch {\n            // error.message must not be JSON\n          }\n        }\n\n        if (\n          isPlainObject(responseBody) &&\n          responseBody.error === INFURA_BLOCKED_KEY\n        ) {\n          updatedNetworkStatus = NetworkStatus.Blocked;\n        } else if (error.code === errorCodes.rpc.internal) {\n          updatedNetworkStatus = NetworkStatus.Unknown;\n        } else {\n          updatedNetworkStatus = NetworkStatus.Unavailable;\n        }\n      } else {\n        log('NetworkController - could not determine network status', error);\n        updatedNetworkStatus = NetworkStatus.Unknown;\n      }\n    }\n\n    if (networkChanged) {\n      // If the network has changed, then `lookupNetwork` either has been or is\n      // in the process of being called, so we don't need to go further.\n      return;\n    }\n    this.messagingSystem.unsubscribe(\n      'NetworkController:networkDidChange',\n      listener,\n    );\n\n    this.update((state) => {\n      state.networkId = updatedNetworkId;\n      state.networkStatus = updatedNetworkStatus;\n      if (updatedIsEIP1559Compatible === undefined) {\n        delete state.networkDetails.EIPS[1559];\n      } else {\n        state.networkDetails.EIPS[1559] = updatedIsEIP1559Compatible;\n      }\n    });\n\n    if (isInfura) {\n      if (updatedNetworkStatus === NetworkStatus.Available) {\n        this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n      } else if (updatedNetworkStatus === NetworkStatus.Blocked) {\n        this.messagingSystem.publish('NetworkController:infuraIsBlocked');\n      }\n    } else {\n      // Always publish infuraIsUnblocked regardless of network status to\n      // prevent consumers from being stuck in a blocked state if they were\n      // previously connected to an Infura network that was blocked\n      this.messagingSystem.publish('NetworkController:infuraIsUnblocked');\n    }\n  }\n\n  /**\n   * Convenience method to update provider network type settings.\n   *\n   * @param type - Human readable network name.\n   */\n  async setProviderType(type: InfuraNetworkType) {\n    assert.notStrictEqual(\n      type,\n      NetworkType.rpc,\n      `NetworkController - cannot call \"setProviderType\" with type \"${NetworkType.rpc}\". Use \"setActiveNetwork\"`,\n    );\n    assert.ok(\n      isInfuraProviderType(type),\n      `Unknown Infura provider type \"${type}\".`,\n    );\n\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    // If testnet the ticker symbol should use a testnet prefix\n    const ticker =\n      type in NetworksTicker && NetworksTicker[type].length > 0\n        ? NetworksTicker[type]\n        : 'ETH';\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig.type = type;\n      state.providerConfig.ticker = ticker;\n      state.providerConfig.chainId = ChainId[type];\n      state.providerConfig.rpcPrefs = BUILT_IN_NETWORKS[type].rpcPrefs;\n      state.providerConfig.rpcUrl = undefined;\n      state.providerConfig.nickname = undefined;\n      state.providerConfig.id = undefined;\n    });\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Convenience method to update provider RPC settings.\n   *\n   * @param networkConfigurationId - The unique id for the network configuration to set as the active provider.\n   */\n  async setActiveNetwork(networkConfigurationId: string) {\n    this.#previousProviderConfig = this.state.providerConfig;\n\n    const targetNetwork =\n      this.state.networkConfigurations[networkConfigurationId];\n\n    if (!targetNetwork) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig.type = NetworkType.rpc;\n      state.providerConfig.rpcUrl = targetNetwork.rpcUrl;\n      state.providerConfig.chainId = targetNetwork.chainId;\n      state.providerConfig.ticker = targetNetwork.ticker;\n      state.providerConfig.nickname = targetNetwork.nickname;\n      state.providerConfig.rpcPrefs = targetNetwork.rpcPrefs;\n      state.providerConfig.id = targetNetwork.id;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Retrieves the latest block with retry for the network.\n   *\n   * @param maxAttempts - The maximum number of retries to attempt retrieving the latest block. Defaults to 3.\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  async #getLatestBlockWithRetry(maxAttempts = 3): Promise<Block | null> {\n    let latestBlock;\n    const retryInterval = 500;\n    for (let attempts = 0; attempts <= maxAttempts; attempts++) {\n      latestBlock = await this.#getLatestBlock();\n\n      if (latestBlock) {\n        return latestBlock;\n      }\n\n      await new Promise((resolve) => setTimeout(resolve, retryInterval));\n    }\n    return null;\n  }\n\n  /**\n   * Fetches the latest block for the network.\n   *\n   * @returns A promise that either resolves to the block header or null if\n   * there is no latest block, or rejects with an error.\n   */\n  #getLatestBlock(): Promise<Block> {\n    return new Promise((resolve, reject) => {\n      if (!this.#ethQuery) {\n        throw new Error('Provider has not been initialized');\n      }\n\n      this.#ethQuery.sendAsync(\n        { method: 'eth_getBlockByNumber', params: ['latest', false] },\n        (error: unknown, block?: unknown) => {\n          if (error) {\n            reject(error);\n          } else {\n            // TODO: Validate this type\n            resolve(block as Block);\n          }\n        },\n      );\n    });\n  }\n\n  /**\n   * Determines whether the network supports EIP-1559 by checking whether the\n   * latest block has a `baseFeePerGas` property, then updates state\n   * appropriately.\n   *\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * and false otherwise.\n   */\n  async getEIP1559Compatibility() {\n    const { EIPS } = this.state.networkDetails;\n\n    if (EIPS[1559] !== undefined) {\n      return EIPS[1559];\n    }\n\n    if (!this.#ethQuery) {\n      return false;\n    }\n\n    const isEIP1559Compatible = await this.#determineEIP1559Compatibility();\n    this.update((state) => {\n      if (isEIP1559Compatible !== undefined) {\n        state.networkDetails.EIPS[1559] = isEIP1559Compatible;\n      }\n    });\n    return isEIP1559Compatible;\n  }\n\n  /**\n   * Retrieves the latest block from the currently selected network; if the\n   * block has a `baseFeePerGas` property, then we know that the network\n   * supports EIP-1559; otherwise it doesn't. Returns undefined if unable to\n   * retrieve the last block.\n   *\n   * @returns A promise that resolves to true if the network supports EIP-1559\n   * and false otherwise.\n   */\n  async #determineEIP1559Compatibility(): Promise<boolean | undefined> {\n    const latestBlock = await this.#getLatestBlock();\n\n    if (!latestBlock) {\n      return undefined;\n    }\n\n    return latestBlock.baseFeePerGas !== undefined;\n  }\n\n  /**\n   * Re-initializes the provider and block tracker for the current network.\n   */\n  async resetConnection() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Adds a new custom network or updates the information for an existing\n   * network.\n   *\n   * This may involve updating the `networkConfigurations` property in\n   * state as well and/or adding a new network client to the network client\n   * registry. The `rpcUrl` and `chainId` of the given object are used to\n   * determine which action to take:\n   *\n   * - If the `rpcUrl` corresponds to an existing network configuration\n   * (case-insensitively), then it is overwritten with the object. Furthermore,\n   * if the `chainId` is different from the existing network configuration, then\n   * the existing network client is replaced with a new one.\n   * - If the `rpcUrl` does not correspond to an existing network configuration\n   * (case-insensitively), then the object is used to add a new network\n   * configuration along with a new network client.\n   *\n   * @param networkConfiguration - The network configuration to add or update.\n   * @param options - Additional configuration options.\n   * @param options.referrer - Used to create a metrics event; the site from which the call originated, or 'metamask' for internal calls.\n   * @param options.source - Used to create a metrics event; where the event originated (i.e. from a dapp or from the network form).\n   * @param options.setActive - If true, switches to the network upon adding or updating it (default: false).\n   * @returns The ID for the added or updated network configuration.\n   */\n  async upsertNetworkConfiguration(\n    networkConfiguration: NetworkConfiguration,\n    {\n      referrer,\n      source,\n      setActive = false,\n    }: {\n      referrer: string;\n      source: string;\n      setActive?: boolean;\n    },\n  ): Promise<string> {\n    const sanitizedNetworkConfiguration: NetworkConfiguration = pick(\n      networkConfiguration,\n      ['rpcUrl', 'chainId', 'ticker', 'nickname', 'rpcPrefs'],\n    );\n    const { rpcUrl, chainId, ticker } = sanitizedNetworkConfiguration;\n\n    assertIsStrictHexString(chainId);\n    if (!isSafeChainId(chainId)) {\n      throw new Error(\n        `Invalid chain ID \"${chainId}\": numerical value greater than max safe value.`,\n      );\n    }\n    if (!rpcUrl) {\n      throw new Error(\n        'An rpcUrl is required to add or update network configuration',\n      );\n    }\n    if (!referrer || !source) {\n      throw new Error(\n        'referrer and source are required arguments for adding or updating a network configuration',\n      );\n    }\n    try {\n      new URL(rpcUrl);\n    } catch (e: any) {\n      if (e.message.includes('Invalid URL')) {\n        throw new Error('rpcUrl must be a valid URL');\n      }\n    }\n    if (!ticker) {\n      throw new Error(\n        'A ticker is required to add or update networkConfiguration',\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    const existingNetworkConfiguration = Object.values(\n      this.state.networkConfigurations,\n    ).find(\n      (networkConfig) =>\n        networkConfig.rpcUrl.toLowerCase() === rpcUrl.toLowerCase(),\n    );\n    const upsertedNetworkConfigurationId = existingNetworkConfiguration\n      ? existingNetworkConfiguration.id\n      : random();\n    const networkClientId = buildCustomNetworkClientId(\n      upsertedNetworkConfigurationId,\n    );\n\n    this.update((state) => {\n      state.networkConfigurations[upsertedNetworkConfigurationId] = {\n        id: upsertedNetworkConfigurationId,\n        ...sanitizedNetworkConfiguration,\n      };\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    const shouldDestroyExistingNetworkClient =\n      existingAutoManagedNetworkClient &&\n      existingAutoManagedNetworkClient.configuration.chainId !== chainId;\n    if (shouldDestroyExistingNetworkClient) {\n      existingAutoManagedNetworkClient.destroy();\n    }\n    if (\n      !existingAutoManagedNetworkClient ||\n      shouldDestroyExistingNetworkClient\n    ) {\n      customNetworkClientRegistry[networkClientId] =\n        createAutoManagedNetworkClient({\n          type: NetworkClientType.Custom,\n          chainId,\n          rpcUrl,\n        });\n    }\n\n    if (!existingNetworkConfiguration) {\n      this.#trackMetaMetricsEvent({\n        event: 'Custom Network Added',\n        category: 'Network',\n        referrer: {\n          url: referrer,\n        },\n        properties: {\n          chain_id: chainId,\n          symbol: ticker,\n          source,\n        },\n      });\n    }\n\n    if (setActive) {\n      await this.setActiveNetwork(upsertedNetworkConfigurationId);\n    }\n\n    return upsertedNetworkConfigurationId;\n  }\n\n  /**\n   * Removes a custom network from state.\n   *\n   * This involves updating the `networkConfigurations` property in state as\n   * well and removing the network client that corresponds to the network from\n   * the client registry.\n   *\n   * @param networkConfigurationId - The ID of an existing network\n   * configuration.\n   */\n  removeNetworkConfiguration(networkConfigurationId: string) {\n    if (!this.state.networkConfigurations[networkConfigurationId]) {\n      throw new Error(\n        `networkConfigurationId ${networkConfigurationId} does not match a configured networkConfiguration`,\n      );\n    }\n\n    const autoManagedNetworkClientRegistry =\n      this.#ensureAutoManagedNetworkClientRegistryPopulated();\n    const networkClientId = buildCustomNetworkClientId(networkConfigurationId);\n\n    this.update((state) => {\n      delete state.networkConfigurations[networkConfigurationId];\n    });\n\n    const customNetworkClientRegistry =\n      autoManagedNetworkClientRegistry[NetworkClientType.Custom];\n    const existingAutoManagedNetworkClient =\n      customNetworkClientRegistry[networkClientId];\n    existingAutoManagedNetworkClient.destroy();\n    delete customNetworkClientRegistry[networkClientId];\n  }\n\n  /**\n   * Switches to the previously selected network, assuming that there is one\n   * (if not and `initializeProvider` has not been previously called, then this\n   * method is equivalent to calling `resetConnection`).\n   */\n  async rollbackToPreviousProvider() {\n    this.#ensureAutoManagedNetworkClientRegistryPopulated();\n\n    this.update((state) => {\n      state.providerConfig = this.#previousProviderConfig;\n    });\n\n    await this.#refreshNetwork();\n  }\n\n  /**\n   * Deactivates the controller, stopping any ongoing polling.\n   *\n   * In-progress requests will not be aborted.\n   */\n  async destroy() {\n    await this.#blockTrackerProxy?.destroy();\n  }\n\n  /**\n   * Updates the controller using the given backup data.\n   *\n   * @param backup - The data that has been backed up.\n   * @param backup.networkConfigurations - Network configurations in the backup.\n   */\n  loadBackup({\n    networkConfigurations,\n  }: {\n    networkConfigurations: NetworkState['networkConfigurations'];\n  }): void {\n    this.update((state) => {\n      state.networkConfigurations = {\n        ...state.networkConfigurations,\n        ...networkConfigurations,\n      };\n    });\n  }\n\n  /**\n   * Before accessing or switching the network, the registry of network clients\n   * needs to be populated. Otherwise, `#applyNetworkSelection` and\n   * `getNetworkClients` will throw an error. This method checks to see if the\n   * population step has happened yet, and if not, makes it happen.\n   *\n   * @returns The populated network client registry.\n   */\n  #ensureAutoManagedNetworkClientRegistryPopulated(): AutoManagedNetworkClientRegistry {\n    const autoManagedNetworkClientRegistry =\n      this.#autoManagedNetworkClientRegistry ??\n      this.#createAutoManagedNetworkClientRegistry();\n    this.#autoManagedNetworkClientRegistry = autoManagedNetworkClientRegistry;\n    return autoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the registry of network clients based on the set of built-in\n   * networks as well as the custom networks in state.\n   *\n   * @returns The network clients keyed by ID.\n   */\n  #createAutoManagedNetworkClientRegistry(): AutoManagedNetworkClientRegistry {\n    return [\n      ...this.#buildIdentifiedInfuraNetworkClientConfigurations(),\n      ...this.#buildIdentifiedCustomNetworkClientConfigurations(),\n      ...this.#buildIdentifiedNetworkClientConfigurationsFromProviderConfig(),\n    ].reduce(\n      (\n        registry,\n        [networkClientType, networkClientId, networkClientConfiguration],\n      ) => {\n        const autoManagedNetworkClient = createAutoManagedNetworkClient(\n          networkClientConfiguration,\n        );\n        if (networkClientId in registry[networkClientType]) {\n          return registry;\n        }\n        return {\n          ...registry,\n          [networkClientType]: {\n            ...registry[networkClientType],\n            [networkClientId]: autoManagedNetworkClient,\n          },\n        };\n      },\n      {\n        [NetworkClientType.Infura]: {},\n        [NetworkClientType.Custom]: {},\n      },\n    ) as AutoManagedNetworkClientRegistry;\n  }\n\n  /**\n   * Constructs the list of network clients for built-in networks (that is,\n   * the subset of the networks we know Infura supports that consumers do not\n   * need to explicitly add).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedInfuraNetworkClientConfigurations(): [\n    NetworkClientType.Infura,\n    BuiltInNetworkClientId,\n    InfuraNetworkClientConfiguration,\n  ][] {\n    return knownKeysOf(InfuraNetworkType).map((network) => {\n      const networkClientId = buildInfuraNetworkClientId(network);\n      const networkClientConfiguration: InfuraNetworkClientConfiguration = {\n        type: NetworkClientType.Infura,\n        network,\n        infuraProjectId: this.#infuraProjectId,\n      };\n      return [\n        NetworkClientType.Infura,\n        networkClientId,\n        networkClientConfiguration,\n      ];\n    });\n  }\n\n  /**\n   * Constructs the list of network clients for custom networks (that is, those\n   * which consumers have added via `networkConfigurations`).\n   *\n   * @returns The network clients.\n   */\n  #buildIdentifiedCustomNetworkClientConfigurations(): [\n    NetworkClientType.Custom,\n    CustomNetworkClientId,\n    CustomNetworkClientConfiguration,\n  ][] {\n    return Object.entries(this.state.networkConfigurations).map(\n      ([networkConfigurationId, networkConfiguration]) => {\n        if (networkConfiguration.chainId === undefined) {\n          throw new Error('chainId must be provided for custom RPC endpoints');\n        }\n        if (networkConfiguration.rpcUrl === undefined) {\n          throw new Error('rpcUrl must be provided for custom RPC endpoints');\n        }\n        const networkClientId = buildCustomNetworkClientId(\n          networkConfigurationId,\n        );\n        const networkClientConfiguration: CustomNetworkClientConfiguration = {\n          type: NetworkClientType.Custom,\n          chainId: networkConfiguration.chainId,\n          rpcUrl: networkConfiguration.rpcUrl,\n        };\n        return [\n          NetworkClientType.Custom,\n          networkClientId,\n          networkClientConfiguration,\n        ];\n      },\n    );\n  }\n\n  /**\n   * Converts the provider config object in state to a network client\n   * configuration object.\n   *\n   * @returns The network client config.\n   * @throws If the provider config is of type \"rpc\" and lacks either a\n   * `chainId` or an `rpcUrl`.\n   */\n  #buildIdentifiedNetworkClientConfigurationsFromProviderConfig():\n    | [\n        [\n          NetworkClientType.Custom,\n          CustomNetworkClientId,\n          CustomNetworkClientConfiguration,\n        ],\n      ]\n    | [] {\n    const { providerConfig } = this.state;\n\n    if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const networkClientConfiguration: CustomNetworkClientConfiguration = {\n        chainId: providerConfig.chainId,\n        rpcUrl: providerConfig.rpcUrl,\n        type: NetworkClientType.Custom,\n      };\n      return [\n        [NetworkClientType.Custom, networkClientId, networkClientConfiguration],\n      ];\n    }\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      return [];\n    }\n\n    throw new Error(`Unrecognized network type: '${providerConfig.type}'`);\n  }\n\n  /**\n   * Uses the information in the provider config object to look up a known and\n   * preinitialized network client. Once a network client is found, updates the\n   * provider and block tracker proxy to point to those from the network client,\n   * then finally creates an EthQuery that points to the provider proxy.\n   *\n   * @throws If no network client could be found matching the current provider\n   * config.\n   */\n  #applyNetworkSelection() {\n    if (!this.#autoManagedNetworkClientRegistry) {\n      throw new Error(\n        'initializeProvider must be called first in order to switch the network',\n      );\n    }\n\n    const { providerConfig } = this.state;\n\n    let autoManagedNetworkClient: AutoManagedNetworkClient<NetworkClientConfiguration>;\n\n    if (isInfuraProviderConfig(providerConfig)) {\n      const networkClientType = NetworkClientType.Infura;\n      const networkClientId = buildInfuraNetworkClientId(providerConfig);\n      const builtInNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = builtInNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find custom network matching ${networkClientId}`,\n        );\n      }\n    } else if (isCustomProviderConfig(providerConfig)) {\n      validateCustomProviderConfig(providerConfig);\n      const networkClientType = NetworkClientType.Custom;\n      const networkClientId = buildCustomNetworkClientId(\n        providerConfig,\n        this.state.networkConfigurations,\n      );\n      const customNetworkClientRegistry =\n        this.#autoManagedNetworkClientRegistry[networkClientType];\n      autoManagedNetworkClient = customNetworkClientRegistry[networkClientId];\n      if (!autoManagedNetworkClient) {\n        throw new Error(\n          `Could not find built-in network matching ${networkClientId}`,\n        );\n      }\n    } else {\n      throw new Error('Could not determine type of provider config');\n    }\n\n    const { provider, blockTracker } = autoManagedNetworkClient;\n\n    if (this.#providerProxy) {\n      this.#providerProxy.setTarget(provider);\n    } else {\n      this.#providerProxy = createEventEmitterProxy(provider);\n    }\n    this.#provider = provider;\n\n    if (this.#blockTrackerProxy) {\n      this.#blockTrackerProxy.setTarget(blockTracker);\n    } else {\n      this.#blockTrackerProxy = createEventEmitterProxy(blockTracker, {\n        eventFilter: 'skipInternal',\n      });\n    }\n\n    this.#ethQuery = new EthQuery(this.#providerProxy);\n  }\n}\n"]}
\ No newline at end of file
