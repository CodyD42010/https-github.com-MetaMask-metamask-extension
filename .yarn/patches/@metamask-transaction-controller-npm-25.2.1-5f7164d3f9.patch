diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 9eab1ebeb5a0b38fb63e0ab8b470646b8106a4b4..6904c17bfcfc0581f292b9bf9dd8e016ba91cea2 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -4,7 +4,7 @@
 
 
 
-var _chunk7BG5XOXJjs = require('./chunk-7BG5XOXJ.js');
+var _chunkR7DZLQGJjs = require('./chunk-R7DZLQGJ.js');
 require('./chunk-VH47Q6TS.js');
 require('./chunk-RQKICZYP.js');
 require('./chunk-QP75SWIQ.js');
@@ -36,5 +36,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.ApprovalState = _chunk7BG5XOXJjs.ApprovalState; exports.CANCEL_RATE = _chunk7BG5XOXJjs.CANCEL_RATE; exports.HARDFORK = _chunk7BG5XOXJjs.HARDFORK; exports.SPEED_UP_RATE = _chunk7BG5XOXJjs.SPEED_UP_RATE; exports.TransactionController = _chunk7BG5XOXJjs.TransactionController;
+exports.ApprovalState = _chunkR7DZLQGJjs.ApprovalState; exports.CANCEL_RATE = _chunkR7DZLQGJjs.CANCEL_RATE; exports.HARDFORK = _chunkR7DZLQGJjs.HARDFORK; exports.SPEED_UP_RATE = _chunkR7DZLQGJjs.SPEED_UP_RATE; exports.TransactionController = _chunkR7DZLQGJjs.TransactionController;
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/chunk-R7DZLQGJ.js b/dist/chunk-R7DZLQGJ.js
new file mode 100644
index 0000000000000000000000000000000000000000..c0c53e65e55d8a39c0bc8afbb13188713bafda3b
--- /dev/null
+++ b/dist/chunk-R7DZLQGJ.js
@@ -0,0 +1,2388 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+var _chunkVH47Q6TSjs = require('./chunk-VH47Q6TS.js');
+
+
+
+
+var _chunkRQKICZYPjs = require('./chunk-RQKICZYP.js');
+
+
+
+var _chunkQP75SWIQjs = require('./chunk-QP75SWIQ.js');
+
+
+
+var _chunkZNZEJDOEjs = require('./chunk-ZNZEJDOE.js');
+
+
+var _chunkGC77BSQZjs = require('./chunk-GC77BSQZ.js');
+
+
+var _chunkHS277C77js = require('./chunk-HS277C77.js');
+
+
+var _chunkQEX3QMSLjs = require('./chunk-QEX3QMSL.js');
+
+
+var _chunkR7NJVDWNjs = require('./chunk-R7NJVDWN.js');
+
+
+var _chunkDTDTOMTBjs = require('./chunk-DTDTOMTB.js');
+
+
+var _chunkNRWEI43Qjs = require('./chunk-NRWEI43Q.js');
+
+
+var _chunk5XBULBP2js = require('./chunk-5XBULBP2.js');
+
+
+var _chunk7LXE4KHVjs = require('./chunk-7LXE4KHV.js');
+
+
+var _chunkFHG5GY6Fjs = require('./chunk-FHG5GY6F.js');
+
+
+var _chunkPF3UOCRWjs = require('./chunk-PF3UOCRW.js');
+
+
+var _chunk5IHLDAOFjs = require('./chunk-5IHLDAOF.js');
+
+
+
+var _chunk5OQ373JSjs = require('./chunk-5OQ373JS.js');
+
+
+
+
+
+
+
+
+
+
+
+var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
+
+
+var _chunkF3CMU2DMjs = require('./chunk-F3CMU2DM.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TransactionController.ts
+var _common = require('@ethereumjs/common');
+var _tx = require('@ethereumjs/tx');
+var _util = require('@ethereumjs/util');
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _networkcontroller = require('@metamask/network-controller');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _ethmethodregistry = require('eth-method-registry');
+var _events = require('events');
+var _lodash = require('lodash');
+var _noncetracker = require('nonce-tracker');
+var _uuid = require('uuid');
+var metadata = {
+  transactions: {
+    persist: true,
+    anonymous: false
+  },
+  methodData: {
+    persist: true,
+    anonymous: false
+  },
+  lastFetchedBlockNumbers: {
+    persist: true,
+    anonymous: false
+  }
+};
+var HARDFORK = _common.Hardfork.London;
+var CANCEL_RATE = 1.1;
+var SPEED_UP_RATE = 1.1;
+var controllerName = "TransactionController";
+var ApprovalState = /* @__PURE__ */ ((ApprovalState2) => {
+  ApprovalState2["Approved"] = "approved";
+  ApprovalState2["NotApproved"] = "not-approved";
+  ApprovalState2["SkippedViaBeforePublishHook"] = "skipped-via-before-publish-hook";
+  return ApprovalState2;
+})(ApprovalState || {});
+function getDefaultTransactionControllerState() {
+  return {
+    methodData: {},
+    transactions: [],
+    lastFetchedBlockNumbers: {}
+  };
+}
+var _internalEvents, _incomingTransactionOptions, _pendingTransactionOptions, _transactionHistoryLimit, _isSimulationEnabled, _multichainTrackingHelper, _createNonceTracker, createNonceTracker_fn, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn, _createPendingTransactionTracker, createPendingTransactionTracker_fn, _checkForPendingTransactionAndStartPolling, _stopAllTracking, stopAllTracking_fn, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn, _getGasFeeFlows, getGasFeeFlows_fn, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn, _updateTransactionInternal, updateTransactionInternal_fn, _checkIfTransactionParamsUpdated, checkIfTransactionParamsUpdated_fn, _onTransactionParamsUpdated, onTransactionParamsUpdated_fn, _updateSimulationData, updateSimulationData_fn;
+var TransactionController = class extends _basecontroller.BaseController {
+  /**
+   * Constructs a TransactionController.
+   *
+   * @param options - The controller options.
+   * @param options.blockTracker - The block tracker used to poll for new blocks data.
+   * @param options.disableHistory - Whether to disable storing history in transaction metadata.
+   * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.
+   * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.
+   * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
+   * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
+   * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+   * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
+   * @param options.getNetworkClientRegistry - Gets the network client registry.
+   * @param options.getNetworkState - Gets the state of the network controller.
+   * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.
+   * @param options.getSavedGasFees - Gets the saved gas fee config.
+   * @param options.getSelectedAddress - Gets the address of the currently selected account.
+   * @param options.incomingTransactions - Configuration options for incoming transaction support.
+   * @param options.isMultichainEnabled - Enable multichain support.
+   * @param options.isSimulationEnabled - Whether new transactions will be automatically simulated.
+   * @param options.messenger - The controller messenger.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.pendingTransactions - Configuration options for pending transaction support.
+   * @param options.provider - The provider used to create the underlying EthQuery instance.
+   * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
+   * @param options.sign - Function used to sign transactions.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.transactionHistoryLimit - Transaction history limit.
+   * @param options.hooks - The controller hooks.
+   */
+  constructor({
+    blockTracker,
+    disableHistory,
+    disableSendFlowHistory,
+    disableSwaps,
+    getCurrentAccountEIP1559Compatibility,
+    getCurrentNetworkEIP1559Compatibility,
+    getExternalPendingTransactions,
+    getGasFeeEstimates,
+    getNetworkClientRegistry,
+    getNetworkState,
+    getPermittedAccounts,
+    getSavedGasFees,
+    getSelectedAddress,
+    incomingTransactions = {},
+    isMultichainEnabled = false,
+    isSimulationEnabled,
+    messenger,
+    onNetworkStateChange,
+    pendingTransactions = {},
+    provider,
+    securityProviderRequest,
+    sign,
+    state,
+    transactionHistoryLimit = 40,
+    hooks
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultTransactionControllerState(),
+        ...state
+      }
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createNonceTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createIncomingTransactionHelper);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createPendingTransactionTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopAllTracking);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removeIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removePendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addPendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNonceTrackerPendingTransactions);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getGasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLayer1GasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionInternal);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkIfTransactionParamsUpdated);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onTransactionParamsUpdated);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateSimulationData);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _internalEvents, new (0, _events.EventEmitter)());
+    this.inProcessOfSigning = /* @__PURE__ */ new Set();
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _incomingTransactionOptions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pendingTransactionOptions, void 0);
+    this.signAbortCallbacks = /* @__PURE__ */ new Map();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _transactionHistoryLimit, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isSimulationEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _multichainTrackingHelper, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkForPendingTransactionAndStartPolling, () => {
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).checkForPendingTransactionAndStartPolling();
+    });
+    this.messagingSystem = messenger;
+    this.getNetworkState = getNetworkState;
+    this.isSendFlowHistoryDisabled = disableSendFlowHistory ?? false;
+    this.isHistoryDisabled = disableHistory ?? false;
+    this.isSwapsDisabled = disableSwaps ?? false;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isSimulationEnabled, isSimulationEnabled ?? (() => true));
+    this.registry = new (0, _ethmethodregistry.MethodRegistry)({ provider });
+    this.getSavedGasFees = getSavedGasFees ?? ((_chainId) => void 0);
+    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility ?? (() => Promise.resolve(true));
+    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
+    this.getGasFeeEstimates = getGasFeeEstimates || (() => Promise.resolve({}));
+    this.getPermittedAccounts = getPermittedAccounts;
+    this.getSelectedAddress = getSelectedAddress;
+    this.getExternalPendingTransactions = getExternalPendingTransactions ?? (() => []);
+    this.securityProviderRequest = securityProviderRequest;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _incomingTransactionOptions, incomingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pendingTransactionOptions, pendingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _transactionHistoryLimit, transactionHistoryLimit);
+    this.sign = sign;
+    this.afterSign = hooks?.afterSign ?? (() => true);
+    this.beforeApproveOnInit = hooks?.beforeApproveOnInit ?? (() => true);
+    this.beforeCheckPendingTransaction = hooks?.beforeCheckPendingTransaction ?? /* istanbul ignore next */
+    (() => true);
+    this.beforePublish = hooks?.beforePublish ?? (() => true);
+    this.getAdditionalSignArguments = hooks?.getAdditionalSignArguments ?? (() => []);
+    this.publish = hooks?.publish ?? (() => Promise.resolve({ transactionHash: void 0 }));
+    this.nonceTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _multichainTrackingHelper, new (0, _chunkNRWEI43Qjs.MultichainTrackingHelper)({
+      isMultichainEnabled,
+      provider,
+      nonceTracker: this.nonceTracker,
+      incomingTransactionOptions: incomingTransactions,
+      findNetworkClientIdByChainId: (chainId) => {
+        return this.messagingSystem.call(
+          `NetworkController:findNetworkClientIdByChainId`,
+          chainId
+        );
+      },
+      getNetworkClientById: (networkClientId) => {
+        return this.messagingSystem.call(
+          `NetworkController:getNetworkClientById`,
+          networkClientId
+        );
+      },
+      getNetworkClientRegistry,
+      removeIncomingTransactionHelperListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).bind(this),
+      removePendingTransactionTrackerListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).bind(this),
+      createNonceTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).bind(this),
+      createIncomingTransactionHelper: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).bind(this),
+      createPendingTransactionTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).bind(this),
+      onNetworkStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "NetworkController:stateChange",
+          listener
+        );
+      }
+    }));
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).initialize();
+    const etherscanRemoteTransactionSource = new (0, _chunkF3CMU2DMjs.EtherscanRemoteTransactionSource)({
+      includeTokenTransfers: incomingTransactions.includeTokenTransfers
+    });
+    this.incomingTransactionHelper = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).call(this, {
+      blockTracker,
+      etherscanRemoteTransactionSource
+    });
+    this.pendingTransactionTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    this.gasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getGasFeeFlows, getGasFeeFlows_fn).call(this);
+    this.layer1GasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn).call(this);
+    const gasFeePoller = new (0, _chunkQEX3QMSLjs.GasFeePoller)({
+      // Default gas fee polling is not yet supported by the clients
+      gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+      getEthQuery: (chainId, networkClientId) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId,
+        chainId
+      }),
+      getGasFeeControllerEstimates: this.getGasFeeEstimates,
+      getTransactions: () => this.state.transactions,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      onStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "TransactionController:stateChange",
+          listener
+        );
+      }
+    });
+    gasFeePoller.hub.on(
+      "transaction-updated",
+      (transactionMeta) => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, transactionMeta, { skipHistory: true })
+    );
+    this.messagingSystem.subscribe(
+      "TransactionController:stateChange",
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _checkForPendingTransactionAndStartPolling)
+    );
+    onNetworkStateChange(() => {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Detected network change", this.getChainId());
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      this.onBootCleanup();
+    });
+    this.onBootCleanup();
+  }
+  failTransaction(transactionMeta, error, actionId) {
+    const newTransactionMeta = _lodash.merge.call(void 0, {}, transactionMeta, {
+      error: _chunkUGFBA4GVjs.normalizeTxError.call(void 0, error),
+      status: "failed" /* failed */
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionFailed`, {
+      actionId,
+      error: error.message,
+      transactionMeta: newTransactionMeta
+    });
+    this.updateTransaction(
+      newTransactionMeta,
+      "TransactionController#failTransaction - Add error message and set status to failed"
+    );
+    this.onTransactionStatusChange(newTransactionMeta);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      newTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      newTransactionMeta
+    );
+  }
+  async registryLookup(fourBytePrefix) {
+    const registryMethod = await this.registry.lookup(fourBytePrefix);
+    if (!registryMethod) {
+      return {
+        registryMethod: "",
+        parsedRegistryMethod: { name: void 0, args: void 0 }
+      };
+    }
+    const parsedRegistryMethod = this.registry.parse(registryMethod);
+    return { registryMethod, parsedRegistryMethod };
+  }
+  /**
+   * Stops polling and removes listeners to prepare the controller for garbage collection.
+   */
+  destroy() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopAllTracking, stopAllTracking_fn).call(this);
+  }
+  /**
+   * Handle new method data request.
+   *
+   * @param fourBytePrefix - The method prefix.
+   * @returns The method data object corresponding to the given signature prefix.
+   */
+  async handleMethodData(fourBytePrefix) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      const { methodData } = this.state;
+      const knownMethod = Object.keys(methodData).find(
+        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix
+      );
+      if (knownMethod) {
+        return methodData[fourBytePrefix];
+      }
+      const registry = await this.registryLookup(fourBytePrefix);
+      this.update((state) => {
+        state.methodData[fourBytePrefix] = registry;
+      });
+      return registry;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a new unapproved transaction to state. Parameters will be validated, a
+   * unique transaction id will be generated, and gas and gasPrice will be calculated
+   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
+   *
+   * @param txParams - Standard parameters for an Ethereum transaction.
+   * @param opts - Additional options to control how the transaction is added.
+   * @param opts.actionId - Unique ID to prevent duplicate requests.
+   * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+   * @param opts.method - RPC method that requested the transaction.
+   * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+   * @param opts.requireApproval - Whether the transaction requires approval by the user, defaults to true unless explicitly disabled.
+   * @param opts.securityAlertResponse - Response from security validator.
+   * @param opts.sendFlowHistory - The sendFlowHistory entries to add.
+   * @param opts.type - Type of transaction to add, such as 'cancel' or 'swap'.
+   * @param opts.swaps - Options for swaps transactions.
+   * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.
+   * @param opts.swaps.meta - Metadata for swap transaction.
+   * @param opts.networkClientId - The id of the network client for this transaction.
+   * @returns Object containing a promise resolving to the transaction hash if approved.
+   */
+  async addTransaction(txParams, {
+    actionId,
+    deviceConfirmedOn,
+    method,
+    origin,
+    requireApproval,
+    securityAlertResponse,
+    sendFlowHistory,
+    swaps = {},
+    type,
+    networkClientId
+  } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Adding transaction", txParams);
+    txParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, txParams);
+    if (networkClientId && !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).has(networkClientId)) {
+      throw new Error(
+        "The networkClientId for this transaction could not be found"
+      );
+    }
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(
+      networkClientId
+    );
+    _chunkVH47Q6TSjs.validateTxParams.call(void 0, txParams, isEIP1559Compatible);
+    if (origin) {
+      await _chunkVH47Q6TSjs.validateTransactionOrigin.call(void 0, 
+        await this.getPermittedAccounts(origin),
+        this.getSelectedAddress(),
+        txParams.from,
+        origin
+      );
+    }
+    const dappSuggestedGasFees = this.generateDappSuggestedGasFees(
+      txParams,
+      origin
+    );
+    const chainId = this.getChainId(networkClientId);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    const transactionType = type ?? (await _chunkHS277C77js.determineTransactionType.call(void 0, txParams, ethQuery)).type;
+    const existingTransactionMeta = this.getTransactionWithActionId(actionId);
+    let addedTransactionMeta = existingTransactionMeta ? _lodash.cloneDeep.call(void 0, existingTransactionMeta) : {
+      // Add actionId to txMeta to check if same actionId is seen again
+      actionId,
+      chainId,
+      dappSuggestedGasFees,
+      deviceConfirmedOn,
+      id: _uuid.v1.call(void 0, ),
+      origin,
+      securityAlertResponse,
+      status: "unapproved" /* unapproved */,
+      time: Date.now(),
+      txParams,
+      userEditedGasLimit: false,
+      verifiedOnBlockchain: false,
+      type: transactionType,
+      networkClientId
+    };
+    await this.updateGasProperties(addedTransactionMeta);
+    if (!existingTransactionMeta) {
+      if (method && this.securityProviderRequest) {
+        const securityProviderResponse = await this.securityProviderRequest(
+          addedTransactionMeta,
+          method
+        );
+        addedTransactionMeta.securityProviderResponse = securityProviderResponse;
+      }
+      if (!this.isSendFlowHistoryDisabled) {
+        addedTransactionMeta.sendFlowHistory = sendFlowHistory ?? [];
+      }
+      if (!this.isHistoryDisabled) {
+        addedTransactionMeta = _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, addedTransactionMeta);
+      }
+      addedTransactionMeta = _chunk5OQ373JSjs.updateSwapsTransaction.call(void 0, 
+        addedTransactionMeta,
+        transactionType,
+        swaps,
+        {
+          isSwapsDisabled: this.isSwapsDisabled,
+          cancelTransaction: this.cancelTransaction.bind(this),
+          messenger: this.messagingSystem
+        }
+      );
+      this.addMetadata(addedTransactionMeta);
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateSimulationData, updateSimulationData_fn).call(this, addedTransactionMeta);
+      this.messagingSystem.publish(
+        `${controllerName}:unapprovedTransactionAdded`,
+        addedTransactionMeta
+      );
+    }
+    return {
+      result: this.processApproval(addedTransactionMeta, {
+        isExisting: Boolean(existingTransactionMeta),
+        requireApproval,
+        actionId
+      }),
+      transactionMeta: addedTransactionMeta
+    };
+  }
+  startIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.start();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).startIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.stop();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopAllIncomingTransactionPolling() {
+    this.incomingTransactionHelper.stop();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllIncomingTransactionPolling();
+  }
+  async updateIncomingTransactions(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      await this.incomingTransactionHelper.update();
+      return;
+    }
+    await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).updateIncomingTransactions(
+      networkClientIds
+    );
+  }
+  /**
+   * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param gasValues - The gas values to use for the cancellation transaction.
+   * @param options - The options for the cancellation transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests.
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async stopTransaction(transactionId, gasValues, {
+    estimatedBaseFee,
+    actionId
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating cancel transaction", transactionId, gasValues);
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      CANCEL_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      CANCEL_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      CANCEL_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const newTxParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    } : {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      newTxParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = newTxParams.maxFeePerGas ?? newTxParams.gasPrice;
+    const oldFee = newTxParams.maxFeePerGas ? transactionMeta.txParams.maxFeePerGas : transactionMeta.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting cancel transaction", {
+      oldFee,
+      newFee,
+      txParams: newTxParams
+    });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const cancelTransactionMeta = {
+      actionId,
+      chainId: transactionMeta.chainId,
+      networkClientId: transactionMeta.networkClientId,
+      estimatedBaseFee,
+      hash,
+      id: _uuid.v1.call(void 0, ),
+      originalGasEstimate: transactionMeta.txParams.gas,
+      status: "submitted" /* submitted */,
+      time: Date.now(),
+      type: "cancel" /* cancel */,
+      txParams: newTxParams
+    };
+    this.addMetadata(cancelTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      cancelTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      cancelTransactionMeta
+    );
+  }
+  /**
+   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.
+   *
+   * @param transactionId - The ID of the transaction to speed up.
+   * @param gasValues - The gas values to use for the speed up transaction.
+   * @param options - The options for the speed up transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async speedUpTransaction(transactionId, gasValues, {
+    actionId,
+    estimatedBaseFee
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating speed up transaction", transactionId, gasValues);
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      SPEED_UP_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */
+    } : {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const transactionMetaWithRsv = await this.updateTransactionMetaRSV(
+      transactionMeta,
+      signedTx
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = txParams.maxFeePerGas ?? txParams.gasPrice;
+    const oldFee = txParams.maxFeePerGas ? transactionMetaWithRsv.txParams.maxFeePerGas : transactionMetaWithRsv.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting speed up transaction", { oldFee, newFee, txParams });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const baseTransactionMeta = {
+      ...transactionMetaWithRsv,
+      estimatedBaseFee,
+      id: _uuid.v1.call(void 0, ),
+      time: Date.now(),
+      hash,
+      actionId,
+      originalGasEstimate: transactionMeta.txParams.gas,
+      type: "retry" /* retry */,
+      originalType: transactionMeta.type
+    };
+    const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        maxFeePerGas: newMaxFeePerGas,
+        maxPriorityFeePerGas: newMaxPriorityFeePerGas
+      }
+    } : {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        gasPrice: newGasPrice
+      }
+    };
+    this.addMetadata(newTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:speedupTransactionAdded`,
+      newTransactionMeta
+    );
+  }
+  /**
+   * Estimates required gas for a given transaction.
+   *
+   * @param transaction - The transaction to estimate gas for.
+   * @param networkClientId - The network client id to use for the estimate.
+   * @returns The gas and gas price.
+   */
+  async estimateGas(transaction, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { estimatedGas, simulationFails } = await _chunkRQKICZYPjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    return { gas: estimatedGas, simulationFails };
+  }
+  /**
+   * Estimates required gas for a given transaction and add additional gas buffer with the given multiplier.
+   *
+   * @param transaction - The transaction params to estimate gas for.
+   * @param multiplier - The multiplier to use for the gas buffer.
+   * @param networkClientId - The network client id to use for the estimate.
+   */
+  async estimateGasBuffered(transaction, multiplier, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { blockGasLimit, estimatedGas, simulationFails } = await _chunkRQKICZYPjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    const gas = _chunkRQKICZYPjs.addGasBuffer.call(void 0, estimatedGas, blockGasLimit, multiplier);
+    return {
+      gas,
+      simulationFails
+    };
+  }
+  /**
+   * Updates an existing transaction in state.
+   *
+   * @param transactionMeta - The new transaction to store in state.
+   * @param note - A note or update reason to include in the transaction history.
+   */
+  updateTransaction(transactionMeta, note) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, transactionMeta, {
+      note,
+      skipHistory: this.isHistoryDisabled
+    });
+  }
+  /**
+   * Update the security alert response for a transaction.
+   *
+   * @param transactionId - ID of the transaction.
+   * @param securityAlertResponse - The new security alert response for the transaction.
+   */
+  updateSecurityAlertResponse(transactionId, securityAlertResponse) {
+    if (!securityAlertResponse) {
+      throw new Error(
+        "updateSecurityAlertResponse: securityAlertResponse should not be null"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update security alert response as no transaction metadata found`
+      );
+    }
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      securityAlertResponse
+    };
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updatesecurityAlertResponse - securityAlertResponse updated`
+    );
+  }
+  /**
+   * Removes all transactions from state, optionally based on the current network.
+   *
+   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the
+   * current network. If `true`, all transactions are wiped.
+   * @param address - If specified, only transactions originating from this address will be
+   * wiped on current network.
+   */
+  wipeTransactions(ignoreNetwork, address) {
+    if (ignoreNetwork && !address) {
+      this.update((state) => {
+        state.transactions = [];
+      });
+      return;
+    }
+    const currentChainId = this.getChainId();
+    const newTransactions = this.state.transactions.filter(
+      ({ chainId, txParams }) => {
+        const isMatchingNetwork = ignoreNetwork || chainId === currentChainId;
+        if (!isMatchingNetwork) {
+          return true;
+        }
+        const isMatchingAddress = !address || txParams.from?.toLowerCase() === address.toLowerCase();
+        return !isMatchingAddress;
+      }
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(newTransactions);
+    });
+  }
+  /**
+   * Adds external provided transaction to state as confirmed transaction.
+   *
+   * @param transactionMeta - TransactionMeta to add transactions.
+   * @param transactionReceipt - TransactionReceipt of the external transaction.
+   * @param baseFeePerGas - Base fee per gas of the external transaction.
+   */
+  async confirmExternalTransaction(transactionMeta, transactionReceipt, baseFeePerGas) {
+    const newTransactionMeta = this.addExternalTransaction(transactionMeta);
+    try {
+      const transactionId = newTransactionMeta.id;
+      const updatedTransactionMeta = {
+        ...newTransactionMeta,
+        status: "confirmed" /* confirmed */,
+        txReceipt: transactionReceipt
+      };
+      if (baseFeePerGas) {
+        updatedTransactionMeta.baseFeePerGas = baseFeePerGas;
+      }
+      this.markNonceDuplicatesDropped(transactionId);
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:confirmExternalTransaction - Add external transaction`
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      this.updatePostBalance(updatedTransactionMeta);
+      this.messagingSystem.publish(
+        `${controllerName}:transactionConfirmed`,
+        updatedTransactionMeta
+      );
+    } catch (error) {
+      console.error("Failed to confirm external transaction", error);
+    }
+  }
+  /**
+   * Append new send flow history to a transaction.
+   *
+   * @param transactionID - The ID of the transaction to update.
+   * @param currentSendFlowHistoryLength - The length of the current sendFlowHistory array.
+   * @param sendFlowHistoryToAdd - The sendFlowHistory entries to add.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionSendFlowHistory(transactionID, currentSendFlowHistoryLength, sendFlowHistoryToAdd) {
+    if (this.isSendFlowHistoryDisabled) {
+      throw new Error(
+        "Send flow history is disabled for the current transaction controller"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionID);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update send flow history as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionSendFlowHistory"
+    );
+    const sendFlowHistory = transactionMeta.sendFlowHistory ?? [];
+    if (currentSendFlowHistoryLength === sendFlowHistory.length) {
+      const updatedTransactionMeta = {
+        ...transactionMeta,
+        sendFlowHistory: [...sendFlowHistory, ...sendFlowHistoryToAdd]
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:updateTransactionSendFlowHistory - sendFlowHistory updated`
+      );
+    }
+    return this.getTransaction(transactionID);
+  }
+  /**
+   * Update the gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param gasValues - Gas values to update.
+   * @param gasValues.gas - Same as transaction.gasLimit.
+   * @param gasValues.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param gasValues.gasPrice - Price per gas for legacy transactions.
+   * @param gasValues.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @param gasValues.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param gasValues.estimateUsed - Which estimate level was used.
+   * @param gasValues.estimateSuggested - Which estimate level that the API suggested.
+   * @param gasValues.defaultGasEstimates - The default estimate for gas.
+   * @param gasValues.originalGasEstimate - Original estimate for gas.
+   * @param gasValues.userEditedGasLimit - The gas limit supplied by user.
+   * @param gasValues.userFeeLevel - Estimate level user selected.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionGasFees(transactionId, {
+    defaultGasEstimates,
+    estimateUsed,
+    estimateSuggested,
+    gas,
+    gasLimit,
+    gasPrice,
+    maxPriorityFeePerGas,
+    maxFeePerGas,
+    originalGasEstimate,
+    userEditedGasLimit,
+    userFeeLevel
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionGasFees"
+    );
+    let transactionGasFees = {
+      txParams: {
+        gas,
+        gasLimit,
+        gasPrice,
+        maxPriorityFeePerGas,
+        maxFeePerGas
+      },
+      defaultGasEstimates,
+      estimateUsed,
+      estimateSuggested,
+      originalGasEstimate,
+      userEditedGasLimit,
+      userFeeLevel
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionGasFees.txParams = _lodash.pickBy.call(void 0, transactionGasFees.txParams);
+    transactionGasFees = _lodash.pickBy.call(void 0, transactionGasFees);
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionGasFees);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updateTransactionGasFees - gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  /**
+   * Update the previous gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param previousGas - Previous gas values to update.
+   * @param previousGas.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param previousGas.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param previousGas.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @returns The updated transactionMeta.
+   */
+  updatePreviousGasParams(transactionId, {
+    gasLimit,
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updatePreviousGasParams");
+    const transactionPreviousGas = {
+      previousGas: {
+        gasLimit,
+        maxFeePerGas,
+        maxPriorityFeePerGas
+      }
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionPreviousGas.previousGas = _lodash.pickBy.call(void 0, 
+      transactionPreviousGas.previousGas
+    );
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionPreviousGas);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updatePreviousGasParams - Previous gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  async getNonceLock(address, networkClientId) {
+    return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(
+      address,
+      networkClientId
+    );
+  }
+  /**
+   * Updates the editable parameters of a transaction.
+   *
+   * @param txId - The ID of the transaction to update.
+   * @param params - The editable parameters to update.
+   * @param params.data - Data to pass with the transaction.
+   * @param params.gas - Maximum number of units of gas to use for the transaction.
+   * @param params.gasPrice - Price per gas for legacy transactions.
+   * @param params.from - Address to send the transaction from.
+   * @param params.to - Address to send the transaction to.
+   * @param params.value - Value associated with the transaction.
+   * @returns The updated transaction metadata.
+   */
+  async updateEditableParams(txId, {
+    data,
+    gas,
+    gasPrice,
+    from,
+    to,
+    value
+  }) {
+    const transactionMeta = this.getTransaction(txId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update editable params as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updateEditableParams");
+    const editableParams = {
+      txParams: {
+        data,
+        from,
+        to,
+        value,
+        gas,
+        gasPrice
+      }
+    };
+    editableParams.txParams = _lodash.pickBy.call(void 0, 
+      editableParams.txParams
+    );
+    const updatedTransaction = _lodash.merge.call(void 0, {}, transactionMeta, editableParams);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const { type } = await _chunkHS277C77js.determineTransactionType.call(void 0, 
+      updatedTransaction.txParams,
+      ethQuery
+    );
+    updatedTransaction.type = type;
+    await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+      ethQuery,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      transactionMeta: updatedTransaction
+    });
+    this.updateTransaction(
+      updatedTransaction,
+      `Update Editable Params for ${txId}`
+    );
+    return this.getTransaction(txId);
+  }
+  /**
+   * Signs and returns the raw transaction data for provided transaction params list.
+   *
+   * @param listOfTxParams - The list of transaction params to approve.
+   * @param opts - Options bag.
+   * @param opts.hasNonce - Whether the transactions already have a nonce.
+   * @returns The raw transactions.
+   */
+  async approveTransactionsWithSameNonce(listOfTxParams = [], { hasNonce } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Approving transactions with same nonce", {
+      transactions: listOfTxParams
+    });
+    if (listOfTxParams.length === 0) {
+      return "";
+    }
+    const initialTx = listOfTxParams[0];
+    const common = this.getCommonConfiguration(initialTx.chainId);
+    let networkClientId;
+    try {
+      networkClientId = this.messagingSystem.call(
+        `NetworkController:findNetworkClientIdByChainId`,
+        initialTx.chainId
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "failed to find networkClientId from chainId", err);
+    }
+    const initialTxAsEthTx = _tx.TransactionFactory.fromTxData(initialTx, {
+      common
+    });
+    const initialTxAsSerializedHex = _util.bufferToHex.call(void 0, initialTxAsEthTx.serialize());
+    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
+      return "";
+    }
+    this.inProcessOfSigning.add(initialTxAsSerializedHex);
+    let rawTransactions, nonceLock;
+    try {
+      const fromAddress = initialTx.from;
+      const requiresNonce = hasNonce !== true;
+      nonceLock = requiresNonce ? await this.getNonceLock(fromAddress, networkClientId) : void 0;
+      const nonce = nonceLock ? _utils.add0x.call(void 0, nonceLock.nextNonce.toString(16)) : initialTx.nonce;
+      if (nonceLock) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Using nonce from nonce tracker", nonce, nonceLock.nonceDetails);
+      }
+      rawTransactions = await Promise.all(
+        listOfTxParams.map((txParams) => {
+          txParams.nonce = nonce;
+          return this.signExternalTransaction(txParams.chainId, txParams);
+        })
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while signing transactions with same nonce", err);
+      throw err;
+    } finally {
+      nonceLock?.releaseLock();
+      this.inProcessOfSigning.delete(initialTxAsSerializedHex);
+    }
+    return rawTransactions;
+  }
+  /**
+   * Update a custodial transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param options - The custodial transaction options to update.
+   * @param options.errorMessage - The error message to be assigned in case transaction status update to failed.
+   * @param options.hash - The new hash value to be assigned.
+   * @param options.status - The new status value to be assigned.
+   */
+  updateCustodialTransaction(transactionId, {
+    errorMessage,
+    hash,
+    status
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update custodial transaction as no transaction metadata found`
+      );
+    }
+    if (!transactionMeta.custodyId) {
+      throw new Error("Transaction must be a custodian transaction");
+    }
+    if (status && ![
+      "submitted" /* submitted */,
+      "signed" /* signed */,
+      "failed" /* failed */
+    ].includes(status)) {
+      throw new Error(
+        `Cannot update custodial transaction with status: ${status}`
+      );
+    }
+    const updatedTransactionMeta = _lodash.merge.call(void 0, 
+      {},
+      transactionMeta,
+      _lodash.pickBy.call(void 0, { hash, status })
+    );
+    if (status === "submitted" /* submitted */) {
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+    }
+    if (status === "failed" /* failed */) {
+      updatedTransactionMeta.error = _chunkUGFBA4GVjs.normalizeTxError.call(void 0, new Error(errorMessage));
+    }
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updateCustodialTransaction - Custodial transaction updated`
+    );
+    if (["submitted" /* submitted */, "failed" /* failed */].includes(
+      status
+    )) {
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+    }
+  }
+  /**
+   * Creates approvals for all unapproved transactions persisted.
+   */
+  initApprovals() {
+    const chainId = this.getChainId();
+    const unapprovedTxs = this.state.transactions.filter(
+      (transaction) => transaction.status === "unapproved" /* unapproved */ && transaction.chainId === chainId && !transaction.isUserOperation
+    );
+    for (const txMeta of unapprovedTxs) {
+      this.processApproval(txMeta, {
+        shouldShowRequest: false
+      }).catch((error) => {
+        if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+          return;
+        }
+        console.error("Error during persisted transaction approval", error);
+      });
+    }
+  }
+  /**
+   * Search transaction metadata for matching entries.
+   *
+   * @param opts - Options bag.
+   * @param opts.searchCriteria - An object containing values or functions for transaction properties to filter transactions with.
+   * @param opts.initialList - The transactions to search. Defaults to the current state.
+   * @param opts.filterToCurrentNetwork - Whether to filter the results to the current network. Defaults to true.
+   * @param opts.limit - The maximum number of transactions to return. No limit by default.
+   * @returns An array of transactions matching the provided options.
+   */
+  getTransactions({
+    searchCriteria = {},
+    initialList,
+    filterToCurrentNetwork = true,
+    limit
+  } = {}) {
+    const chainId = this.getChainId();
+    const predicateMethods = _lodash.mapValues.call(void 0, searchCriteria, (predicate) => {
+      return typeof predicate === "function" ? predicate : (
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        (v) => v === predicate
+      );
+    });
+    const transactionsToFilter = initialList ?? this.state.transactions;
+    const filteredTransactions = _lodash.sortBy.call(void 0, 
+      _lodash.pickBy.call(void 0, transactionsToFilter, (transaction) => {
+        if (filterToCurrentNetwork && transaction.chainId !== chainId) {
+          return false;
+        }
+        for (const [key, predicate] of Object.entries(predicateMethods)) {
+          if (key in transaction.txParams) {
+            if (predicate(transaction.txParams[key]) === false) {
+              return false;
+            }
+          } else if (predicate(transaction[key]) === false) {
+            return false;
+          }
+        }
+        return true;
+      }),
+      "time"
+    );
+    if (limit !== void 0) {
+      const nonces = /* @__PURE__ */ new Set();
+      const txs = [];
+      for (let i = filteredTransactions.length - 1; i > -1; i--) {
+        const txMeta = filteredTransactions[i];
+        const { nonce } = txMeta.txParams;
+        if (!nonces.has(nonce)) {
+          if (nonces.size < limit) {
+            nonces.add(nonce);
+          } else {
+            continue;
+          }
+        }
+        txs.unshift(txMeta);
+      }
+      return txs;
+    }
+    return filteredTransactions;
+  }
+  async signExternalTransaction(chainId, transactionParams) {
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const normalizedTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionParams);
+    const type = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, normalizedTransactionParams) ? "0x2" /* feeMarket */ : "0x0" /* legacy */;
+    const updatedTransactionParams = {
+      ...normalizedTransactionParams,
+      type,
+      gasLimit: normalizedTransactionParams.gas,
+      chainId
+    };
+    const { from } = updatedTransactionParams;
+    const common = this.getCommonConfiguration(chainId);
+    const unsignedTransaction = _tx.TransactionFactory.fromTxData(
+      updatedTransactionParams,
+      { common }
+    );
+    const signedTransaction = await this.sign(unsignedTransaction, from);
+    const rawTransaction = _util.bufferToHex.call(void 0, signedTransaction.serialize());
+    return rawTransaction;
+  }
+  /**
+   * Removes unapproved transactions from state.
+   */
+  clearUnapprovedTransactions() {
+    const transactions = this.state.transactions.filter(
+      ({ status }) => status !== "unapproved" /* unapproved */
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+  }
+  /**
+   * Stop the signing process for a specific transaction.
+   * Throws an error causing the transaction status to be set to failed.
+   * @param transactionId - The ID of the transaction to stop signing.
+   */
+  abortTransactionSigning(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(`Cannot abort signing as no transaction metadata found`);
+    }
+    const abortCallback = this.signAbortCallbacks.get(transactionId);
+    if (!abortCallback) {
+      throw new Error(
+        `Cannot abort signing as transaction is not waiting for signing`
+      );
+    }
+    abortCallback();
+    this.signAbortCallbacks.delete(transactionId);
+  }
+  addMetadata(transactionMeta) {
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        transactionMeta
+      ]);
+    });
+  }
+  async updateGasProperties(transactionMeta) {
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(transactionMeta.networkClientId) && transactionMeta.txParams.type !== "0x0" /* legacy */;
+    const { networkClientId, chainId } = transactionMeta;
+    const isCustomNetwork = networkClientId ? this.messagingSystem.call(
+      `NetworkController:getNetworkClientById`,
+      networkClientId
+    ).configuration.type === _networkcontroller.NetworkClientType.Custom : this.getNetworkState().providerConfig.type === _controllerutils.NetworkType.rpc;
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    await _chunkRQKICZYPjs.updateGas.call(void 0, {
+      ethQuery,
+      chainId,
+      isCustomNetwork,
+      txMeta: transactionMeta
+    });
+    await _chunk5IHLDAOFjs.updateGasFees.call(void 0, {
+      eip1559: isEIP1559Compatible,
+      ethQuery,
+      gasFeeFlows: this.gasFeeFlows,
+      getGasFeeEstimates: this.getGasFeeEstimates,
+      getSavedGasFees: this.getSavedGasFees.bind(this),
+      txMeta: transactionMeta
+    });
+    await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+      ethQuery,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      transactionMeta
+    });
+  }
+  onBootCleanup() {
+    this.submitApprovedTransactions();
+  }
+  /**
+   * Force submit approved transactions for all chains.
+   */
+  submitApprovedTransactions() {
+    const approvedTransactions = this.state.transactions.filter(
+      (transaction) => transaction.status === "approved" /* approved */
+    );
+    for (const transactionMeta of approvedTransactions) {
+      if (this.beforeApproveOnInit(transactionMeta)) {
+        this.approveTransaction(transactionMeta.id).catch((error) => {
+          console.error("Error while submitting persisted transaction", error);
+        });
+      }
+    }
+  }
+  async processApproval(transactionMeta, {
+    isExisting = false,
+    requireApproval,
+    shouldShowRequest = true,
+    actionId
+  }) {
+    const transactionId = transactionMeta.id;
+    let resultCallbacks;
+    const { meta, isCompleted } = this.isTransactionCompleted(transactionId);
+    const finishedPromise = isCompleted ? Promise.resolve(meta) : this.waitForTransactionFinished(transactionId);
+    if (meta && !isExisting && !isCompleted) {
+      try {
+        if (requireApproval !== false) {
+          const acceptResult = await this.requestApproval(transactionMeta, {
+            shouldShowRequest
+          });
+          resultCallbacks = acceptResult.resultCallbacks;
+          const approvalValue = acceptResult.value;
+          const updatedTransaction = approvalValue?.txMeta;
+          if (updatedTransaction) {
+            _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating transaction with approval data", {
+              customNonce: updatedTransaction.customNonceValue,
+              params: updatedTransaction.txParams
+            });
+            this.updateTransaction(
+              updatedTransaction,
+              "TransactionController#processApproval - Updated with approval data"
+            );
+          }
+        }
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          const approvalResult = await this.approveTransaction(transactionId);
+          if (approvalResult === "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */ && resultCallbacks) {
+            resultCallbacks.success();
+          }
+          const updatedTransactionMeta = this.getTransaction(
+            transactionId
+          );
+          this.messagingSystem.publish(
+            `${controllerName}:transactionApproved`,
+            {
+              transactionMeta: updatedTransactionMeta,
+              actionId
+            }
+          );
+        }
+      } catch (error) {
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+            this.cancelTransaction(transactionId, actionId);
+            throw _rpcerrors.providerErrors.userRejectedRequest(
+              "MetaMask Tx Signature: User denied transaction signature."
+            );
+          } else {
+            this.failTransaction(meta, error, actionId);
+          }
+        }
+      }
+    }
+    const finalMeta = await finishedPromise;
+    switch (finalMeta?.status) {
+      case "failed" /* failed */:
+        resultCallbacks?.error(finalMeta.error);
+        throw _rpcerrors.rpcErrors.internal(finalMeta.error.message);
+      case "submitted" /* submitted */:
+        resultCallbacks?.success();
+        return finalMeta.hash;
+      default:
+        const internalError = _rpcerrors.rpcErrors.internal(
+          `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(
+            finalMeta || transactionId
+          )}`
+        );
+        resultCallbacks?.error(internalError);
+        throw internalError;
+    }
+  }
+  /**
+   * Approves a transaction and updates it's status in state. If this is not a
+   * retry transaction, a nonce will be generated. The transaction is signed
+   * using the sign configuration property, then published to the blockchain.
+   * A `<tx.id>:finished` hub event is fired after success or failure.
+   *
+   * @param transactionId - The ID of the transaction to approve.
+   */
+  async approveTransaction(transactionId) {
+    const { transactions } = this.state;
+    const releaseLock = await this.mutex.acquire();
+    const index = transactions.findIndex(({ id }) => transactionId === id);
+    const transactionMeta = transactions[index];
+    const updatedTransactionMeta = _lodash.cloneDeep.call(void 0, transactionMeta);
+    const {
+      txParams: { from },
+      networkClientId
+    } = transactionMeta;
+    let releaseNonceLock;
+    try {
+      if (!this.sign) {
+        releaseLock();
+        this.failTransaction(
+          transactionMeta,
+          new Error("No sign method defined.")
+        );
+        return "not-approved" /* NotApproved */;
+      } else if (!transactionMeta.chainId) {
+        releaseLock();
+        this.failTransaction(transactionMeta, new Error("No chainId defined."));
+        return "not-approved" /* NotApproved */;
+      }
+      if (this.inProcessOfSigning.has(transactionId)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping approval as signing in progress", transactionId);
+        return "not-approved" /* NotApproved */;
+      }
+      const [nonce, releaseNonce] = await _chunkZNZEJDOEjs.getNextNonce.call(void 0, 
+        transactionMeta,
+        (address) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(address, networkClientId)
+      );
+      releaseNonceLock = releaseNonce;
+      updatedTransactionMeta.status = "approved" /* approved */;
+      updatedTransactionMeta.txParams = {
+        ...updatedTransactionMeta.txParams,
+        nonce,
+        chainId: transactionMeta.chainId
+      };
+      const baseTxParams = {
+        ...updatedTransactionMeta.txParams,
+        gasLimit: updatedTransactionMeta.txParams.gas
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction approved"
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      const isEIP1559 = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, updatedTransactionMeta.txParams);
+      const txParams = isEIP1559 ? {
+        ...baseTxParams,
+        estimatedBaseFee: updatedTransactionMeta.txParams.estimatedBaseFee,
+        type: "0x2" /* feeMarket */
+      } : baseTxParams;
+      const rawTx = await this.signTransaction(
+        updatedTransactionMeta,
+        txParams
+      );
+      if (!this.beforePublish(updatedTransactionMeta)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping publishing transaction based on hook");
+        this.messagingSystem.publish(
+          `${controllerName}:transactionPublishingSkipped`,
+          updatedTransactionMeta
+        );
+        return "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */;
+      }
+      if (!rawTx) {
+        return "not-approved" /* NotApproved */;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      if (transactionMeta.type === "swap" /* swap */) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Determining pre-transaction balance");
+        const preTxBalance = await _controllerutils.query.call(void 0, ethQuery, "getBalance", [from]);
+        updatedTransactionMeta.preTxBalance = preTxBalance;
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+          "Updated pre-transaction balance",
+          updatedTransactionMeta.preTxBalance
+        );
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publishing transaction", txParams);
+      let { transactionHash: hash } = await this.publish(
+        updatedTransactionMeta,
+        rawTx
+      );
+      if (hash === void 0) {
+        hash = await this.publishTransaction(ethQuery, rawTx);
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publish successful", hash);
+      updatedTransactionMeta.hash = hash;
+      updatedTransactionMeta.status = "submitted" /* submitted */;
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction submitted"
+      );
+      this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+        transactionMeta: updatedTransactionMeta
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      return "approved" /* Approved */;
+    } catch (error) {
+      this.failTransaction(transactionMeta, error);
+      return "not-approved" /* NotApproved */;
+    } finally {
+      this.inProcessOfSigning.delete(transactionId);
+      releaseNonceLock?.();
+      releaseLock();
+    }
+  }
+  async publishTransaction(ethQuery, rawTransaction) {
+    return await _controllerutils.query.call(void 0, ethQuery, "sendRawTransaction", [rawTransaction]);
+  }
+  /**
+   * Cancels a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param actionId - The actionId passed from UI
+   */
+  cancelTransaction(transactionId, actionId) {
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    this.update((state) => {
+      const transactions = state.transactions.filter(
+        ({ id }) => id !== transactionId
+      );
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "rejected" /* rejected */
+    };
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      updatedTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      updatedTransactionMeta
+    );
+    this.messagingSystem.publish(`${controllerName}:transactionRejected`, {
+      transactionMeta: updatedTransactionMeta,
+      actionId
+    });
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Trim the amount of transactions that are set on the state. Checks
+   * if the length of the tx history is longer then desired persistence
+   * limit and then if it is removes the oldest confirmed or rejected tx.
+   * Pending or unapproved transactions will not be removed by this
+   * operation. For safety of presenting a fully functional transaction UI
+   * representation, this function will not break apart transactions with the
+   * same nonce, created on the same day, per network. Not accounting for
+   * transactions of the same nonce, same day and network combo can result in
+   * confusing or broken experiences in the UI.
+   *
+   * @param transactions - The transactions to be applied to the state.
+   * @returns The trimmed list of transactions.
+   */
+  trimTransactionsForState(transactions) {
+    const nonceNetworkSet = /* @__PURE__ */ new Set();
+    const txsToKeep = [...transactions].sort((a, b) => a.time > b.time ? -1 : 1).filter((tx) => {
+      const { chainId, status, txParams, time } = tx;
+      if (txParams) {
+        const key = `${String(txParams.nonce)}-${_controllerutils.convertHexToDecimal.call(void 0, 
+          chainId
+        )}-${new Date(time).toDateString()}`;
+        if (nonceNetworkSet.has(key)) {
+          return true;
+        } else if (nonceNetworkSet.size < _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit) || !this.isFinalState(status)) {
+          nonceNetworkSet.add(key);
+          return true;
+        }
+      }
+      return false;
+    });
+    txsToKeep.reverse();
+    return txsToKeep;
+  }
+  /**
+   * Determines if the transaction is in a final state.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isFinalState(status) {
+    return status === "rejected" /* rejected */ || status === "confirmed" /* confirmed */ || status === "failed" /* failed */;
+  }
+  /**
+   * Whether the transaction has at least completed all local processing.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isLocalFinalState(status) {
+    return [
+      "confirmed" /* confirmed */,
+      "failed" /* failed */,
+      "rejected" /* rejected */,
+      "submitted" /* submitted */
+    ].includes(status);
+  }
+  async requestApproval(txMeta, { shouldShowRequest }) {
+    const id = this.getApprovalId(txMeta);
+    const { origin } = txMeta;
+    const type = _controllerutils.ApprovalType.Transaction;
+    const requestData = { txId: txMeta.id };
+    return await this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id,
+        origin: origin || _controllerutils.ORIGIN_METAMASK,
+        type,
+        requestData,
+        expectsResult: true
+      },
+      shouldShowRequest
+    );
+  }
+  getTransaction(transactionId) {
+    const { transactions } = this.state;
+    return transactions.find(({ id }) => id === transactionId);
+  }
+  getApprovalId(txMeta) {
+    return String(txMeta.id);
+  }
+  isTransactionCompleted(transactionId) {
+    const transaction = this.getTransaction(transactionId);
+    if (!transaction) {
+      return { meta: void 0, isCompleted: false };
+    }
+    const isCompleted = this.isLocalFinalState(transaction.status);
+    return { meta: transaction, isCompleted };
+  }
+  getChainId(networkClientId) {
+    if (networkClientId) {
+      return this.messagingSystem.call(
+        `NetworkController:getNetworkClientById`,
+        networkClientId
+      ).configuration.chainId;
+    }
+    const { providerConfig } = this.getNetworkState();
+    return providerConfig.chainId;
+  }
+  prepareUnsignedEthTx(chainId, txParams) {
+    return _tx.TransactionFactory.fromTxData(txParams, {
+      freeze: false,
+      common: this.getCommonConfiguration(chainId)
+    });
+  }
+  /**
+   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
+   * specifying which chain, network, hardfork and EIPs to support for
+   * a transaction. By referencing this configuration, and analyzing the fields
+   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
+   * transaction type to use.
+   *
+   * @param chainId - The chainId to use for the configuration.
+   * @returns common configuration object
+   */
+  getCommonConfiguration(chainId) {
+    const customChainParams = {
+      chainId: parseInt(chainId, 16),
+      defaultHardfork: HARDFORK
+    };
+    return _common.Common.custom(customChainParams);
+  }
+  onIncomingTransactions({
+    added,
+    updated
+  }) {
+    this.update((state) => {
+      const { transactions: currentTransactions } = state;
+      const updatedTransactions = [
+        ...added,
+        ...currentTransactions.map((originalTransaction) => {
+          const updatedTransaction = updated.find(
+            ({ hash }) => hash === originalTransaction.hash
+          );
+          return updatedTransaction ?? originalTransaction;
+        })
+      ];
+      state.transactions = this.trimTransactionsForState(updatedTransactions);
+    });
+  }
+  onUpdatedLastFetchedBlockNumbers({
+    lastFetchedBlockNumbers,
+    blockNumber
+  }) {
+    this.update((state) => {
+      state.lastFetchedBlockNumbers = lastFetchedBlockNumbers;
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:incomingTransactionBlockReceived`,
+      blockNumber
+    );
+  }
+  generateDappSuggestedGasFees(txParams, origin) {
+    if (!origin || origin === _controllerutils.ORIGIN_METAMASK) {
+      return void 0;
+    }
+    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas, gas } = txParams;
+    if (gasPrice === void 0 && maxFeePerGas === void 0 && maxPriorityFeePerGas === void 0 && gas === void 0) {
+      return void 0;
+    }
+    const dappSuggestedGasFees = {};
+    if (gasPrice !== void 0) {
+      dappSuggestedGasFees.gasPrice = gasPrice;
+    } else if (maxFeePerGas !== void 0 || maxPriorityFeePerGas !== void 0) {
+      dappSuggestedGasFees.maxFeePerGas = maxFeePerGas;
+      dappSuggestedGasFees.maxPriorityFeePerGas = maxPriorityFeePerGas;
+    }
+    if (gas !== void 0) {
+      dappSuggestedGasFees.gas = gas;
+    }
+    return dappSuggestedGasFees;
+  }
+  /**
+   * Validates and adds external provided transaction to state.
+   *
+   * @param transactionMeta - Nominated external transaction to be added to state.
+   * @returns The new transaction.
+   */
+  addExternalTransaction(transactionMeta) {
+    const { chainId } = transactionMeta;
+    const { transactions } = this.state;
+    const fromAddress = transactionMeta?.txParams?.from;
+    const sameFromAndNetworkTransactions = transactions.filter(
+      (transaction) => transaction.txParams.from === fromAddress && transaction.chainId === chainId
+    );
+    const confirmedTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "confirmed" /* confirmed */
+    );
+    const pendingTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "submitted" /* submitted */
+    );
+    _chunk7LXE4KHVjs.validateConfirmedExternalTransaction.call(void 0, 
+      transactionMeta,
+      confirmedTxs,
+      pendingTxs
+    );
+    const newTransactionMeta = (transactionMeta.history ?? []).length === 0 && !this.isHistoryDisabled ? _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, transactionMeta) : transactionMeta;
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        newTransactionMeta
+      ]);
+    });
+    return newTransactionMeta;
+  }
+  /**
+   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
+   * in the transactions have the same nonce.
+   *
+   * @param transactionId - Used to identify original transaction.
+   */
+  markNonceDuplicatesDropped(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    const nonce = transactionMeta.txParams?.nonce;
+    const from = transactionMeta.txParams?.from;
+    const { chainId } = transactionMeta;
+    const sameNonceTransactions = this.state.transactions.filter(
+      (transaction) => transaction.id !== transactionId && transaction.txParams.from === from && transaction.txParams.nonce === nonce && transaction.chainId === chainId && transaction.type !== "incoming" /* incoming */
+    );
+    const sameNonceTransactionIds = sameNonceTransactions.map(
+      (transaction) => transaction.id
+    );
+    if (sameNonceTransactions.length === 0) {
+      return;
+    }
+    this.update((state) => {
+      for (const transaction of state.transactions) {
+        if (sameNonceTransactionIds.includes(transaction.id)) {
+          transaction.replacedBy = transactionMeta?.hash;
+          transaction.replacedById = transactionMeta?.id;
+        }
+      }
+    });
+    for (const transaction of this.state.transactions) {
+      if (sameNonceTransactionIds.includes(transaction.id) && transaction.status !== "failed" /* failed */) {
+        this.setTransactionStatusDropped(transaction);
+      }
+    }
+  }
+  /**
+   * Method to set transaction status to dropped.
+   *
+   * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.
+   */
+  setTransactionStatusDropped(transactionMeta) {
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "dropped" /* dropped */
+    };
+    this.messagingSystem.publish(`${controllerName}:transactionDropped`, {
+      transactionMeta: updatedTransactionMeta
+    });
+    this.updateTransaction(
+      updatedTransactionMeta,
+      "TransactionController#setTransactionStatusDropped - Transaction dropped"
+    );
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Get transaction with provided actionId.
+   *
+   * @param actionId - Unique ID to prevent duplicate requests
+   * @returns the filtered transaction
+   */
+  getTransactionWithActionId(actionId) {
+    return this.state.transactions.find(
+      (transaction) => actionId && transaction.actionId === actionId
+    );
+  }
+  async waitForTransactionFinished(transactionId) {
+    return new Promise((resolve) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).once(`${transactionId}:finished`, (txMeta) => {
+        resolve(txMeta);
+      });
+    });
+  }
+  /**
+   * Updates the r, s, and v properties of a TransactionMeta object
+   * with values from a signed transaction.
+   *
+   * @param transactionMeta - The TransactionMeta object to update.
+   * @param signedTx - The encompassing type for all transaction types containing r, s, and v values.
+   */
+  async updateTransactionMetaRSV(transactionMeta, signedTx) {
+    const transactionMetaWithRsv = _lodash.cloneDeep.call(void 0, transactionMeta);
+    for (const key of ["r", "s", "v"]) {
+      const value = signedTx[key];
+      if (value === void 0 || value === null) {
+        continue;
+      }
+      transactionMetaWithRsv[key] = _utils.add0x.call(void 0, value.toString(16));
+    }
+    return transactionMetaWithRsv;
+  }
+  async getEIP1559Compatibility(networkClientId) {
+    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility(networkClientId);
+    const currentAccountIsEIP1559Compatible = await this.getCurrentAccountEIP1559Compatibility();
+    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
+  }
+  async signTransaction(transactionMeta, txParams) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Signing transaction", txParams);
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    this.inProcessOfSigning.add(transactionMeta.id);
+    const signedTx = await new Promise((resolve, reject) => {
+      this.sign?.(
+        unsignedEthTx,
+        txParams.from,
+        ...this.getAdditionalSignArguments(transactionMeta)
+      ).then(resolve, reject);
+      this.signAbortCallbacks.set(
+        transactionMeta.id,
+        () => reject(new Error("Signing aborted by user"))
+      );
+    });
+    this.signAbortCallbacks.delete(transactionMeta.id);
+    if (!signedTx) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status as no signed transaction");
+      return void 0;
+    }
+    if (!this.afterSign(transactionMeta, signedTx)) {
+      this.updateTransaction(
+        transactionMeta,
+        "TransactionController#signTransaction - Update after sign"
+      );
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status based on hook");
+      return void 0;
+    }
+    const transactionMetaWithRsv = {
+      ...await this.updateTransactionMetaRSV(transactionMeta, signedTx),
+      status: "signed" /* signed */
+    };
+    this.updateTransaction(
+      transactionMetaWithRsv,
+      "TransactionController#approveTransaction - Transaction signed"
+    );
+    this.onTransactionStatusChange(transactionMetaWithRsv);
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const transactionMetaWithRawTx = _lodash.merge.call(void 0, {}, transactionMetaWithRsv, {
+      rawTx
+    });
+    this.updateTransaction(
+      transactionMetaWithRawTx,
+      "TransactionController#approveTransaction - RawTransaction added"
+    );
+    return rawTx;
+  }
+  onTransactionStatusChange(transactionMeta) {
+    this.messagingSystem.publish(`${controllerName}:transactionStatusUpdated`, {
+      transactionMeta
+    });
+  }
+  getNonceTrackerTransactions(status, address, chainId = this.getChainId()) {
+    return _chunkZNZEJDOEjs.getAndFormatTransactionsForNonceTracker.call(void 0, 
+      chainId,
+      address,
+      status,
+      this.state.transactions
+    );
+  }
+  onConfirmedTransaction(transactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Processing confirmed transaction", transactionMeta.id);
+    this.markNonceDuplicatesDropped(transactionMeta.id);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionConfirmed`,
+      transactionMeta
+    );
+    this.onTransactionStatusChange(transactionMeta);
+    this.updatePostBalance(transactionMeta);
+  }
+  async updatePostBalance(transactionMeta) {
+    try {
+      if (transactionMeta.type !== "swap" /* swap */) {
+        return;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      const { updatedTransactionMeta, approvalTransactionMeta } = await _chunk5OQ373JSjs.updatePostTransactionBalance.call(void 0, transactionMeta, {
+        ethQuery,
+        getTransaction: this.getTransaction.bind(this),
+        updateTransaction: this.updateTransaction.bind(this)
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:postTransactionBalanceUpdated`,
+        {
+          transactionMeta: updatedTransactionMeta,
+          approvalTransactionMeta
+        }
+      );
+    } catch (error) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while updating post transaction balance", error);
+    }
+  }
+  async publishTransactionForRetry(ethQuery, rawTx, transactionMeta) {
+    try {
+      const hash = await this.publishTransaction(ethQuery, rawTx);
+      return hash;
+    } catch (error) {
+      if (this.isTransactionAlreadyConfirmedError(error)) {
+        await this.pendingTransactionTracker.forceCheckTransaction(
+          transactionMeta
+        );
+        throw new Error("Previous transaction is already confirmed");
+      }
+      throw error;
+    }
+  }
+  /**
+   * Ensures that error is a nonce issue
+   *
+   * @param error - The error to check
+   * @returns Whether or not the error is a nonce issue
+   */
+  // TODO: Replace `any` with type
+  // Some networks are returning original error in the data field
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  isTransactionAlreadyConfirmedError(error) {
+    return error?.message?.includes("nonce too low") || error?.data?.message?.includes("nonce too low");
+  }
+};
+_internalEvents = new WeakMap();
+_incomingTransactionOptions = new WeakMap();
+_pendingTransactionOptions = new WeakMap();
+_transactionHistoryLimit = new WeakMap();
+_isSimulationEnabled = new WeakMap();
+_multichainTrackingHelper = new WeakMap();
+_createNonceTracker = new WeakSet();
+createNonceTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  return new (0, _noncetracker.NonceTracker)({
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    provider,
+    blockTracker,
+    getPendingTransactions: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn).bind(
+      this,
+      chainId
+    ),
+    getConfirmedTransactions: this.getNonceTrackerTransactions.bind(
+      this,
+      "confirmed" /* confirmed */
+    )
+  });
+};
+_createIncomingTransactionHelper = new WeakSet();
+createIncomingTransactionHelper_fn = function({
+  blockTracker,
+  etherscanRemoteTransactionSource,
+  chainId
+}) {
+  const incomingTransactionHelper = new (0, _chunkDTDTOMTBjs.IncomingTransactionHelper)({
+    blockTracker,
+    getCurrentAccount: this.getSelectedAddress,
+    getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+    getChainId: chainId ? () => chainId : this.getChainId.bind(this),
+    isEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).isEnabled,
+    queryEntireHistory: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).queryEntireHistory,
+    remoteTransactionSource: etherscanRemoteTransactionSource,
+    transactionLimit: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit),
+    updateTransactions: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).updateTransactions
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn).call(this, incomingTransactionHelper);
+  return incomingTransactionHelper;
+};
+_createPendingTransactionTracker = new WeakSet();
+createPendingTransactionTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  const ethQuery = new (0, _ethquery2.default)(provider);
+  const getChainId = chainId ? () => chainId : this.getChainId.bind(this);
+  const pendingTransactionTracker = new (0, _chunk5XBULBP2js.PendingTransactionTracker)({
+    approveTransaction: async (transactionId) => {
+      await this.approveTransaction(transactionId);
+    },
+    blockTracker,
+    getChainId,
+    getEthQuery: () => ethQuery,
+    getTransactions: () => this.state.transactions,
+    isResubmitEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pendingTransactionOptions).isResubmitEnabled,
+    getGlobalLock: () => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).acquireNonceLockForChainIdKey({
+      chainId: getChainId()
+    }),
+    publishTransaction: this.publishTransaction.bind(this),
+    hooks: {
+      beforeCheckPendingTransaction: this.beforeCheckPendingTransaction.bind(this),
+      beforePublish: this.beforePublish.bind(this)
+    }
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn).call(this, pendingTransactionTracker);
+  return pendingTransactionTracker;
+};
+_checkForPendingTransactionAndStartPolling = new WeakMap();
+_stopAllTracking = new WeakSet();
+stopAllTracking_fn = function() {
+  this.pendingTransactionTracker.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).call(this, this.pendingTransactionTracker);
+  this.incomingTransactionHelper.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).call(this, this.incomingTransactionHelper);
+  _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllTracking();
+};
+_removeIncomingTransactionHelperListeners = new WeakSet();
+removeIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.removeAllListeners("transactions");
+  incomingTransactionHelper.hub.removeAllListeners(
+    "updatedLastFetchedBlockNumbers"
+  );
+};
+_addIncomingTransactionHelperListeners = new WeakSet();
+addIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.on(
+    "transactions",
+    this.onIncomingTransactions.bind(this)
+  );
+  incomingTransactionHelper.hub.on(
+    "updatedLastFetchedBlockNumbers",
+    this.onUpdatedLastFetchedBlockNumbers.bind(this)
+  );
+};
+_removePendingTransactionTrackerListeners = new WeakSet();
+removePendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.removeAllListeners("transaction-confirmed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-dropped");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-failed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-updated");
+};
+_addPendingTransactionTrackerListeners = new WeakSet();
+addPendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.on(
+    "transaction-confirmed",
+    this.onConfirmedTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-dropped",
+    this.setTransactionStatusDropped.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-failed",
+    this.failTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-updated",
+    this.updateTransaction.bind(this)
+  );
+};
+_getNonceTrackerPendingTransactions = new WeakSet();
+getNonceTrackerPendingTransactions_fn = function(chainId, address) {
+  const standardPendingTransactions = this.getNonceTrackerTransactions(
+    "submitted" /* submitted */,
+    address,
+    chainId
+  );
+  const externalPendingTransactions = this.getExternalPendingTransactions(
+    address,
+    chainId
+  );
+  return [...standardPendingTransactions, ...externalPendingTransactions];
+};
+_getGasFeeFlows = new WeakSet();
+getGasFeeFlows_fn = function() {
+  return [new (0, _chunkFHG5GY6Fjs.LineaGasFeeFlow)(), new (0, _chunkPF3UOCRWjs.DefaultGasFeeFlow)()];
+};
+_getLayer1GasFeeFlows = new WeakSet();
+getLayer1GasFeeFlows_fn = function() {
+  return [];
+};
+_updateTransactionInternal = new WeakSet();
+updateTransactionInternal_fn = function(transactionMeta, { note, skipHistory }) {
+  const normalizedTransaction = {
+    ...transactionMeta,
+    txParams: _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionMeta.txParams)
+  };
+  _chunkVH47Q6TSjs.validateTxParams.call(void 0, normalizedTransaction.txParams);
+  const updatedTransactionParams = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _checkIfTransactionParamsUpdated, checkIfTransactionParamsUpdated_fn).call(this, normalizedTransaction);
+  const transactionWithUpdatedHistory = skipHistory === true ? normalizedTransaction : _chunkQP75SWIQjs.updateTransactionHistory.call(void 0, 
+    normalizedTransaction,
+    note ?? "Transaction updated"
+  );
+  this.update((state) => {
+    const index = state.transactions.findIndex(
+      ({ id }) => transactionMeta.id === id
+    );
+    state.transactions[index] = transactionWithUpdatedHistory;
+  });
+  if (updatedTransactionParams.length > 0) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTransactionParamsUpdated, onTransactionParamsUpdated_fn).call(this, normalizedTransaction, updatedTransactionParams);
+  }
+};
+_checkIfTransactionParamsUpdated = new WeakSet();
+checkIfTransactionParamsUpdated_fn = function(newTransactionMeta) {
+  const { id: transactionId, txParams: newParams } = newTransactionMeta;
+  const originalParams = this.getTransaction(transactionId)?.txParams;
+  if (!originalParams || _lodash.isEqual.call(void 0, originalParams, newParams)) {
+    return [];
+  }
+  const params = Object.keys(newParams);
+  const updatedProperties = params.filter(
+    (param) => newParams[param] !== originalParams[param]
+  );
+  _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+    "Transaction parameters have been updated",
+    transactionId,
+    updatedProperties,
+    originalParams,
+    newParams
+  );
+  return updatedProperties;
+};
+_onTransactionParamsUpdated = new WeakSet();
+onTransactionParamsUpdated_fn = function(transactionMeta, updatedParams) {
+  if (["to", "value", "data"].some(
+    (param) => updatedParams.includes(param)
+  )) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating simulation data due to transaction parameter update");
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateSimulationData, updateSimulationData_fn).call(this, transactionMeta);
+  }
+};
+_updateSimulationData = new WeakSet();
+updateSimulationData_fn = async function(transactionMeta) {
+  const { id, chainId, txParams } = transactionMeta;
+  const { from, to, value, data } = txParams;
+  let simulationData = {
+    error: {
+      message: "Simulation disabled",
+      isReverted: false
+    },
+    tokenBalanceChanges: []
+  };
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isSimulationEnabled).call(this)) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, { ...transactionMeta, simulationData: void 0 }, { skipHistory: true });
+    simulationData = await _chunkGC77BSQZjs.getSimulationData.call(void 0, {
+      chainId,
+      from,
+      to,
+      value,
+      data
+    });
+  }
+  const finalTransactionMeta = this.getTransaction(id);
+  if (!finalTransactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+      "Cannot update simulation data as transaction not found",
+      id,
+      simulationData
+    );
+    return;
+  }
+  this.updateTransaction(
+    { ...finalTransactionMeta, simulationData },
+    "TransactionController#updateSimulationData - Update simulation data"
+  );
+  _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updated simulation data", id, simulationData);
+};
+
+
+
+
+
+
+
+exports.HARDFORK = HARDFORK; exports.CANCEL_RATE = CANCEL_RATE; exports.SPEED_UP_RATE = SPEED_UP_RATE; exports.ApprovalState = ApprovalState; exports.TransactionController = TransactionController;
+//# sourceMappingURL=chunk-R7DZLQGJ.js.map
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index 0623d7802df33fd9d0c59c07976611e371abb1bb..dfc0c3ae44d39286941cf3353ce0891b652a9e2e 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -2,7 +2,7 @@
 
 
 
-var _chunk7BG5XOXJjs = require('./chunk-7BG5XOXJ.js');
+var _chunkR7DZLQGJjs = require('./chunk-R7DZLQGJ.js');
 require('./chunk-VH47Q6TS.js');
 require('./chunk-RQKICZYP.js');
 require('./chunk-QP75SWIQ.js');
@@ -56,5 +56,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.CANCEL_RATE = _chunk7BG5XOXJjs.CANCEL_RATE; exports.HARDFORK = _chunk7BG5XOXJjs.HARDFORK; exports.SimulationTokenStandard = _chunkVEJ3MIZGjs.SimulationTokenStandard; exports.TransactionController = _chunk7BG5XOXJjs.TransactionController; exports.TransactionEnvelopeType = _chunkVEJ3MIZGjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkVEJ3MIZGjs.TransactionStatus; exports.TransactionType = _chunkVEJ3MIZGjs.TransactionType; exports.UserFeeLevel = _chunkVEJ3MIZGjs.UserFeeLevel; exports.WalletDevice = _chunkVEJ3MIZGjs.WalletDevice; exports.determineTransactionType = _chunkHS277C77js.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkTZTP4JVAjs.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
+exports.CANCEL_RATE = _chunkR7DZLQGJjs.CANCEL_RATE; exports.HARDFORK = _chunkR7DZLQGJjs.HARDFORK; exports.SimulationTokenStandard = _chunkVEJ3MIZGjs.SimulationTokenStandard; exports.TransactionController = _chunkR7DZLQGJjs.TransactionController; exports.TransactionEnvelopeType = _chunkVEJ3MIZGjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkVEJ3MIZGjs.TransactionStatus; exports.TransactionType = _chunkVEJ3MIZGjs.TransactionType; exports.UserFeeLevel = _chunkVEJ3MIZGjs.UserFeeLevel; exports.WalletDevice = _chunkVEJ3MIZGjs.WalletDevice; exports.determineTransactionType = _chunkHS277C77js.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkTZTP4JVAjs.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
