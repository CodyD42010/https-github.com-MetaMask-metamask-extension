diff --git a/dist/AccountTrackerController.d.ts b/dist/AccountTrackerController.d.ts
index 04ac0f0f99f47be3d52ffaa6e298544139573d04..69f490078b8b690be29b1302156cc3b3b97d5936 100644
--- a/dist/AccountTrackerController.d.ts
+++ b/dist/AccountTrackerController.d.ts
@@ -86,3 +86,4 @@ export declare class AccountTrackerController extends BaseController<AccountTrac
     }>>;
 }
 export default AccountTrackerController;
+//# sourceMappingURL=AccountTrackerController.d.ts.map
\ No newline at end of file
diff --git a/dist/AssetsContractController.d.ts b/dist/AssetsContractController.d.ts
index 18a40db56e6d4664e1c24473f1e1b768b3021224..68279b480024f22ab86965dde0ce101aa0ec6383 100644
--- a/dist/AssetsContractController.d.ts
+++ b/dist/AssetsContractController.d.ts
@@ -174,3 +174,4 @@ export declare class AssetsContractController extends BaseController<AssetsContr
     getBalancesInSingleCall(selectedAddress: string, tokensToDetect: string[]): Promise<BalanceMap>;
 }
 export default AssetsContractController;
+//# sourceMappingURL=AssetsContractController.d.ts.map
\ No newline at end of file
diff --git a/dist/CurrencyRateController.d.ts b/dist/CurrencyRateController.d.ts
index a1189f2aeed5c02a4cf7c1c7dee84981c30a3da6..e2658b8c9cacf58d83ec767c1584bc6aa6e56a1c 100644
--- a/dist/CurrencyRateController.d.ts
+++ b/dist/CurrencyRateController.d.ts
@@ -97,3 +97,4 @@ export declare class CurrencyRateController extends BaseControllerV2<typeof name
     updateExchangeRate(): Promise<CurrencyRateState | void>;
 }
 export default CurrencyRateController;
+//# sourceMappingURL=CurrencyRateController.d.ts.map
\ No newline at end of file
diff --git a/dist/NftController.d.ts b/dist/NftController.d.ts
index 545b3bd30d5f1dd6ffb31267174e953655df773b..a71d8f073752db469de4ee02eb6133c11fa73b0f 100644
--- a/dist/NftController.d.ts
+++ b/dist/NftController.d.ts
@@ -407,3 +407,4 @@ export declare class NftController extends BaseController<NftConfig, NftState> {
     resetNftTransactionStatusByTransactionId(transactionId: string, selectedAddress: string, chainId: string): boolean;
 }
 export default NftController;
+//# sourceMappingURL=NftController.d.ts.map
\ No newline at end of file
diff --git a/dist/NftController.js b/dist/NftController.js
index 83210c8e9dacd6b82a1a9b762c9b15668acf1629..6a14075361516ea98a0763e78ad2bbcd2d85f1ac 100644
--- a/dist/NftController.js
+++ b/dist/NftController.js
@@ -51,7 +51,7 @@ class NftController extends base_controller_1.BaseController {
          */
         this.name = 'NftController';
         this.defaultConfig = {
-            networkType: controller_utils_1.MAINNET,
+            networkType: controller_utils_1.NetworkType.mainnet,
             selectedAddress: '',
             chainId: '',
             ipfsGateway: controller_utils_1.IPFS_DEFAULT_GATEWAY_URL,
diff --git a/dist/NftController.js.map b/dist/NftController.js.map
index 057762b63de1d838649c8581c1dc426bfa66ea22..fea8cab63259b07f331139515c57c1fb88b17622 100644
--- a/dist/NftController.js.map
+++ b/dist/NftController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Mutex } from 'async-mutex';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  MAINNET,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_API_URL,\n  OPENSEA_PROXY_URL,\n  NetworkType,\n} from '@metamask/controller-utils';\nimport type {\n  ApiNft,\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n}\n\ninterface AccountParams {\n  userAddress: string;\n  chainId: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface NftConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [key: string]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [key: string]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private mutex = new Mutex();\n\n  private getNftApi({\n    contractAddress,\n    tokenId,\n    useProxy,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`\n      : `${OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n    useProxy,\n  }: {\n    contractAddress: string;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`\n      : `${OPENSEA_API_URL}/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: AccountParams | undefined = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // Attempt to fetch the data with the proxy\n    let nftInformation: ApiNft | undefined = await fetchWithErrorHandling({\n      url: this.getNftApi({\n        contractAddress,\n        tokenId,\n        useProxy: true,\n      }),\n    });\n\n    // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea\n    if (!nftInformation && this.openSeaApiKey) {\n      nftInformation = await fetchWithErrorHandling({\n        url: this.getNftApi({\n          contractAddress,\n          tokenId,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n    }\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = nftInformation;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains } = this.config;\n    const result = await this.getNftURIAndStandard(contractAddress, tokenId);\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    if (tokenURI.startsWith('ipfs://')) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(contractAddress, tokenId);\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(contractAddress, tokenId);\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const blockchainMetadata = await safelyExecute(async () => {\n      return await this.getNftInformationFromTokenURI(contractAddress, tokenId);\n    });\n\n    let openSeaMetadata;\n    if (this.config.openSeaEnabled) {\n      openSeaMetadata = await safelyExecute(async () => {\n        return await this.getNftInformationFromApi(contractAddress, tokenId);\n      });\n    }\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    let apiNftContractObject: ApiNftContract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n          useProxy: true,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiNftContractObject) {\n      return apiNftContractObject;\n    }\n\n    // if we were unsuccessful in fetching from the API and an OpenSea API key is present\n    // attempt to refetch directly against the OpenSea API and if successful return the data immediately\n    if (this.openSeaApiKey) {\n      apiNftContractObject = await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n\n      if (apiNftContractObject) {\n        return apiNftContractObject;\n      }\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const name = await this.getERC721AssetName(contractAddress);\n    const symbol = await this.getERC721AssetSymbol(contractAddress);\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData: Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'> = await safelyExecute(async () => {\n      return await this.getNftContractInformationFromContract(contractAddress);\n    });\n\n    let openSeaContractData: Partial<ApiNftContract> | undefined;\n    if (this.config.openSeaEnabled) {\n      openSeaContractData = await safelyExecute(async () => {\n        return await this.getNftContractInformationFromApi(contractAddress);\n      });\n    }\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    address: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    detection?: AccountParams,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNfts } = this.state;\n      let chainId, selectedAddress;\n\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === address.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source: detection ? 'detected' : 'custom',\n        });\n      }\n\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract(\n    address: string,\n    detection?: AccountParams,\n  ): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNftContracts } = this.state;\n\n      let chainId, selectedAddress;\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n      const contractInformation = await this.getNftContractInformation(address);\n\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Otherwise at least name from the contract is needed\n      if (\n        (detection && !name) ||\n        Object.keys(contractInformation).length === 0\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeAndIgnoreIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(address: string): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: string;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      onNftAdded,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      networkType: MAINNET,\n      selectedAddress: '',\n      chainId: '',\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n    };\n\n    this.defaultState = {\n      allNftContracts: {},\n      allNfts: {},\n      ignoredNfts: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.onNftAdded = onNftAdded;\n\n    onPreferencesStateChange(\n      ({ selectedAddress, ipfsGateway, openSeaEnabled }) => {\n        this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param nftId - NFT token ID.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    nftId: string,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(nftAddress, nftId);\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        nftId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      'Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.',\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   */\n  async addNftVerifyOwnership(address: string, tokenId: string) {\n    const { selectedAddress } = this.config;\n    if (!(await this.isNftOwner(selectedAddress, address, tokenId))) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId);\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional metadata.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    address: string,\n    tokenId: string,\n    nftMetadata?: NftMetadata,\n    detection?: AccountParams,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newNftContracts = await this.addNftContract(address, detection);\n    nftMetadata =\n      nftMetadata || (await this.getNftInformation(address, tokenId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        address,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        detection,\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeAndIgnoreNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    { userAddress, chainId }: AccountParams | undefined = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch === true) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus() {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true)) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   */\n  updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean) {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: string,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: string,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: string,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n    return true;\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftController.js","sourceRoot":"","sources":["../src/NftController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { BN, stripHexPrefix } from 'ethereumjs-util';\nimport { Mutex } from 'async-mutex';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  safelyExecute,\n  handleFetch,\n  toChecksumHexAddress,\n  BNToHex,\n  fetchWithErrorHandling,\n  IPFS_DEFAULT_GATEWAY_URL,\n  ERC721,\n  ERC1155,\n  OPENSEA_API_URL,\n  OPENSEA_PROXY_URL,\n  NetworkType,\n} from '@metamask/controller-utils';\nimport type {\n  ApiNft,\n  ApiNftCreator,\n  ApiNftContract,\n  ApiNftLastSale,\n} from './NftDetectionController';\nimport type { AssetsContractController } from './AssetsContractController';\nimport { compareNftMetadata, getFormattedIpfsUrl } from './assetsUtil';\n\n/**\n * @type Nft\n *\n * NFT representation\n * @property address - Hex address of a ERC721 contract\n * @property description - The NFT description\n * @property image - URI of custom NFT image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The NFT identifier\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property isCurrentlyOwned - Boolean indicating whether the address/chainId combination where it's currently stored currently owns this NFT\n * @property transactionId - Transaction Id associated with the NFT\n */\nexport interface Nft extends NftMetadata {\n  tokenId: string;\n  address: string;\n  isCurrentlyOwned?: boolean;\n}\n\n/**\n * @type NftContract\n *\n * NFT contract information representation\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Total supply of NFTs\n * @property assetContractType - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property createdDate - Creation date\n * @property schemaName - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property externalLink - External link containing additional information\n */\nexport interface NftContract {\n  name?: string;\n  logo?: string;\n  address: string;\n  symbol?: string;\n  description?: string;\n  totalSupply?: string;\n  assetContractType?: string;\n  createdDate?: string;\n  schemaName?: string;\n  externalLink?: string;\n}\n\n/**\n * @type NftMetadata\n *\n * NFT custom information\n * @property name - NFT custom name\n * @property description - The NFT description\n * @property numberOfSales - Number of sales\n * @property backgroundColor - The background color to be displayed with the item\n * @property image - Image custom image URI\n * @property imagePreview - URI of a smaller image associated with this NFT\n * @property imageThumbnail - URI of a thumbnail image associated with this NFT\n * @property imageOriginal - URI of the original image associated with this NFT\n * @property animation - URI of a animation associated with this NFT\n * @property animationOriginal - URI of the original animation associated with this NFT\n * @property externalLink - External link containing additional information\n * @property creator - The NFT owner information object\n * @property standard - NFT standard name for the NFT, e.g., ERC-721 or ERC-1155\n */\nexport interface NftMetadata {\n  name: string | null;\n  description: string | null;\n  image: string | null;\n  standard: string | null;\n  favorite?: boolean;\n  numberOfSales?: number;\n  backgroundColor?: string;\n  imagePreview?: string;\n  imageThumbnail?: string;\n  imageOriginal?: string;\n  animation?: string;\n  animationOriginal?: string;\n  externalLink?: string;\n  creator?: ApiNftCreator;\n  lastSale?: ApiNftLastSale;\n  transactionId?: string;\n}\n\ninterface AccountParams {\n  userAddress: string;\n  chainId: string;\n}\n\n/**\n * @type NftConfig\n *\n * NFT controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface NftConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  ipfsGateway: string;\n  openSeaEnabled: boolean;\n  useIPFSSubdomains: boolean;\n}\n\n/**\n * @type NftState\n *\n * NFT controller state\n * @property allNftContracts - Object containing NFT contract information\n * @property allNfts - Object containing NFTs per account and network\n * @property ignoredNfts - List of NFTs that should be ignored\n */\nexport interface NftState extends BaseState {\n  allNftContracts: {\n    [key: string]: { [key: string]: NftContract[] };\n  };\n  allNfts: { [key: string]: { [key: string]: Nft[] } };\n  ignoredNfts: Nft[];\n}\n\nconst ALL_NFTS_STATE_KEY = 'allNfts';\nconst ALL_NFTS_CONTRACTS_STATE_KEY = 'allNftContracts';\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class NftController extends BaseController<NftConfig, NftState> {\n  private mutex = new Mutex();\n\n  private getNftApi({\n    contractAddress,\n    tokenId,\n    useProxy,\n  }: {\n    contractAddress: string;\n    tokenId: string;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`\n      : `${OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;\n  }\n\n  private getNftContractInformationApi({\n    contractAddress,\n    useProxy,\n  }: {\n    contractAddress: string;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`\n      : `${OPENSEA_API_URL}/asset_contract/${contractAddress}`;\n  }\n\n  /**\n   * Helper method to update nested state for allNfts and allNftContracts.\n   *\n   * @param newCollection - the modified piece of state to update in the controller's store\n   * @param baseStateKey - The root key in the store to update.\n   * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.\n   * @param passedConfig.userAddress - the address passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   * @param passedConfig.chainId - the chainId passed through the NFT detection flow to ensure detected assets are stored to the correct account\n   */\n  private updateNestedNftState(\n    newCollection: Nft[] | NftContract[],\n    baseStateKey: 'allNfts' | 'allNftContracts',\n    { userAddress, chainId }: AccountParams | undefined = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { [baseStateKey]: oldState } = this.state;\n\n    const addressState = oldState[userAddress];\n    const newAddressState = {\n      ...addressState,\n      ...{ [chainId]: newCollection },\n    };\n    const newState = {\n      ...oldState,\n      ...{ [userAddress]: newAddressState },\n    };\n\n    this.update({\n      [baseStateKey]: newState,\n    });\n  }\n\n  /**\n   * Request individual NFT information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromApi(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    // Attempt to fetch the data with the proxy\n    let nftInformation: ApiNft | undefined = await fetchWithErrorHandling({\n      url: this.getNftApi({\n        contractAddress,\n        tokenId,\n        useProxy: true,\n      }),\n    });\n\n    // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea\n    if (!nftInformation && this.openSeaApiKey) {\n      nftInformation = await fetchWithErrorHandling({\n        url: this.getNftApi({\n          contractAddress,\n          tokenId,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n    }\n\n    // if we were still unable to fetch the data we return out the default/null of `NftMetadata`\n    if (!nftInformation) {\n      return {\n        name: null,\n        description: null,\n        image: null,\n        standard: null,\n      };\n    }\n\n    // if we've reached this point, we have successfully fetched some data for nftInformation\n    // now we reconfigure the data to conform to the `NftMetadata` type for storage.\n    const {\n      num_sales,\n      background_color,\n      image_url,\n      image_preview_url,\n      image_thumbnail_url,\n      image_original_url,\n      animation_url,\n      animation_original_url,\n      name,\n      description,\n      external_link,\n      creator,\n      last_sale,\n      asset_contract: { schema_name },\n    } = nftInformation;\n\n    /* istanbul ignore next */\n    const nftMetadata: NftMetadata = Object.assign(\n      {},\n      { name: name || null },\n      { description: description || null },\n      { image: image_url || null },\n      creator && { creator },\n      num_sales && { numberOfSales: num_sales },\n      background_color && { backgroundColor: background_color },\n      image_preview_url && { imagePreview: image_preview_url },\n      image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n      image_original_url && { imageOriginal: image_original_url },\n      animation_url && { animation: animation_url },\n      animation_original_url && {\n        animationOriginal: animation_original_url,\n      },\n      external_link && { externalLink: external_link },\n      last_sale && { lastSale: last_sale },\n      schema_name && { standard: schema_name },\n    );\n\n    return nftMetadata;\n  }\n\n  /**\n   * Request individual NFT information from contracts that follows Metadata Interface.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformationFromTokenURI(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const { ipfsGateway, useIPFSSubdomains } = this.config;\n    const result = await this.getNftURIAndStandard(contractAddress, tokenId);\n    let tokenURI = result[0];\n    const standard = result[1];\n\n    if (tokenURI.startsWith('ipfs://')) {\n      tokenURI = getFormattedIpfsUrl(ipfsGateway, tokenURI, useIPFSSubdomains);\n    }\n\n    try {\n      const object = await handleFetch(tokenURI);\n      // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155\n      const image = Object.prototype.hasOwnProperty.call(object, 'image')\n        ? 'image'\n        : /* istanbul ignore next */ 'image_url';\n\n      return {\n        image: object[image],\n        name: object.name,\n        description: object.description,\n        standard,\n        favorite: false,\n      };\n    } catch {\n      return {\n        image: null,\n        name: null,\n        description: null,\n        standard: standard || null,\n        favorite: false,\n      };\n    }\n  }\n\n  /**\n   * Retrieve NFT uri with  metadata. TODO Update method to use IPFS.\n   *\n   * @param contractAddress - NFT contract address.\n   * @param tokenId - NFT token id.\n   * @returns Promise resolving NFT uri and token standard.\n   */\n  private async getNftURIAndStandard(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<[string, string]> {\n    // try ERC721 uri\n    try {\n      const uri = await this.getERC721TokenURI(contractAddress, tokenId);\n      return [uri, ERC721];\n    } catch {\n      // Ignore error\n    }\n\n    // try ERC1155 uri\n    try {\n      const tokenURI = await this.getERC1155TokenURI(contractAddress, tokenId);\n\n      /**\n       * According to EIP1155 the URI value allows for ID substitution\n       * in case the string `{id}` exists.\n       * https://eips.ethereum.org/EIPS/eip-1155#metadata\n       */\n\n      if (!tokenURI.includes('{id}')) {\n        return [tokenURI, ERC1155];\n      }\n\n      const hexTokenId = stripHexPrefix(BNToHex(new BN(tokenId)))\n        .padStart(64, '0')\n        .toLowerCase();\n      return [tokenURI.replace('{id}', hexTokenId), ERC1155];\n    } catch {\n      // Ignore error\n    }\n\n    return ['', ''];\n  }\n\n  /**\n   * Request individual NFT information (name, image url and description).\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftInformation(\n    contractAddress: string,\n    tokenId: string,\n  ): Promise<NftMetadata> {\n    const blockchainMetadata = await safelyExecute(async () => {\n      return await this.getNftInformationFromTokenURI(contractAddress, tokenId);\n    });\n\n    let openSeaMetadata;\n    if (this.config.openSeaEnabled) {\n      openSeaMetadata = await safelyExecute(async () => {\n        return await this.getNftInformationFromApi(contractAddress, tokenId);\n      });\n    }\n    return {\n      ...openSeaMetadata,\n      name: blockchainMetadata.name ?? openSeaMetadata?.name ?? null,\n      description:\n        blockchainMetadata.description ?? openSeaMetadata?.description ?? null,\n      image: blockchainMetadata.image ?? openSeaMetadata?.image ?? null,\n      standard:\n        blockchainMetadata.standard ?? openSeaMetadata?.standard ?? null,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromApi(\n    contractAddress: string,\n  ): Promise<ApiNftContract> {\n    /* istanbul ignore if */\n    let apiNftContractObject: ApiNftContract | undefined =\n      await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n          useProxy: true,\n        }),\n      });\n\n    // if we successfully fetched return the fetched data immediately\n    if (apiNftContractObject) {\n      return apiNftContractObject;\n    }\n\n    // if we were unsuccessful in fetching from the API and an OpenSea API key is present\n    // attempt to refetch directly against the OpenSea API and if successful return the data immediately\n    if (this.openSeaApiKey) {\n      apiNftContractObject = await fetchWithErrorHandling({\n        url: this.getNftContractInformationApi({\n          contractAddress,\n          useProxy: false,\n        }),\n        options: {\n          headers: { 'X-API-KEY': this.openSeaApiKey },\n        },\n        // catch 403 errors (in case API key is down we don't want to blow up)\n        errorCodesToCatch: [403],\n      });\n\n      if (apiNftContractObject) {\n        return apiNftContractObject;\n      }\n    }\n\n    // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return\n    // the default/null of ApiNftContract\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: {\n        name: null,\n        image_url: null,\n      },\n    };\n  }\n\n  /**\n   * Request NFT contract information from the contract itself.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT name and image.\n   */\n  private async getNftContractInformationFromContract(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const name = await this.getERC721AssetName(contractAddress);\n    const symbol = await this.getERC721AssetSymbol(contractAddress);\n    return {\n      collection: { name },\n      symbol,\n      address: contractAddress,\n    };\n  }\n\n  /**\n   * Request NFT contract information from OpenSea API.\n   *\n   * @param contractAddress - Hex address of the NFT contract.\n   * @returns Promise resolving to the NFT contract name, image and description.\n   */\n  private async getNftContractInformation(\n    contractAddress: string,\n  ): Promise<\n    Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'>\n  > {\n    const blockchainContractData: Partial<ApiNftContract> &\n      Pick<ApiNftContract, 'address'> &\n      Pick<ApiNftContract, 'collection'> = await safelyExecute(async () => {\n      return await this.getNftContractInformationFromContract(contractAddress);\n    });\n\n    let openSeaContractData: Partial<ApiNftContract> | undefined;\n    if (this.config.openSeaEnabled) {\n      openSeaContractData = await safelyExecute(async () => {\n        return await this.getNftContractInformationFromApi(contractAddress);\n      });\n    }\n\n    if (blockchainContractData || openSeaContractData) {\n      return {\n        ...openSeaContractData,\n        ...blockchainContractData,\n        collection: {\n          image_url: null,\n          ...openSeaContractData?.collection,\n          ...blockchainContractData?.collection,\n        },\n      };\n    }\n\n    /* istanbul ignore next */\n    return {\n      address: contractAddress,\n      asset_contract_type: null,\n      created_date: null,\n      schema_name: null,\n      symbol: null,\n      total_supply: null,\n      description: null,\n      external_link: null,\n      collection: { name: null, image_url: null },\n    };\n  }\n\n  /**\n   * Adds an individual NFT to the stored NFT list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional information (name, image and description).\n   * @param nftContract - An object containing contract data of the NFT being added.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  private async addIndividualNft(\n    address: string,\n    tokenId: string,\n    nftMetadata: NftMetadata,\n    nftContract: NftContract,\n    detection?: AccountParams,\n  ): Promise<Nft[]> {\n    // TODO: Remove unused return\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNfts } = this.state;\n      let chainId, selectedAddress;\n\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry: Nft | undefined = nfts.find(\n        (nft) =>\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId,\n      );\n\n      if (existingEntry) {\n        const differentMetadata = compareNftMetadata(\n          nftMetadata,\n          existingEntry,\n        );\n        if (differentMetadata || !existingEntry.isCurrentlyOwned) {\n          // TODO: Switch to indexToUpdate\n          const indexToRemove = nfts.findIndex(\n            (nft) =>\n              nft.address.toLowerCase() === address.toLowerCase() &&\n              nft.tokenId === tokenId,\n          );\n          /* istanbul ignore next */\n          if (indexToRemove !== -1) {\n            nfts.splice(indexToRemove, 1);\n          }\n        } else {\n          return nfts;\n        }\n      }\n\n      const newEntry: Nft = {\n        address,\n        tokenId,\n        favorite: existingEntry?.favorite || false,\n        isCurrentlyOwned: true,\n        ...nftMetadata,\n      };\n\n      const newNfts = [...nfts, newEntry];\n      this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      if (this.onNftAdded) {\n        this.onNftAdded({\n          address,\n          symbol: nftContract.symbol,\n          tokenId: tokenId.toString(),\n          standard: nftMetadata.standard,\n          source: detection ? 'detected' : 'custom',\n        });\n      }\n\n      return newNfts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private async addNftContract(\n    address: string,\n    detection?: AccountParams,\n  ): Promise<NftContract[]> {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { allNftContracts } = this.state;\n\n      let chainId, selectedAddress;\n      if (detection) {\n        chainId = detection.chainId;\n        selectedAddress = detection.userAddress;\n      } else {\n        chainId = this.config.chainId;\n        selectedAddress = this.config.selectedAddress;\n      }\n\n      const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n      const existingEntry = nftContracts.find(\n        (nftContract) =>\n          nftContract.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (existingEntry) {\n        return nftContracts;\n      }\n      const contractInformation = await this.getNftContractInformation(address);\n\n      const {\n        asset_contract_type,\n        created_date,\n        schema_name,\n        symbol,\n        total_supply,\n        description,\n        external_link,\n        collection: { name, image_url },\n      } = contractInformation;\n      // If being auto-detected opensea information is expected\n      // Otherwise at least name from the contract is needed\n      if (\n        (detection && !name) ||\n        Object.keys(contractInformation).length === 0\n      ) {\n        return nftContracts;\n      }\n\n      /* istanbul ignore next */\n      const newEntry: NftContract = Object.assign(\n        {},\n        { address },\n        description && { description },\n        name && { name },\n        image_url && { logo: image_url },\n        symbol && { symbol },\n        total_supply !== null &&\n          typeof total_supply !== 'undefined' && { totalSupply: total_supply },\n        asset_contract_type && { assetContractType: asset_contract_type },\n        created_date && { createdDate: created_date },\n        schema_name && { schemaName: schema_name },\n        external_link && { externalLink: external_link },\n      );\n      const newNftContracts = [...nftContracts, newEntry];\n      this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY, {\n        chainId,\n        userAddress: selectedAddress,\n      });\n\n      return newNftContracts;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeAndIgnoreIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts, ignoredNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const newIgnoredNfts = [...ignoredNfts];\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter((nft) => {\n      if (\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId\n      ) {\n        const alreadyIgnored = newIgnoredNfts.find(\n          (c) => c.address === address && c.tokenId === tokenId,\n        );\n        !alreadyIgnored && newIgnoredNfts.push(nft);\n        return false;\n      }\n      return true;\n    });\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n\n    this.update({\n      ignoredNfts: newIgnoredNfts,\n    });\n  }\n\n  /**\n   * Removes an individual NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  private removeIndividualNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const newNfts = nfts.filter(\n      (nft) =>\n        !(\n          nft.address.toLowerCase() === address.toLowerCase() &&\n          nft.tokenId === tokenId\n        ),\n    );\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Removes an NFT contract to the stored NFT contracts list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @returns Promise resolving to the current NFT contracts list.\n   */\n  private removeNftContract(address: string): NftContract[] {\n    address = toChecksumHexAddress(address);\n    const { allNftContracts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nftContracts = allNftContracts[selectedAddress]?.[chainId] || [];\n\n    const newNftContracts = nftContracts.filter(\n      (nftContract) =>\n        !(nftContract.address.toLowerCase() === address.toLowerCase()),\n    );\n    this.updateNestedNftState(newNftContracts, ALL_NFTS_CONTRACTS_STATE_KEY);\n\n    return newNftContracts;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Optional API key to use with opensea\n   */\n  openSeaApiKey?: string;\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftController';\n\n  private getERC721AssetName: AssetsContractController['getERC721AssetName'];\n\n  private getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n\n  private getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n\n  private getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n\n  private getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n\n  private getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n\n  private onNftAdded?: (data: {\n    address: string;\n    symbol: string | undefined;\n    tokenId: string;\n    standard: string | null;\n    source: string;\n  }) => void;\n\n  /**\n   * Creates an NftController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getERC721AssetName - Gets the name of the asset at the given address.\n   * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.\n   * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.\n   * @param options.getERC721OwnerOf - Get the owner of a ERC-721 NFT.\n   * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 NFT.\n   * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.\n   * @param options.onNftAdded - Callback that is called when an NFT is added. Currently used pass data\n   * for tracking the NFT added event.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getERC721AssetName,\n      getERC721AssetSymbol,\n      getERC721TokenURI,\n      getERC721OwnerOf,\n      getERC1155BalanceOf,\n      getERC1155TokenURI,\n      onNftAdded,\n    }: {\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getERC721AssetName: AssetsContractController['getERC721AssetName'];\n      getERC721AssetSymbol: AssetsContractController['getERC721AssetSymbol'];\n      getERC721TokenURI: AssetsContractController['getERC721TokenURI'];\n      getERC721OwnerOf: AssetsContractController['getERC721OwnerOf'];\n      getERC1155BalanceOf: AssetsContractController['getERC1155BalanceOf'];\n      getERC1155TokenURI: AssetsContractController['getERC1155TokenURI'];\n      onNftAdded?: (data: {\n        address: string;\n        symbol: string | undefined;\n        tokenId: string;\n        standard: string | null;\n        source: string;\n      }) => void;\n    },\n    config?: Partial<BaseConfig>,\n    state?: Partial<NftState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      networkType: NetworkType.mainnet,\n      selectedAddress: '',\n      chainId: '',\n      ipfsGateway: IPFS_DEFAULT_GATEWAY_URL,\n      openSeaEnabled: false,\n      useIPFSSubdomains: true,\n    };\n\n    this.defaultState = {\n      allNftContracts: {},\n      allNfts: {},\n      ignoredNfts: [],\n    };\n    this.initialize();\n    this.getERC721AssetName = getERC721AssetName;\n    this.getERC721AssetSymbol = getERC721AssetSymbol;\n    this.getERC721TokenURI = getERC721TokenURI;\n    this.getERC721OwnerOf = getERC721OwnerOf;\n    this.getERC1155BalanceOf = getERC1155BalanceOf;\n    this.getERC1155TokenURI = getERC1155TokenURI;\n    this.onNftAdded = onNftAdded;\n\n    onPreferencesStateChange(\n      ({ selectedAddress, ipfsGateway, openSeaEnabled }) => {\n        this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });\n      },\n    );\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { chainId } = providerConfig;\n      this.configure({ chainId });\n    });\n  }\n\n  /**\n   * Sets an OpenSea API key to retrieve NFT information.\n   *\n   * @param openSeaApiKey - OpenSea API key.\n   */\n  setApiKey(openSeaApiKey: string) {\n    this.openSeaApiKey = openSeaApiKey;\n  }\n\n  /**\n   * Checks the ownership of a ERC-721 or ERC-1155 NFT for a given address.\n   *\n   * @param ownerAddress - User public address.\n   * @param nftAddress - NFT contract address.\n   * @param nftId - NFT token ID.\n   * @returns Promise resolving the NFT ownership.\n   */\n  async isNftOwner(\n    ownerAddress: string,\n    nftAddress: string,\n    nftId: string,\n  ): Promise<boolean> {\n    // Checks the ownership for ERC-721.\n    try {\n      const owner = await this.getERC721OwnerOf(nftAddress, nftId);\n      return ownerAddress.toLowerCase() === owner.toLowerCase();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-721 contract error\n    }\n\n    // Checks the ownership for ERC-1155.\n    try {\n      const balance = await this.getERC1155BalanceOf(\n        ownerAddress,\n        nftAddress,\n        nftId,\n      );\n      return !balance.isZero();\n      // eslint-disable-next-line no-empty\n    } catch {\n      // Ignore ERC-1155 contract error\n    }\n\n    throw new Error(\n      'Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.',\n    );\n  }\n\n  /**\n   * Verifies currently selected address owns entered NFT address/tokenId combo and\n   * adds the NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   */\n  async addNftVerifyOwnership(address: string, tokenId: string) {\n    const { selectedAddress } = this.config;\n    if (!(await this.isNftOwner(selectedAddress, address, tokenId))) {\n      throw new Error('This NFT is not owned by the user');\n    }\n    await this.addNft(address, tokenId);\n  }\n\n  /**\n   * Adds an NFT and respective NFT contract to the stored NFT and NFT contracts lists.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - The NFT identifier.\n   * @param nftMetadata - NFT optional metadata.\n   * @param detection - The chain ID and address of the currently selected network and account at the moment the NFT was detected.\n   * @returns Promise resolving to the current NFT list.\n   */\n  async addNft(\n    address: string,\n    tokenId: string,\n    nftMetadata?: NftMetadata,\n    detection?: AccountParams,\n  ) {\n    address = toChecksumHexAddress(address);\n    const newNftContracts = await this.addNftContract(address, detection);\n    nftMetadata =\n      nftMetadata || (await this.getNftInformation(address, tokenId));\n\n    // If NFT contract was not added, do not add individual NFT\n    const nftContract = newNftContracts.find(\n      (contract) => contract.address.toLowerCase() === address.toLowerCase(),\n    );\n\n    // If NFT contract information, add individual NFT\n    if (nftContract) {\n      await this.addIndividualNft(\n        address,\n        tokenId,\n        nftMetadata,\n        nftContract,\n        detection,\n      );\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes an NFT from the stored token list and saves it in ignored NFTs list.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Token identifier of the NFT.\n   */\n  removeAndIgnoreNft(address: string, tokenId: string) {\n    address = toChecksumHexAddress(address);\n    this.removeAndIgnoreIndividualNft(address, tokenId);\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const remainingNft = nfts.find(\n      (nft) => nft.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (!remainingNft) {\n      this.removeNftContract(address);\n    }\n  }\n\n  /**\n   * Removes all NFTs from the ignored list.\n   */\n  clearIgnoredNfts() {\n    this.update({ ignoredNfts: [] });\n  }\n\n  /**\n   * Checks whether input NFT is still owned by the user\n   * And updates the isCurrentlyOwned value on the NFT object accordingly.\n   *\n   * @param nft - The NFT object to check and update.\n   * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.\n   * @param accountParams - The userAddress and chainId to check ownership against\n   * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account\n   * @returns the NFT with the updated isCurrentlyOwned value\n   */\n  async checkAndUpdateSingleNftOwnershipStatus(\n    nft: Nft,\n    batch: boolean,\n    { userAddress, chainId }: AccountParams | undefined = {\n      userAddress: this.config.selectedAddress,\n      chainId: this.config.chainId,\n    },\n  ) {\n    const { address, tokenId } = nft;\n    let isOwned = nft.isCurrentlyOwned;\n    try {\n      isOwned = await this.isNftOwner(userAddress, address, tokenId);\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error &&\n          error.message.includes('Unable to verify ownership')\n        )\n      ) {\n        throw error;\n      }\n    }\n\n    nft.isCurrentlyOwned = isOwned;\n\n    if (batch === true) {\n      return nft;\n    }\n\n    // if this is not part of a batched update we update this one NFT in state\n    const { allNfts } = this.state;\n    const nfts = allNfts[userAddress]?.[chainId] || [];\n    const nftToUpdate = nfts.find(\n      (item) =>\n        item.tokenId === tokenId &&\n        item.address.toLowerCase() === address.toLowerCase(),\n    );\n    if (nftToUpdate) {\n      nftToUpdate.isCurrentlyOwned = isOwned;\n      this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY, {\n        userAddress,\n        chainId,\n      });\n    }\n    return nft;\n  }\n\n  /**\n   * Checks whether NFTs associated with current selectedAddress/chainId combination are still owned by the user\n   * And updates the isCurrentlyOwned value on each accordingly.\n   */\n  async checkAndUpdateAllNftsOwnershipStatus() {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const updatedNfts = await Promise.all(\n      nfts.map(async (nft) => {\n        return (\n          (await this.checkAndUpdateSingleNftOwnershipStatus(nft, true)) ?? nft\n        );\n      }),\n    );\n\n    this.updateNestedNftState(updatedNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Update NFT favorite status.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Hex address of the NFT contract.\n   * @param favorite - NFT new favorite status.\n   */\n  updateNftFavoriteStatus(address: string, tokenId: string, favorite: boolean) {\n    const { allNfts } = this.state;\n    const { chainId, selectedAddress } = this.config;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.address === address && nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nfts[index],\n      favorite,\n    };\n\n    // Update Nfts array\n    nfts[index] = updatedNft;\n\n    this.updateNestedNftState(nfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Returns an NFT by the address and token id.\n   *\n   * @param address - Hex address of the NFT contract.\n   * @param tokenId - Number that represents the id of the token.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns Object containing the NFT and its position in the array\n   */\n  findNftByAddressAndTokenId(\n    address: string,\n    tokenId: string,\n    selectedAddress: string,\n    chainId: string,\n  ): { nft: Nft; index: number } | null {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n\n    const index: number = nfts.findIndex(\n      (nft) =>\n        nft.address.toLowerCase() === address.toLowerCase() &&\n        nft.tokenId === tokenId,\n    );\n\n    if (index === -1) {\n      return null;\n    }\n\n    return { nft: nfts[index], index };\n  }\n\n  /**\n   * Update NFT data.\n   *\n   * @param nft - NFT object to find the right NFT to updates.\n   * @param updates - NFT partial object to update properties of the NFT.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   */\n  updateNft(\n    nft: Nft,\n    updates: Partial<Nft>,\n    selectedAddress: string,\n    chainId: string,\n  ) {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const nftInfo = this.findNftByAddressAndTokenId(\n      nft.address,\n      nft.tokenId,\n      selectedAddress,\n      chainId,\n    );\n\n    if (!nftInfo) {\n      return;\n    }\n\n    const updatedNft: Nft = {\n      ...nft,\n      ...updates,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, nftInfo.index),\n      updatedNft,\n      ...nfts.slice(nftInfo.index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n  }\n\n  /**\n   * Resets the transaction status of an NFT.\n   *\n   * @param transactionId - NFT transaction id.\n   * @param selectedAddress - Hex address of the user account.\n   * @param chainId - Id of the current network.\n   * @returns a boolean indicating if the reset was well succeded or not\n   */\n  resetNftTransactionStatusByTransactionId(\n    transactionId: string,\n    selectedAddress: string,\n    chainId: string,\n  ): boolean {\n    const { allNfts } = this.state;\n    const nfts = allNfts[selectedAddress]?.[chainId] || [];\n    const index: number = nfts.findIndex(\n      (nft) => nft.transactionId === transactionId,\n    );\n\n    if (index === -1) {\n      return false;\n    }\n    const updatedNft: Nft = {\n      ...nfts[index],\n      transactionId: undefined,\n    };\n\n    const newNfts = [\n      ...nfts.slice(0, index),\n      updatedNft,\n      ...nfts.slice(index + 1),\n    ];\n\n    this.updateNestedNftState(newNfts, ALL_NFTS_STATE_KEY);\n    return true;\n  }\n}\n\nexport default NftController;\n"]}
\ No newline at end of file
diff --git a/dist/NftDetectionController.d.ts b/dist/NftDetectionController.d.ts
index e2ea191fcd4d4faf82854c87beff3435225693eb..20d65abf916518c5347eea9d6a47ae7c50db9b31 100644
--- a/dist/NftDetectionController.d.ts
+++ b/dist/NftDetectionController.d.ts
@@ -177,3 +177,4 @@ export declare class NftDetectionController extends BaseController<NftDetectionC
     detectNfts(): Promise<void>;
 }
 export default NftDetectionController;
+//# sourceMappingURL=NftDetectionController.d.ts.map
\ No newline at end of file
diff --git a/dist/NftDetectionController.js b/dist/NftDetectionController.js
index 38ddb4ab9228fee3a45994ef64070b19ef7a9971..81526698c0127aa0f4f3564b8193910e24ca4d6f 100644
--- a/dist/NftDetectionController.js
+++ b/dist/NftDetectionController.js
@@ -41,10 +41,10 @@ class NftDetectionController extends base_controller_1.BaseController {
          *
          * @returns Whether current network is mainnet.
          */
-        this.isMainnet = () => this.config.networkType === controller_utils_1.MAINNET;
+        this.isMainnet = () => this.config.networkType === 'mainnet';
         this.defaultConfig = {
             interval: DEFAULT_INTERVAL,
-            networkType: controller_utils_1.MAINNET,
+            networkType: 'mainnet',
             chainId: '1',
             selectedAddress: '',
             disabled: true,
diff --git a/dist/NftDetectionController.js.map b/dist/NftDetectionController.js.map
index 76893378852f9301799fcb9745feb8b8245d8c56..43c7f5baace742c84ecf42d225e09dc0f15593d5 100644
--- a/dist/NftDetectionController.js.map
+++ b/dist/NftDetectionController.js.map
@@ -1 +1 @@
-{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+DAImC;AAGnC,iEAOoC;AAGpC,MAAM,gBAAgB,GAAG,MAAM,CAAC;AAiHhC;;GAEG;AACH,MAAa,sBAAuB,SAAQ,gCAG3C;IAoEC;;;;;;;;;;;;OAYG;IACH,YACE,EACE,wBAAwB,EACxB,oBAAoB,EACpB,gBAAgB,EAChB,MAAM,EACN,WAAW,GAYZ,EACD,MAAoC,EACpC,KAA0B;QAE1B,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QA9CvB;;WAEG;QACM,SAAI,GAAG,wBAAwB,CAAC;QAyHzC;;;;WAIG;QACH,cAAS,GAAG,GAAY,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,KAAK,0BAAO,CAAC;QAlF7D,IAAI,CAAC,aAAa,GAAG;YACnB,QAAQ,EAAE,gBAAgB;YAC1B,WAAW,EAAE,0BAAO;YACpB,OAAO,EAAE,GAAG;YACZ,eAAe,EAAE,EAAE;YACnB,QAAQ,EAAE,IAAI;SACf,CAAC;QACF,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,wBAAwB,CAAC,CAAC,EAAE,eAAe,EAAE,eAAe,EAAE,EAAE,EAAE;YAChE,MAAM,EAAE,eAAe,EAAE,yBAAyB,EAAE,QAAQ,EAAE,GAC5D,IAAI,CAAC,MAAM,CAAC;YAEd,IACE,eAAe,KAAK,yBAAyB;gBAC7C,CAAC,eAAe,KAAK,QAAQ,EAC7B;gBACA,IAAI,CAAC,SAAS,CAAC,EAAE,eAAe,EAAE,QAAQ,EAAE,CAAC,eAAe,EAAE,CAAC,CAAC;aACjE;YAED,IAAI,eAAe,KAAK,SAAS,EAAE;gBACjC,IAAI,eAAe,EAAE;oBACnB,IAAI,CAAC,KAAK,EAAE,CAAC;iBACd;qBAAM;oBACL,IAAI,CAAC,IAAI,EAAE,CAAC;iBACb;aACF;QACH,CAAC,CAAC,CAAC;QAEH,oBAAoB,CAAC,CAAC,EAAE,cAAc,EAAE,EAAE,EAAE;YAC1C,IAAI,CAAC,SAAS,CAAC;gBACb,WAAW,EAAE,cAAc,CAAC,IAAI;gBAChC,OAAO,EAAE,cAAc,CAAC,OAAwC;aACjE,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IA1IO,cAAc,CAAC,EACrB,OAAO,EACP,MAAM,EACN,QAAQ,GAKT;QACC,OAAO,QAAQ;YACb,CAAC,CAAC,GAAG,oCAAiB,iBAAiB,OAAO,WAAW,MAAM,WAAW;YAC1E,CAAC,CAAC,GAAG,kCAAe,iBAAiB,OAAO,WAAW,MAAM,WAAW,CAAC;IAC7E,CAAC;IAEa,YAAY,CAAC,OAAe;;;YACxC,IAAI,cAAoC,CAAC;YACzC,IAAI,IAAI,GAAa,EAAE,CAAC;YACxB,MAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC9C,IAAI,MAAM,GAAG,CAAC,CAAC;YACf,IAAI,YAAY,GAAG,KAAK,CAAC;YACzB,wBAAwB;YACxB,GAAG;gBACD,cAAc,GAAG,MAAM,IAAA,yCAAsB,EAAC;oBAC5C,GAAG,EAAE,IAAI,CAAC,cAAc,CAAC,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;oBAC7D,OAAO,EAAE,KAAK;iBACf,CAAC,CAAC;gBAEH,IAAI,aAAa,IAAI,CAAC,cAAc,EAAE;oBACpC,cAAc,GAAG,MAAM,IAAA,yCAAsB,EAAC;wBAC5C,GAAG,EAAE,IAAI,CAAC,cAAc,CAAC;4BACvB,OAAO;4BACP,MAAM;4BACN,QAAQ,EAAE,KAAK;yBAChB,CAAC;wBACF,OAAO,EAAE,EAAE,OAAO,EAAE,EAAE,WAAW,EAAE,aAAa,EAAE,EAAE;wBACpD,OAAO,EAAE,KAAK;wBACd,sEAAsE;wBACtE,iBAAiB,EAAE,CAAC,GAAG,CAAC;qBACzB,CAAC,CAAC;iBACJ;gBAED,IAAI,CAAC,cAAc,EAAE;oBACnB,OAAO,IAAI,CAAC;iBACb;gBAED,CAAA,MAAA,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAE,MAAM,0CAAE,MAAM,MAAK,CAAC;oBAClC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,GAAG,IAAI,EAAE,GAAG,cAAc,CAAC,MAAM,CAAC,CAAC;oBAC9C,CAAC,CAAC,CAAC,YAAY,GAAG,IAAI,CAAC,CAAC;gBAC1B,MAAM,IAAI,EAAE,CAAC;aACd,QAAQ,CAAC,YAAY,EAAE;YAExB,OAAO,IAAI,CAAC;;KACb;IAwFD;;OAEG;IACG,KAAK;;YACT,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACtC,OAAO;aACR;YAED,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;QAC5B,CAAC;KAAA;IAED;;OAEG;IACH,IAAI;QACF,IAAI,CAAC,WAAW,EAAE,CAAC;IACrB,CAAC;IAEO,WAAW;QACjB,IAAI,IAAI,CAAC,UAAU,EAAE;YACnB,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SAChC;IACH,CAAC;IAED;;;;OAIG;IACW,YAAY,CAAC,QAAiB;;YAC1C,QAAQ,IAAI,IAAI,CAAC,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;YACvD,IAAI,CAAC,WAAW,EAAE,CAAC;YACnB,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;YACxB,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,GAAS,EAAE;gBACvC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;YAC1B,CAAC,CAAA,EAAE,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;QAC3B,CAAC;KAAA;IASD;;;OAGG;IACG,UAAU;;YACd,wBAAwB;YACxB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACtC,OAAO;aACR;YACD,MAAM,EAAE,eAAe,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC;YAEjD,0BAA0B;YAC1B,IAAI,CAAC,eAAe,EAAE;gBACpB,OAAO;aACR;YAED,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,CAAC;YACzD,MAAM,cAAc,GAAG,OAAO,CAAC,GAAG,CAAC,CAAO,GAAW,EAAE,EAAE;gBACvD,MAAM,EACJ,QAAQ,EACR,SAAS,EACT,gBAAgB,EAChB,SAAS,EACT,iBAAiB,EACjB,mBAAmB,EACnB,kBAAkB,EAClB,aAAa,EACb,sBAAsB,EACtB,IAAI,EACJ,WAAW,EACX,aAAa,EACb,OAAO,EACP,cAAc,EAAE,EAAE,OAAO,EAAE,WAAW,EAAE,EACxC,SAAS,GACV,GAAG,GAAG,CAAC;gBAER,IAAI,OAAO,CAAC;gBACZ,0BAA0B;gBAC1B,MAAM,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;gBAC3C,IAAI,WAAW,CAAC,MAAM,EAAE;oBACtB,OAAO,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE;wBAC/B,0BAA0B;wBAC1B,OAAO,CACL,CAAC,CAAC,OAAO,KAAK,IAAA,uCAAoB,EAAC,OAAO,CAAC;4BAC3C,CAAC,CAAC,OAAO,KAAK,QAAQ,CACvB,CAAC;oBACJ,CAAC,CAAC,CAAC;iBACJ;gBAED,0BAA0B;gBAC1B,IAAI,CAAC,OAAO,EAAE;oBACZ,0BAA0B;oBAC1B,MAAM,WAAW,GAAgB,MAAM,CAAC,MAAM,CAC5C,EAAE,EACF,EAAE,IAAI,EAAE,EACR,OAAO,IAAI,EAAE,OAAO,EAAE,EACtB,WAAW,IAAI,EAAE,WAAW,EAAE,EAC9B,SAAS,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,EACjC,SAAS,IAAI,EAAE,aAAa,EAAE,SAAS,EAAE,EACzC,gBAAgB,IAAI,EAAE,eAAe,EAAE,gBAAgB,EAAE,EACzD,iBAAiB,IAAI,EAAE,YAAY,EAAE,iBAAiB,EAAE,EACxD,mBAAmB,IAAI,EAAE,cAAc,EAAE,mBAAmB,EAAE,EAC9D,kBAAkB,IAAI,EAAE,aAAa,EAAE,kBAAkB,EAAE,EAC3D,aAAa,IAAI,EAAE,SAAS,EAAE,aAAa,EAAE,EAC7C,sBAAsB,IAAI;wBACxB,iBAAiB,EAAE,sBAAsB;qBAC1C,EACD,WAAW,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,EACxC,aAAa,IAAI,EAAE,YAAY,EAAE,aAAa,EAAE,EAChD,SAAS,IAAI,EAAE,QAAQ,EAAE,SAAS,EAAE,CACrC,CAAC;oBAEF,MAAM,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE;wBAChD,WAAW,EAAE,eAAe;wBAC5B,OAAO,EAAE,OAAiB;qBAC3B,CAAC,CAAC;iBACJ;YACH,CAAC,CAAA,CAAC,CAAC;YACH,MAAM,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;QACpC,CAAC;KAAA;CACF;AA/QD,wDA+QC;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport {\n  MAINNET,\n  OPENSEA_PROXY_URL,\n  OPENSEA_API_URL,\n  NetworkType,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type { NftController, NftState, NftMetadata } from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  networkType: NetworkType;\n  chainId: `0x${string}` | `${number}` | number;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends BaseController<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    offset,\n    useProxy,\n  }: {\n    address: string;\n    offset: number;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`\n      : `${OPENSEA_API_URL}/assets?owner=${address}&offset=${offset}&limit=50`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: { assets: ApiNft[] };\n    let nfts: ApiNft[] = [];\n    const openSeaApiKey = this.getOpenSeaApiKey();\n    let offset = 0;\n    let pagingFinish = false;\n    /* istanbul ignore if */\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, offset, useProxy: true }),\n        timeout: 15000,\n      });\n\n      if (openSeaApiKey && !nftApiResponse) {\n        nftApiResponse = await fetchWithErrorHandling({\n          url: this.getOwnerNftApi({\n            address,\n            offset,\n            useProxy: false,\n          }),\n          options: { headers: { 'X-API-KEY': openSeaApiKey } },\n          timeout: 15000,\n          // catch 403 errors (in case API key is down we don't want to blow up)\n          errorCodesToCatch: [403],\n        });\n      }\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      nftApiResponse?.assets?.length !== 0\n        ? (nfts = [...nfts, ...nftApiResponse.assets])\n        : (pagingFinish = true);\n      offset += 50;\n    } while (!pagingFinish);\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private addNft: NftController['addNft'];\n\n  private getNftState: () => NftState;\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftState,\n    }: {\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      networkType: MAINNET,\n      chainId: '1',\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n      }\n\n      if (useNftDetection !== undefined) {\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        networkType: providerConfig.type,\n        chainId: providerConfig.chainId as NftDetectionConfig['chainId'],\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.networkType === MAINNET;\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   */\n  async detectNfts() {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    const { selectedAddress, chainId } = this.config;\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(selectedAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(address, token_id, nftMetadata, {\n          userAddress: selectedAddress,\n          chainId: chainId as string,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
+{"version":3,"file":"NftDetectionController.js","sourceRoot":"","sources":["../src/NftDetectionController.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport {\n  OPENSEA_PROXY_URL,\n  OPENSEA_API_URL,\n  NetworkType,\n  fetchWithErrorHandling,\n  toChecksumHexAddress,\n} from '@metamask/controller-utils';\nimport type { NftController, NftState, NftMetadata } from './NftController';\n\nconst DEFAULT_INTERVAL = 180000;\n\n/**\n * @type ApiNft\n *\n * NFT object coming from OpenSea api\n * @property token_id - The NFT identifier\n * @property num_sales - Number of sales\n * @property background_color - The background color to be displayed with the item\n * @property image_url - URI of an image associated with this NFT\n * @property image_preview_url - URI of a smaller image associated with this NFT\n * @property image_thumbnail_url - URI of a thumbnail image associated with this NFT\n * @property image_original_url - URI of the original image associated with this NFT\n * @property animation_url - URI of a animation associated with this NFT\n * @property animation_original_url - URI of the original animation associated with this NFT\n * @property name - The NFT name\n * @property description - The NFT description\n * @property external_link - External link containing additional information\n * @property assetContract - The NFT contract information object\n * @property creator - The NFT owner information object\n * @property lastSale - When this item was last sold\n */\nexport interface ApiNft {\n  token_id: string;\n  num_sales: number | null;\n  background_color: string | null;\n  image_url: string | null;\n  image_preview_url: string | null;\n  image_thumbnail_url: string | null;\n  image_original_url: string | null;\n  animation_url: string | null;\n  animation_original_url: string | null;\n  name: string | null;\n  description: string | null;\n  external_link: string | null;\n  asset_contract: ApiNftContract;\n  creator: ApiNftCreator;\n  last_sale: ApiNftLastSale | null;\n}\n\n/**\n * @type ApiNftContract\n *\n * NFT contract object coming from OpenSea api\n * @property address - Address of the NFT contract\n * @property asset_contract_type - The NFT type, it could be `semi-fungible` or `non-fungible`\n * @property created_date - Creation date\n * @property collection - Object containing the contract name and URI of an image associated\n * @property schema_name - The schema followed by the contract, it could be `ERC721` or `ERC1155`\n * @property symbol - The NFT contract symbol\n * @property total_supply - Total supply of NFTs\n * @property description - The NFT contract description\n * @property external_link - External link containing additional information\n */\nexport interface ApiNftContract {\n  address: string;\n  asset_contract_type: string | null;\n  created_date: string | null;\n  schema_name: string | null;\n  symbol: string | null;\n  total_supply: string | null;\n  description: string | null;\n  external_link: string | null;\n  collection: {\n    name: string | null;\n    image_url?: string | null;\n  };\n}\n\n/**\n * @type ApiNftLastSale\n *\n * NFT sale object coming from OpenSea api\n * @property event_timestamp - Object containing a `username`\n * @property total_price - URI of NFT image associated with this owner\n * @property transaction - Object containing transaction_hash and block_hash\n */\nexport interface ApiNftLastSale {\n  event_timestamp: string;\n  total_price: string;\n  transaction: { transaction_hash: string; block_hash: string };\n}\n\n/**\n * @type ApiNftCreator\n *\n * NFT creator object coming from OpenSea api\n * @property user - Object containing a `username`\n * @property profile_img_url - URI of NFT image associated with this owner\n * @property address - The owner address\n */\nexport interface ApiNftCreator {\n  user: { username: string };\n  profile_img_url: string;\n  address: string;\n}\n\n/**\n * @type NftDetectionConfig\n *\n * NftDetection configuration\n * @property interval - Polling interval used to fetch new token rates\n * @property networkType - Network type ID as per net_version\n * @property selectedAddress - Vault selected address\n * @property tokens - List of tokens associated with the active vault\n */\nexport interface NftDetectionConfig extends BaseConfig {\n  interval: number;\n  networkType: NetworkType;\n  chainId: `0x${string}` | `${number}` | number;\n  selectedAddress: string;\n}\n\n/**\n * Controller that passively polls on a set interval for NFT auto detection\n */\nexport class NftDetectionController extends BaseController<\n  NftDetectionConfig,\n  BaseState\n> {\n  private intervalId?: ReturnType<typeof setTimeout>;\n\n  private getOwnerNftApi({\n    address,\n    offset,\n    useProxy,\n  }: {\n    address: string;\n    offset: number;\n    useProxy: boolean;\n  }) {\n    return useProxy\n      ? `${OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`\n      : `${OPENSEA_API_URL}/assets?owner=${address}&offset=${offset}&limit=50`;\n  }\n\n  private async getOwnerNfts(address: string) {\n    let nftApiResponse: { assets: ApiNft[] };\n    let nfts: ApiNft[] = [];\n    const openSeaApiKey = this.getOpenSeaApiKey();\n    let offset = 0;\n    let pagingFinish = false;\n    /* istanbul ignore if */\n    do {\n      nftApiResponse = await fetchWithErrorHandling({\n        url: this.getOwnerNftApi({ address, offset, useProxy: true }),\n        timeout: 15000,\n      });\n\n      if (openSeaApiKey && !nftApiResponse) {\n        nftApiResponse = await fetchWithErrorHandling({\n          url: this.getOwnerNftApi({\n            address,\n            offset,\n            useProxy: false,\n          }),\n          options: { headers: { 'X-API-KEY': openSeaApiKey } },\n          timeout: 15000,\n          // catch 403 errors (in case API key is down we don't want to blow up)\n          errorCodesToCatch: [403],\n        });\n      }\n\n      if (!nftApiResponse) {\n        return nfts;\n      }\n\n      nftApiResponse?.assets?.length !== 0\n        ? (nfts = [...nfts, ...nftApiResponse.assets])\n        : (pagingFinish = true);\n      offset += 50;\n    } while (!pagingFinish);\n\n    return nfts;\n  }\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'NftDetectionController';\n\n  private getOpenSeaApiKey: () => string | undefined;\n\n  private addNft: NftController['addNft'];\n\n  private getNftState: () => NftState;\n\n  /**\n   * Creates an NftDetectionController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onNftsStateChange - Allows subscribing to assets controller state changes.\n   * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.\n   * @param options.addNft - Add an NFT.\n   * @param options.getNftState - Gets the current state of the Assets controller.\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   */\n  constructor(\n    {\n      onPreferencesStateChange,\n      onNetworkStateChange,\n      getOpenSeaApiKey,\n      addNft,\n      getNftState,\n    }: {\n      onNftsStateChange: (listener: (nftsState: NftState) => void) => void;\n      onPreferencesStateChange: (\n        listener: (preferencesState: PreferencesState) => void,\n      ) => void;\n      onNetworkStateChange: (\n        listener: (networkState: NetworkState) => void,\n      ) => void;\n      getOpenSeaApiKey: () => string | undefined;\n      addNft: NftController['addNft'];\n      getNftState: () => NftState;\n    },\n    config?: Partial<NftDetectionConfig>,\n    state?: Partial<BaseState>,\n  ) {\n    super(config, state);\n    this.defaultConfig = {\n      interval: DEFAULT_INTERVAL,\n      networkType: 'mainnet' as NetworkType,\n      chainId: '1',\n      selectedAddress: '',\n      disabled: true,\n    };\n    this.initialize();\n    this.getNftState = getNftState;\n    onPreferencesStateChange(({ selectedAddress, useNftDetection }) => {\n      const { selectedAddress: previouslySelectedAddress, disabled } =\n        this.config;\n\n      if (\n        selectedAddress !== previouslySelectedAddress ||\n        !useNftDetection !== disabled\n      ) {\n        this.configure({ selectedAddress, disabled: !useNftDetection });\n      }\n\n      if (useNftDetection !== undefined) {\n        if (useNftDetection) {\n          this.start();\n        } else {\n          this.stop();\n        }\n      }\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      this.configure({\n        networkType: providerConfig.type,\n        chainId: providerConfig.chainId as NftDetectionConfig['chainId'],\n      });\n    });\n    this.getOpenSeaApiKey = getOpenSeaApiKey;\n    this.addNft = addNft;\n  }\n\n  /**\n   * Start polling for the currency rate.\n   */\n  async start() {\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n\n    await this.startPolling();\n  }\n\n  /**\n   * Stop polling for the currency rate.\n   */\n  stop() {\n    this.stopPolling();\n  }\n\n  private stopPolling() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n\n  /**\n   * Starts a new polling interval.\n   *\n   * @param interval - An interval on which to poll.\n   */\n  private async startPolling(interval?: number): Promise<void> {\n    interval && this.configure({ interval }, false, false);\n    this.stopPolling();\n    await this.detectNfts();\n    this.intervalId = setInterval(async () => {\n      await this.detectNfts();\n    }, this.config.interval);\n  }\n\n  /**\n   * Checks whether network is mainnet or not.\n   *\n   * @returns Whether current network is mainnet.\n   */\n  isMainnet = (): boolean => this.config.networkType === 'mainnet';\n\n  /**\n   * Triggers asset ERC721 token auto detection on mainnet. Any newly detected NFTs are\n   * added.\n   */\n  async detectNfts() {\n    /* istanbul ignore if */\n    if (!this.isMainnet() || this.disabled) {\n      return;\n    }\n    const { selectedAddress, chainId } = this.config;\n\n    /* istanbul ignore else */\n    if (!selectedAddress) {\n      return;\n    }\n\n    const apiNfts = await this.getOwnerNfts(selectedAddress);\n    const addNftPromises = apiNfts.map(async (nft: ApiNft) => {\n      const {\n        token_id,\n        num_sales,\n        background_color,\n        image_url,\n        image_preview_url,\n        image_thumbnail_url,\n        image_original_url,\n        animation_url,\n        animation_original_url,\n        name,\n        description,\n        external_link,\n        creator,\n        asset_contract: { address, schema_name },\n        last_sale,\n      } = nft;\n\n      let ignored;\n      /* istanbul ignore else */\n      const { ignoredNfts } = this.getNftState();\n      if (ignoredNfts.length) {\n        ignored = ignoredNfts.find((c) => {\n          /* istanbul ignore next */\n          return (\n            c.address === toChecksumHexAddress(address) &&\n            c.tokenId === token_id\n          );\n        });\n      }\n\n      /* istanbul ignore else */\n      if (!ignored) {\n        /* istanbul ignore next */\n        const nftMetadata: NftMetadata = Object.assign(\n          {},\n          { name },\n          creator && { creator },\n          description && { description },\n          image_url && { image: image_url },\n          num_sales && { numberOfSales: num_sales },\n          background_color && { backgroundColor: background_color },\n          image_preview_url && { imagePreview: image_preview_url },\n          image_thumbnail_url && { imageThumbnail: image_thumbnail_url },\n          image_original_url && { imageOriginal: image_original_url },\n          animation_url && { animation: animation_url },\n          animation_original_url && {\n            animationOriginal: animation_original_url,\n          },\n          schema_name && { standard: schema_name },\n          external_link && { externalLink: external_link },\n          last_sale && { lastSale: last_sale },\n        );\n\n        await this.addNft(address, token_id, nftMetadata, {\n          userAddress: selectedAddress,\n          chainId: chainId as string,\n        });\n      }\n    });\n    await Promise.all(addNftPromises);\n  }\n}\n\nexport default NftDetectionController;\n"]}
\ No newline at end of file
diff --git a/dist/Standards/ERC20Standard.d.ts b/dist/Standards/ERC20Standard.d.ts
index b403761c378d708a05920eef65a71eaf14c69a67..0df38d9c2a50dd4ac320ffbb2ef19c861daf9d32 100644
--- a/dist/Standards/ERC20Standard.d.ts
+++ b/dist/Standards/ERC20Standard.d.ts
@@ -40,3 +40,4 @@ export declare class ERC20Standard {
         balance: BN | undefined;
     }>;
 }
+//# sourceMappingURL=ERC20Standard.d.ts.map
\ No newline at end of file
diff --git a/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts b/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
index 579987a2f5c3bec503f2cbd31d39567a6db8f744..255c4c9177b47be6b6fa518fde8777cb0b5b0226 100644
--- a/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
+++ b/dist/Standards/NftStandards/ERC1155/ERC1155Standard.d.ts
@@ -76,3 +76,4 @@ export declare class ERC1155Standard {
         image: string | undefined;
     }>;
 }
+//# sourceMappingURL=ERC1155Standard.d.ts.map
\ No newline at end of file
diff --git a/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts b/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
index 72c4c3d8463da9d4d5c8c5fca8fc27d859380ad5..28133f10b59ab2f65792465fc77481fda6ed040f 100644
--- a/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
+++ b/dist/Standards/NftStandards/ERC721/ERC721Standard.d.ts
@@ -86,3 +86,4 @@ export declare class ERC721Standard {
         image: string | undefined;
     }>;
 }
+//# sourceMappingURL=ERC721Standard.d.ts.map
\ No newline at end of file
diff --git a/dist/Standards/standards-types.d.ts b/dist/Standards/standards-types.d.ts
index 8efcd998d05b0abee8fc2711cc36e2fd9c662138..309ab00c100981821c07c0a4518dee84c25a9e26 100644
--- a/dist/Standards/standards-types.d.ts
+++ b/dist/Standards/standards-types.d.ts
@@ -12,3 +12,4 @@ export declare type Web3 = {
     };
 };
 export {};
+//# sourceMappingURL=standards-types.d.ts.map
\ No newline at end of file
diff --git a/dist/TokenBalancesController.d.ts b/dist/TokenBalancesController.d.ts
index 352136921642458f974f36cda11d5331549988fa..1563e609cb2d896eeea1fb31f02a37adcd776f1f 100644
--- a/dist/TokenBalancesController.d.ts
+++ b/dist/TokenBalancesController.d.ts
@@ -67,3 +67,4 @@ export declare class TokenBalancesController extends BaseController<TokenBalance
     updateBalances(): Promise<void>;
 }
 export default TokenBalancesController;
+//# sourceMappingURL=TokenBalancesController.d.ts.map
\ No newline at end of file
diff --git a/dist/TokenDetectionController.d.ts b/dist/TokenDetectionController.d.ts
index 01f039a5a06751b819362d1116d49441090a1678..4d32ec4301ef2611c7f7032bb9046dee8ac6be0a 100644
--- a/dist/TokenDetectionController.d.ts
+++ b/dist/TokenDetectionController.d.ts
@@ -82,3 +82,4 @@ export declare class TokenDetectionController extends BaseController<TokenDetect
     detectTokens(): Promise<void>;
 }
 export default TokenDetectionController;
+//# sourceMappingURL=TokenDetectionController.d.ts.map
\ No newline at end of file
diff --git a/dist/TokenListController.d.ts b/dist/TokenListController.d.ts
index a67d6f93d1ae74d92b002e44673acb6576a78c7c..86d75f7e3fb313418fada9f2bd384cc6196a7d63 100644
--- a/dist/TokenListController.d.ts
+++ b/dist/TokenListController.d.ts
@@ -112,3 +112,4 @@ export declare class TokenListController extends BaseControllerV2<typeof name, T
     updatePreventPollingOnNetworkRestart(shouldPreventPolling: boolean): void;
 }
 export default TokenListController;
+//# sourceMappingURL=TokenListController.d.ts.map
\ No newline at end of file
diff --git a/dist/TokenRatesController.d.ts b/dist/TokenRatesController.d.ts
index 25dfd49d8e1e0fede265ae05007e0cc54c874e4c..8bb7c206a1814b2e41c70ba52ce7841e7c59793c 100644
--- a/dist/TokenRatesController.d.ts
+++ b/dist/TokenRatesController.d.ts
@@ -165,3 +165,4 @@ export declare class TokenRatesController extends BaseController<TokenRatesConfi
     fetchAndMapExchangeRates(nativeCurrency: string, slug: string): Promise<ContractExchangeRates>;
 }
 export default TokenRatesController;
+//# sourceMappingURL=TokenRatesController.d.ts.map
\ No newline at end of file
diff --git a/dist/TokensController.d.ts b/dist/TokensController.d.ts
index 60fbbcf56bfadffcb2147ef25283c6239812686b..d613aa8942d35b0493f3c91a5d2bbb678688e632 100644
--- a/dist/TokensController.d.ts
+++ b/dist/TokensController.d.ts
@@ -1,7 +1,8 @@
 /// <reference types="node" />
 import { EventEmitter } from 'events';
+import { AcceptRequest as AcceptApprovalRequest, AddApprovalRequest, RejectRequest as RejectApprovalRequest } from '@metamask/approval-controller';
 import { Contract } from '@ethersproject/contracts';
-import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
+import { BaseController, BaseConfig, BaseState, RestrictedControllerMessenger } from '@metamask/base-controller';
 import type { PreferencesState } from '@metamask/preferences-controller';
 import type { NetworkState } from '@metamask/network-controller';
 import { NetworkType } from '@metamask/controller-utils';
@@ -39,6 +40,7 @@ export declare type SuggestedAssetMetaBase = {
     time: number;
     type: string;
     asset: Token;
+    interactingAddress?: string;
 };
 /**
  * @type SuggestedAssetMeta
@@ -50,6 +52,7 @@ export declare type SuggestedAssetMetaBase = {
  * @property time - Timestamp associated with this this suggested asset
  * @property type - Type type this suggested asset
  * @property asset - Asset suggested object
+ * @property interactingAddress - Account address that requested watch asset
  */
 export declare type SuggestedAssetMeta = (SuggestedAssetMetaBase & {
     status: SuggestedAssetStatus.failed;
@@ -90,6 +93,18 @@ export interface TokensState extends BaseState {
     };
     suggestedAssets: SuggestedAssetMeta[];
 }
+/**
+ * The name of the {@link TokensController}.
+ */
+declare const controllerName = "TokensController";
+/**
+ * The external actions available to the {@link TokensController}.
+ */
+declare type AllowedActions = AddApprovalRequest | AcceptApprovalRequest | RejectApprovalRequest;
+/**
+ * The messenger of the {@link TokensController}.
+ */
+export declare type TokensControllerMessenger = RestrictedControllerMessenger<typeof controllerName, AllowedActions, never, AllowedActions['type'], never>;
 /**
  * Controller that stores assets and exposes convenience methods
  */
@@ -97,6 +112,7 @@ export declare class TokensController extends BaseController<TokensConfig, Token
     private mutex;
     private ethersProvider;
     private abortController;
+    private messagingSystem;
     private failSuggestedAsset;
     /**
      * Fetch metadata for a token.
@@ -121,12 +137,14 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
+     * @param options.messenger - The controller messenger.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }: {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, }: {
         onPreferencesStateChange: (listener: (preferencesState: PreferencesState) => void) => void;
         onNetworkStateChange: (listener: (networkState: NetworkState) => void) => void;
         config?: Partial<TokensConfig>;
         state?: Partial<TokensState>;
+        messenger: TokensControllerMessenger;
     });
     _instantiateNewEthersProvider(): any;
     /**
@@ -136,9 +154,10 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      * @param symbol - Symbol of the token.
      * @param decimals - Number of decimals the token uses.
      * @param image - Image of the token.
+     * @param interactingAddress - The address of the account to add a token to.
      * @returns Current token list.
      */
-    addToken(address: string, symbol: string, decimals: number, image?: string): Promise<Token[]>;
+    addToken(address: string, symbol: string, decimals: number, image?: string, interactingAddress?: string): Promise<Token[]>;
     /**
      * Add a batch of tokens.
      *
@@ -187,9 +206,10 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      *
      * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.
      * @param type - The asset type.
+     * @param interactingAddress - The address of the account that is requesting to watch the asset.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchAsset(asset: Token, type: string): Promise<AssetSuggestionResult>;
+    watchAsset(asset: Token, type: string, interactingAddress?: string): Promise<AssetSuggestionResult>;
     /**
      * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
      * adding the asset to corresponding asset state. In this case ERC20 tokens.
@@ -213,16 +233,16 @@ export declare class TokensController extends BaseController<TokensConfig, Token
      * @param params.newTokens - The new tokens to set for the current network and selected account.
      * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
      * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
-     * @param params.detectionAddress - The address on which the detected tokens to add were detected.
-     * @param params.detectionChainId - The chainId on which the detected tokens to add were detected.
+     * @param params.interactingAddress - The account address to use to store the tokens.
+     * @param params.interactingChainId - The chainId to use to store the tokens.
      * @returns The updated `allTokens` and `allIgnoredTokens` state.
      */
     _getNewAllTokensState(params: {
         newTokens?: Token[];
         newIgnoredTokens?: string[];
         newDetectedTokens?: Token[];
-        detectionAddress?: string;
-        detectionChainId?: string;
+        interactingAddress?: string;
+        interactingChainId?: string;
     }): {
         newAllTokens: {
             [key: string]: {
@@ -246,3 +266,4 @@ export declare class TokensController extends BaseController<TokensConfig, Token
     clearIgnoredTokens(): void;
 }
 export default TokensController;
+//# sourceMappingURL=TokensController.d.ts.map
\ No newline at end of file
diff --git a/dist/TokensController.js b/dist/TokensController.js
index 8c02fe6e773f543ccddf8a800e20e306b20c4a80..93ade88f49cd8eaaabb831a238a95ea72623a1dd 100644
--- a/dist/TokensController.js
+++ b/dist/TokensController.js
@@ -32,6 +32,12 @@ var SuggestedAssetStatus;
     SuggestedAssetStatus["pending"] = "pending";
     SuggestedAssetStatus["rejected"] = "rejected";
 })(SuggestedAssetStatus || (SuggestedAssetStatus = {}));
+/**
+ * The name of the {@link TokensController}.
+ */
+const controllerName = 'TokensController';
+const ORIGIN_METAMASK = 'metamask';
+const WATCH_ASSET_METHOD_NAME = 'wallet_watchAssets';
 /**
  * Controller that stores assets and exposes convenience methods
  */
@@ -44,8 +50,9 @@ class TokensController extends base_controller_1.BaseController {
      * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
      * @param options.config - Initial options used to configure this controller.
      * @param options.state - Initial state to set on this controller.
+     * @param options.messenger - The controller messenger.
      */
-    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }) {
+    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, messenger, }) {
         super(config, state);
         this.mutex = new async_mutex_1.Mutex();
         /**
@@ -56,10 +63,11 @@ class TokensController extends base_controller_1.BaseController {
          * Name of this controller used during composition
          */
         this.name = 'TokensController';
-        this.defaultConfig = Object.assign({ networkType: controller_utils_1.MAINNET, selectedAddress: '', chainId: '', provider: undefined }, config);
+        this.defaultConfig = Object.assign({ networkType: 'mainnet', selectedAddress: '', chainId: '', provider: undefined }, config);
         this.defaultState = Object.assign({ tokens: [], ignoredTokens: [], detectedTokens: [], allTokens: {}, allIgnoredTokens: {}, allDetectedTokens: {}, suggestedAssets: [] }, state);
         this.initialize();
         this.abortController = new abort_controller_1.AbortController();
+        this.messagingSystem = messenger;
         onPreferencesStateChange(({ selectedAddress }) => {
             var _a, _b, _c;
             const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
@@ -123,15 +131,22 @@ class TokensController extends base_controller_1.BaseController {
      * @param symbol - Symbol of the token.
      * @param decimals - Number of decimals the token uses.
      * @param image - Image of the token.
+     * @param interactingAddress - The address of the account to add a token to.
      * @returns Current token list.
      */
-    addToken(address, symbol, decimals, image) {
+    addToken(address, symbol, decimals, image, interactingAddress) {
+        var _a, _b, _c;
         return __awaiter(this, void 0, void 0, function* () {
-            const currentChainId = this.config.chainId;
+            const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
+            const { chainId: currentChainId, selectedAddress } = this.config;
+            const accountAddress = interactingAddress || selectedAddress;
+            const isInteractingWithWalletAccount = accountAddress === selectedAddress;
             const releaseLock = yield this.mutex.acquire();
             try {
                 address = (0, controller_utils_1.toChecksumHexAddress)(address);
-                const { tokens, ignoredTokens, detectedTokens } = this.state;
+                const tokens = ((_a = allTokens[currentChainId]) === null || _a === void 0 ? void 0 : _a[accountAddress]) || [];
+                const ignoredTokens = ((_b = allIgnoredTokens[currentChainId]) === null || _b === void 0 ? void 0 : _b[accountAddress]) || [];
+                const detectedTokens = ((_c = allDetectedTokens[currentChainId]) === null || _c === void 0 ? void 0 : _c[accountAddress]) || [];
                 const newTokens = [...tokens];
                 const [isERC721, tokenMetadata] = yield Promise.all([
                     this._detectIsERC721(address),
@@ -166,15 +181,18 @@ class TokensController extends base_controller_1.BaseController {
                     newTokens,
                     newIgnoredTokens,
                     newDetectedTokens,
+                    interactingAddress: accountAddress,
                 });
-                this.update({
-                    tokens: newTokens,
-                    ignoredTokens: newIgnoredTokens,
-                    detectedTokens: newDetectedTokens,
+                let newState = {
                     allTokens: newAllTokens,
                     allIgnoredTokens: newAllIgnoredTokens,
                     allDetectedTokens: newAllDetectedTokens,
-                });
+                };
+                // Only update active tokens if user is interacting with their active wallet account.
+                if (isInteractingWithWalletAccount) {
+                    newState = Object.assign(Object.assign({}, newState), { tokens: newTokens, ignoredTokens: newIgnoredTokens, detectedTokens: newDetectedTokens });
+                }
+                this.update(newState);
                 return newTokens;
             }
             finally {
@@ -313,12 +331,12 @@ class TokensController extends base_controller_1.BaseController {
                         }
                     }
                 });
-                const { selectedAddress: detectionAddress, chainId: detectionChainId } = detectionDetails || {};
+                const { selectedAddress: interactingAddress, chainId: interactingChainId, } = detectionDetails || {};
                 const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState({
                     newTokens,
                     newDetectedTokens,
-                    detectionAddress,
-                    detectionChainId,
+                    interactingAddress,
+                    interactingChainId,
                 });
                 const { chainId, selectedAddress } = this.config;
                 // if the newly added detectedTokens were detected on (and therefore added to) a different chainId/selectedAddress than the currently configured combo
@@ -402,16 +420,19 @@ class TokensController extends base_controller_1.BaseController {
      *
      * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.
      * @param type - The asset type.
+     * @param interactingAddress - The address of the account that is requesting to watch the asset.
      * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
      */
-    watchAsset(asset, type) {
+    watchAsset(asset, type, interactingAddress) {
         return __awaiter(this, void 0, void 0, function* () {
+            const { selectedAddress } = this.config;
             const suggestedAssetMeta = {
                 asset,
                 id: this._generateRandomId(),
                 status: SuggestedAssetStatus.pending,
                 time: Date.now(),
                 type,
+                interactingAddress: interactingAddress || selectedAddress,
             };
             try {
                 switch (type) {
@@ -444,7 +465,15 @@ class TokensController extends base_controller_1.BaseController {
             const { suggestedAssets } = this.state;
             suggestedAssets.push(suggestedAssetMeta);
             this.update({ suggestedAssets: [...suggestedAssets] });
-            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
+            this.messagingSystem
+                .call('ApprovalController:addRequest', {
+                id: suggestedAssetMeta.id,
+                origin: ORIGIN_METAMASK,
+                type: WATCH_ASSET_METHOD_NAME,
+            }, true)
+                .catch(() => {
+                // Intentionally ignored as promise not currently used
+            });
             return { result, suggestedAssetMeta };
         });
     }
@@ -457,6 +486,7 @@ class TokensController extends base_controller_1.BaseController {
      */
     acceptWatchAsset(suggestedAssetID) {
         return __awaiter(this, void 0, void 0, function* () {
+            const { selectedAddress } = this.config;
             const { suggestedAssets } = this.state;
             const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
             const suggestedAssetMeta = suggestedAssets[index];
@@ -464,8 +494,14 @@ class TokensController extends base_controller_1.BaseController {
                 switch (suggestedAssetMeta.type) {
                     case 'ERC20':
                         const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
-                        yield this.addToken(address, symbol, decimals, image);
+                        yield this.addToken(address, symbol, decimals, image, (suggestedAssetMeta === null || suggestedAssetMeta === void 0 ? void 0 : suggestedAssetMeta.interactingAddress) || selectedAddress);
                         suggestedAssetMeta.status = SuggestedAssetStatus.accepted;
+                        try {
+                            this.messagingSystem.call('ApprovalController:acceptRequest', suggestedAssetMeta.id);
+                        }
+                        catch (error) {
+                            console.error('Failed to accept token watch approval request', error);
+                        }
                         this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
                         break;
                     default:
@@ -474,6 +510,12 @@ class TokensController extends base_controller_1.BaseController {
             }
             catch (error) {
                 this.failSuggestedAsset(suggestedAssetMeta, error);
+                try {
+                    this.messagingSystem.call('ApprovalController:rejectRequest', suggestedAssetMeta.id, new Error('Rejected'));
+                }
+                catch (messageCallError) {
+                    console.error('Failed to reject transaction approval request', messageCallError);
+                }
             }
             const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
             this.update({ suggestedAssets: [...newSuggestedAssets] });
@@ -496,6 +538,12 @@ class TokensController extends base_controller_1.BaseController {
         this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
         const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
         this.update({ suggestedAssets: [...newSuggestedAssets] });
+        try {
+            this.messagingSystem.call('ApprovalController:rejectRequest', suggestedAssetMeta.id, new Error('Rejected'));
+        }
+        catch (error) {
+            console.error('Failed to reject transaction approval request', error);
+        }
     }
     /**
      * Takes a new tokens and ignoredTokens array for the current network/account combination
@@ -505,16 +553,16 @@ class TokensController extends base_controller_1.BaseController {
      * @param params.newTokens - The new tokens to set for the current network and selected account.
      * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
      * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
-     * @param params.detectionAddress - The address on which the detected tokens to add were detected.
-     * @param params.detectionChainId - The chainId on which the detected tokens to add were detected.
+     * @param params.interactingAddress - The account address to use to store the tokens.
+     * @param params.interactingChainId - The chainId to use to store the tokens.
      * @returns The updated `allTokens` and `allIgnoredTokens` state.
      */
     _getNewAllTokensState(params) {
-        const { newTokens, newIgnoredTokens, newDetectedTokens, detectionAddress, detectionChainId, } = params;
+        const { newTokens, newIgnoredTokens, newDetectedTokens, interactingAddress, interactingChainId, } = params;
         const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
         const { chainId, selectedAddress } = this.config;
-        const userAddressToAddTokens = detectionAddress !== null && detectionAddress !== void 0 ? detectionAddress : selectedAddress;
-        const chainIdToAddTokens = detectionChainId !== null && detectionChainId !== void 0 ? detectionChainId : chainId;
+        const userAddressToAddTokens = interactingAddress !== null && interactingAddress !== void 0 ? interactingAddress : selectedAddress;
+        const chainIdToAddTokens = interactingChainId !== null && interactingChainId !== void 0 ? interactingChainId : chainId;
         let newAllTokens = allTokens;
         if ((newTokens === null || newTokens === void 0 ? void 0 : newTokens.length) ||
             (newTokens &&
diff --git a/dist/TokensController.js.map b/dist/TokensController.js.map
index c60295e1e65160b4daf5f77ed96df991ee8afc11..824ce61bad4aae73b7dfbafd62df0e6446fd9a81 100644
--- a/dist/TokensController.js.map
+++ b/dist/TokensController.js.map
@@ -1 +1 @@
-{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport contractsMap from '@metamask/contract-metadata';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport { v1 as random } from 'uuid';\nimport { Mutex } from 'async-mutex';\nimport { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  NetworkType,\n  toChecksumHexAddress,\n  MAINNET,\n  ERC721_INTERFACE_ID,\n} from '@metamask/controller-utils';\nimport type { Token } from './TokenRatesController';\nimport { TokenListToken } from './TokenListController';\nimport {\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n  validateTokenToWatch,\n} from './assetsUtil';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  provider: any;\n}\n\n/**\n * @type AssetSuggestionResult\n * @property result - Promise resolving to a new suggested asset address\n * @property suggestedAssetMeta - Meta information about this new suggested asset\n */\ninterface AssetSuggestionResult {\n  result: Promise<string>;\n  suggestedAssetMeta: SuggestedAssetMeta;\n}\n\nenum SuggestedAssetStatus {\n  accepted = 'accepted',\n  failed = 'failed',\n  pending = 'pending',\n  rejected = 'rejected',\n}\n\nexport type SuggestedAssetMetaBase = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n};\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property error - Synthesized error information for failed asset suggestions\n * @property id - Generated UUID associated with this suggested asset\n * @property status - String status of this this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n */\nexport type SuggestedAssetMeta =\n  | (SuggestedAssetMetaBase & {\n      status: SuggestedAssetStatus.failed;\n      error: Error;\n    })\n  | (SuggestedAssetMetaBase & {\n      status:\n        | SuggestedAssetStatus.accepted\n        | SuggestedAssetStatus.rejected\n        | SuggestedAssetStatus.pending;\n    });\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n * @property suggestedAssets - List of pending suggested assets to be added or canceled\n */\nexport interface TokensState extends BaseState {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [key: string]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [key: string]: { [key: string]: string[] } };\n  allDetectedTokens: { [key: string]: { [key: string]: Token[] } };\n  suggestedAssets: SuggestedAssetMeta[];\n}\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private mutex = new Mutex();\n\n  private ethersProvider: any;\n\n  private abortController: WhatwgAbortController;\n\n  private failSuggestedAsset(\n    suggestedAssetMeta: SuggestedAssetMeta,\n    error: unknown,\n  ) {\n    const failedSuggestedAssetMeta = {\n      ...suggestedAssetMeta,\n      status: SuggestedAssetStatus.failed,\n      error,\n    };\n    this.hub.emit(\n      `${suggestedAssetMeta.id}:finished`,\n      failedSuggestedAssetMeta,\n    );\n  }\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   */\n  constructor({\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    config,\n    state,\n  }: {\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      networkType: MAINNET,\n      selectedAddress: '',\n      chainId: '',\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      tokens: [],\n      ignoredTokens: [],\n      detectedTokens: [],\n      allTokens: {},\n      allIgnoredTokens: {},\n      allDetectedTokens: {},\n      suggestedAssets: [],\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new WhatwgAbortController();\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = providerConfig;\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.configure({ chainId });\n      this.ethersProvider = this._instantiateNewEthersProvider();\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n  }\n\n  _instantiateNewEthersProvider(): any {\n    return new Web3Provider(this.config?.provider);\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param address - Hex address of the token contract.\n   * @param symbol - Symbol of the token.\n   * @param decimals - Number of decimals the token uses.\n   * @param image - Image of the token.\n   * @returns Current token list.\n   */\n  async addToken(\n    address: string,\n    symbol: string,\n    decimals: number,\n    image?: string,\n  ): Promise<Token[]> {\n    const currentChainId = this.config.chainId;\n    const releaseLock = await this.mutex.acquire();\n    try {\n      address = toChecksumHexAddress(address);\n      const { tokens, ignoredTokens, detectedTokens } = this.state;\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address),\n        this.fetchTokenMetadata(address),\n      ]);\n      if (currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: this.config.chainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n      };\n      const previousEntry = newTokens.find(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousEntry) {\n        const previousIndex = newTokens.indexOf(previousEntry);\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n        });\n\n      this.update({\n        tokens: newTokens,\n        ignoredTokens: newIgnoredTokens,\n        detectedTokens: newDetectedTokens,\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   */\n  async addTokens(tokensToImport: Token[]) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: string },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const newTokens: Token[] = [...tokens];\n    let newDetectedTokens: Token[] = [...detectedTokens];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, isERC721 } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n        };\n        const previousImportedEntry = newTokens.find(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedEntry) {\n          // Update existing data of imported token\n          const previousImportedIndex = newTokens.indexOf(\n            previousImportedEntry,\n          );\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex = ignoredTokens.indexOf(address);\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedEntry = newDetectedTokens.find(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedEntry) {\n              const previousDetectedIndex = newDetectedTokens.indexOf(\n                previousDetectedEntry,\n              );\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const { selectedAddress: detectionAddress, chainId: detectionChainId } =\n        detectionDetails || {};\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          detectionAddress,\n          detectionChainId,\n        },\n      );\n\n      const { chainId, selectedAddress } = this.config;\n      // if the newly added detectedTokens were detected on (and therefore added to) a different chainId/selectedAddress than the currently configured combo\n      // the newDetectedTokens (which should contain the detectedTokens on the current chainId/address combo) needs to be repointed to the current chainId/address pair\n      // if the detectedTokens were detected on the current chainId/address then this won't change anything.\n      newDetectedTokens =\n        newAllDetectedTokens?.[chainId]?.[selectedAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(tokenAddress: string) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      this.ethersProvider,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    ethersProvider: any,\n  ): Contract {\n    const tokenContract = new Contract(tokenAddress, abi, ethersProvider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param type - The asset type.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset(asset: Token, type: string): Promise<AssetSuggestionResult> {\n    const suggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      status: SuggestedAssetStatus.pending as SuggestedAssetStatus.pending,\n      time: Date.now(),\n      type,\n    };\n    try {\n      switch (type) {\n        case 'ERC20':\n          validateTokenToWatch(asset);\n          break;\n        default:\n          throw new Error(`Asset of type ${type} not supported`);\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n      return Promise.reject(error);\n    }\n\n    const result: Promise<string> = new Promise((resolve, reject) => {\n      this.hub.once(\n        `${suggestedAssetMeta.id}:finished`,\n        (meta: SuggestedAssetMeta) => {\n          switch (meta.status) {\n            case SuggestedAssetStatus.accepted:\n              return resolve(meta.asset.address);\n            case SuggestedAssetStatus.rejected:\n              return reject(new Error('User rejected to watch the asset.'));\n            case SuggestedAssetStatus.failed:\n              return reject(new Error(meta.error.message));\n            /* istanbul ignore next */\n            default:\n              return reject(new Error(`Unknown status: ${meta.status}`));\n          }\n        },\n      );\n    });\n\n    const { suggestedAssets } = this.state;\n    suggestedAssets.push(suggestedAssetMeta);\n    this.update({ suggestedAssets: [...suggestedAssets] });\n    this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);\n    return { result, suggestedAssetMeta };\n  }\n\n  /**\n   * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,\n   * adding the asset to corresponding asset state. In this case ERC20 tokens.\n   * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.\n   *\n   * @param suggestedAssetID - The ID of the suggestedAsset to accept.\n   */\n  async acceptWatchAsset(suggestedAssetID: string): Promise<void> {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(\n      ({ id }) => suggestedAssetID === id,\n    );\n    const suggestedAssetMeta = suggestedAssets[index];\n    try {\n      switch (suggestedAssetMeta.type) {\n        case 'ERC20':\n          const { address, symbol, decimals, image } = suggestedAssetMeta.asset;\n          await this.addToken(address, symbol, decimals, image);\n          suggestedAssetMeta.status = SuggestedAssetStatus.accepted;\n          this.hub.emit(\n            `${suggestedAssetMeta.id}:finished`,\n            suggestedAssetMeta,\n          );\n          break;\n        default:\n          throw new Error(\n            `Asset of type ${suggestedAssetMeta.type} not supported`,\n          );\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n    }\n    const newSuggestedAssets = suggestedAssets.filter(\n      ({ id }) => id !== suggestedAssetID,\n    );\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Rejects a watchAsset request based on its ID by setting its status to \"rejected\"\n   * and emitting a `<suggestedAssetMeta.id>:finished` hub event.\n   *\n   * @param suggestedAssetID - The ID of the suggestedAsset to accept.\n   */\n  rejectWatchAsset(suggestedAssetID: string) {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(\n      ({ id }) => suggestedAssetID === id,\n    );\n    const suggestedAssetMeta = suggestedAssets[index];\n    if (!suggestedAssetMeta) {\n      return;\n    }\n    suggestedAssetMeta.status = SuggestedAssetStatus.rejected;\n    this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n    const newSuggestedAssets = suggestedAssets.filter(\n      ({ id }) => id !== suggestedAssetID,\n    );\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.detectionAddress - The address on which the detected tokens to add were detected.\n   * @param params.detectionChainId - The chainId on which the detected tokens to add were detected.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    detectionAddress?: string;\n    detectionChainId?: string;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      detectionAddress,\n      detectionChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = detectionAddress ?? selectedAddress;\n    const chainIdToAddTokens = detectionChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
+{"version":3,"file":"TokensController.js","sourceRoot":"","sources":["../src/TokensController.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport {\n  AcceptRequest as AcceptApprovalRequest,\n  AddApprovalRequest,\n  RejectRequest as RejectApprovalRequest,\n} from '@metamask/approval-controller';\nimport contractsMap from '@metamask/contract-metadata';\nimport { abiERC721 } from '@metamask/metamask-eth-abis';\nimport { v1 as random } from 'uuid';\nimport { Mutex } from 'async-mutex';\nimport { Contract } from '@ethersproject/contracts';\nimport { Web3Provider } from '@ethersproject/providers';\nimport { AbortController as WhatwgAbortController } from 'abort-controller';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n  RestrictedControllerMessenger,\n} from '@metamask/base-controller';\nimport type { PreferencesState } from '@metamask/preferences-controller';\nimport type { NetworkState } from '@metamask/network-controller';\nimport {\n  NetworkType,\n  toChecksumHexAddress,\n  ERC721_INTERFACE_ID,\n} from '@metamask/controller-utils';\nimport type { Token } from './TokenRatesController';\nimport { TokenListToken } from './TokenListController';\nimport {\n  formatAggregatorNames,\n  formatIconUrlWithProxy,\n  validateTokenToWatch,\n} from './assetsUtil';\nimport {\n  fetchTokenMetadata,\n  TOKEN_METADATA_NO_SUPPORT_ERROR,\n} from './token-service';\n\n/**\n * @type TokensConfig\n *\n * Tokens controller configuration\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface TokensConfig extends BaseConfig {\n  networkType: NetworkType;\n  selectedAddress: string;\n  chainId: string;\n  provider: any;\n}\n\n/**\n * @type AssetSuggestionResult\n * @property result - Promise resolving to a new suggested asset address\n * @property suggestedAssetMeta - Meta information about this new suggested asset\n */\ninterface AssetSuggestionResult {\n  result: Promise<string>;\n  suggestedAssetMeta: SuggestedAssetMeta;\n}\n\nenum SuggestedAssetStatus {\n  accepted = 'accepted',\n  failed = 'failed',\n  pending = 'pending',\n  rejected = 'rejected',\n}\n\nexport type SuggestedAssetMetaBase = {\n  id: string;\n  time: number;\n  type: string;\n  asset: Token;\n  interactingAddress?: string;\n};\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n * @property error - Synthesized error information for failed asset suggestions\n * @property id - Generated UUID associated with this suggested asset\n * @property status - String status of this this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n * @property interactingAddress - Account address that requested watch asset\n */\nexport type SuggestedAssetMeta =\n  | (SuggestedAssetMetaBase & {\n      status: SuggestedAssetStatus.failed;\n      error: Error;\n    })\n  | (SuggestedAssetMetaBase & {\n      status:\n        | SuggestedAssetStatus.accepted\n        | SuggestedAssetStatus.rejected\n        | SuggestedAssetStatus.pending;\n    });\n\n/**\n * @type TokensState\n *\n * Assets controller state\n * @property tokens - List of tokens associated with the active network and address pair\n * @property ignoredTokens - List of ignoredTokens associated with the active network and address pair\n * @property detectedTokens - List of detected tokens associated with the active network and address pair\n * @property allTokens - Object containing tokens by network and account\n * @property allIgnoredTokens - Object containing hidden/ignored tokens by network and account\n * @property allDetectedTokens - Object containing tokens detected with non-zero balances\n * @property suggestedAssets - List of pending suggested assets to be added or canceled\n */\nexport interface TokensState extends BaseState {\n  tokens: Token[];\n  ignoredTokens: string[];\n  detectedTokens: Token[];\n  allTokens: { [key: string]: { [key: string]: Token[] } };\n  allIgnoredTokens: { [key: string]: { [key: string]: string[] } };\n  allDetectedTokens: { [key: string]: { [key: string]: Token[] } };\n  suggestedAssets: SuggestedAssetMeta[];\n}\n\n/**\n * The name of the {@link TokensController}.\n */\nconst controllerName = 'TokensController';\n\n/**\n * The external actions available to the {@link TokensController}.\n */\ntype AllowedActions =\n  | AddApprovalRequest\n  | AcceptApprovalRequest\n  | RejectApprovalRequest;\n\n/**\n * The messenger of the {@link TokensController}.\n */\nexport type TokensControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  AllowedActions,\n  never,\n  AllowedActions['type'],\n  never\n>;\n\nconst ORIGIN_METAMASK = 'metamask';\nconst WATCH_ASSET_METHOD_NAME = 'wallet_watchAssets';\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class TokensController extends BaseController<\n  TokensConfig,\n  TokensState\n> {\n  private mutex = new Mutex();\n\n  private ethersProvider: any;\n\n  private abortController: WhatwgAbortController;\n\n  private messagingSystem: TokensControllerMessenger;\n\n  private failSuggestedAsset(\n    suggestedAssetMeta: SuggestedAssetMeta,\n    error: unknown,\n  ) {\n    const failedSuggestedAssetMeta = {\n      ...suggestedAssetMeta,\n      status: SuggestedAssetStatus.failed,\n      error,\n    };\n    this.hub.emit(\n      `${suggestedAssetMeta.id}:finished`,\n      failedSuggestedAssetMeta,\n    );\n  }\n\n  /**\n   * Fetch metadata for a token.\n   *\n   * @param tokenAddress - The address of the token.\n   * @returns The token metadata.\n   */\n  private async fetchTokenMetadata(\n    tokenAddress: string,\n  ): Promise<TokenListToken | undefined> {\n    try {\n      const token = await fetchTokenMetadata<TokenListToken>(\n        this.config.chainId,\n        tokenAddress,\n        this.abortController.signal,\n      );\n      return token;\n    } catch (error) {\n      if (\n        error instanceof Error &&\n        error.message.includes(TOKEN_METADATA_NO_SUPPORT_ERROR)\n      ) {\n        return undefined;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific EIP747 events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TokensController';\n\n  /**\n   * Creates a TokensController instance.\n   *\n   * @param options - The controller options.\n   * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.\n   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.\n   * @param options.config - Initial options used to configure this controller.\n   * @param options.state - Initial state to set on this controller.\n   * @param options.messenger - The controller messenger.\n   */\n  constructor({\n    onPreferencesStateChange,\n    onNetworkStateChange,\n    config,\n    state,\n    messenger,\n  }: {\n    onPreferencesStateChange: (\n      listener: (preferencesState: PreferencesState) => void,\n    ) => void;\n    onNetworkStateChange: (\n      listener: (networkState: NetworkState) => void,\n    ) => void;\n    config?: Partial<TokensConfig>;\n    state?: Partial<TokensState>;\n    messenger: TokensControllerMessenger;\n  }) {\n    super(config, state);\n\n    this.defaultConfig = {\n      networkType: 'mainnet' as NetworkType,\n      selectedAddress: '',\n      chainId: '',\n      provider: undefined,\n      ...config,\n    };\n\n    this.defaultState = {\n      tokens: [],\n      ignoredTokens: [],\n      detectedTokens: [],\n      allTokens: {},\n      allIgnoredTokens: {},\n      allDetectedTokens: {},\n      suggestedAssets: [],\n      ...state,\n    };\n\n    this.initialize();\n    this.abortController = new WhatwgAbortController();\n\n    this.messagingSystem = messenger;\n\n    onPreferencesStateChange(({ selectedAddress }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { chainId } = this.config;\n      this.configure({ selectedAddress });\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n\n    onNetworkStateChange(({ providerConfig }) => {\n      const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n      const { selectedAddress } = this.config;\n      const { chainId } = providerConfig;\n      this.abortController.abort();\n      this.abortController = new WhatwgAbortController();\n      this.configure({ chainId });\n      this.ethersProvider = this._instantiateNewEthersProvider();\n      this.update({\n        tokens: allTokens[chainId]?.[selectedAddress] || [],\n        ignoredTokens: allIgnoredTokens[chainId]?.[selectedAddress] || [],\n        detectedTokens: allDetectedTokens[chainId]?.[selectedAddress] || [],\n      });\n    });\n  }\n\n  _instantiateNewEthersProvider(): any {\n    return new Web3Provider(this.config?.provider);\n  }\n\n  /**\n   * Adds a token to the stored token list.\n   *\n   * @param address - Hex address of the token contract.\n   * @param symbol - Symbol of the token.\n   * @param decimals - Number of decimals the token uses.\n   * @param image - Image of the token.\n   * @param interactingAddress - The address of the account to add a token to.\n   * @returns Current token list.\n   */\n  async addToken(\n    address: string,\n    symbol: string,\n    decimals: number,\n    image?: string,\n    interactingAddress?: string,\n  ): Promise<Token[]> {\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId: currentChainId, selectedAddress } = this.config;\n    const accountAddress = interactingAddress || selectedAddress;\n    const isInteractingWithWalletAccount = accountAddress === selectedAddress;\n    const releaseLock = await this.mutex.acquire();\n\n    try {\n      address = toChecksumHexAddress(address);\n      const tokens = allTokens[currentChainId]?.[accountAddress] || [];\n      const ignoredTokens =\n        allIgnoredTokens[currentChainId]?.[accountAddress] || [];\n      const detectedTokens =\n        allDetectedTokens[currentChainId]?.[accountAddress] || [];\n      const newTokens: Token[] = [...tokens];\n      const [isERC721, tokenMetadata] = await Promise.all([\n        this._detectIsERC721(address),\n        this.fetchTokenMetadata(address),\n      ]);\n      if (currentChainId !== this.config.chainId) {\n        throw new Error(\n          'TokensController Error: Switched networks while adding token',\n        );\n      }\n      const newEntry: Token = {\n        address,\n        symbol,\n        decimals,\n        image:\n          image ||\n          formatIconUrlWithProxy({\n            chainId: this.config.chainId,\n            tokenAddress: address,\n          }),\n        isERC721,\n        aggregators: formatAggregatorNames(tokenMetadata?.aggregators || []),\n      };\n      const previousEntry = newTokens.find(\n        (token) => token.address.toLowerCase() === address.toLowerCase(),\n      );\n      if (previousEntry) {\n        const previousIndex = newTokens.indexOf(previousEntry);\n        newTokens[previousIndex] = newEntry;\n      } else {\n        newTokens.push(newEntry);\n      }\n\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase(),\n      );\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => token.address.toLowerCase() !== address.toLowerCase(),\n      );\n\n      const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newIgnoredTokens,\n          newDetectedTokens,\n          interactingAddress: accountAddress,\n        });\n\n      let newState: Partial<TokensState> = {\n        allTokens: newAllTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      };\n\n      // Only update active tokens if user is interacting with their active wallet account.\n      if (isInteractingWithWalletAccount) {\n        newState = {\n          ...newState,\n          tokens: newTokens,\n          ignoredTokens: newIgnoredTokens,\n          detectedTokens: newDetectedTokens,\n        };\n      }\n\n      this.update(newState);\n      return newTokens;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Add a batch of tokens.\n   *\n   * @param tokensToImport - Array of tokens to import.\n   */\n  async addTokens(tokensToImport: Token[]) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const importedTokensMap: { [key: string]: true } = {};\n    // Used later to dedupe imported tokens\n    const newTokensMap = tokens.reduce((output, current) => {\n      output[current.address] = current;\n      return output;\n    }, {} as { [address: string]: Token });\n\n    try {\n      tokensToImport.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators } = tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const formattedToken: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          aggregators,\n        };\n        newTokensMap[address] = formattedToken;\n        importedTokensMap[address.toLowerCase()] = true;\n        return formattedToken;\n      });\n      const newTokens = Object.values(newTokensMap);\n\n      const newDetectedTokens = detectedTokens.filter(\n        (token) => !importedTokensMap[token.address.toLowerCase()],\n      );\n      const newIgnoredTokens = ignoredTokens.filter(\n        (tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()],\n      );\n\n      const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } =\n        this._getNewAllTokensState({\n          newTokens,\n          newDetectedTokens,\n          newIgnoredTokens,\n        });\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n        ignoredTokens: newIgnoredTokens,\n        allIgnoredTokens: newAllIgnoredTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Ignore a batch of tokens.\n   *\n   * @param tokenAddressesToIgnore - Array of token addresses to ignore.\n   */\n  ignoreTokens(tokenAddressesToIgnore: string[]) {\n    const { ignoredTokens, detectedTokens, tokens } = this.state;\n    const ignoredTokensMap: { [key: string]: true } = {};\n    let newIgnoredTokens: string[] = [...ignoredTokens];\n\n    const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {\n      const checksumAddress = toChecksumHexAddress(address);\n      ignoredTokensMap[address.toLowerCase()] = true;\n      return checksumAddress;\n    });\n    newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];\n    const newDetectedTokens = detectedTokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n    const newTokens = tokens.filter(\n      (token) => !ignoredTokensMap[token.address.toLowerCase()],\n    );\n\n    const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } =\n      this._getNewAllTokensState({\n        newIgnoredTokens,\n        newDetectedTokens,\n        newTokens,\n      });\n\n    this.update({\n      ignoredTokens: newIgnoredTokens,\n      tokens: newTokens,\n      detectedTokens: newDetectedTokens,\n      allIgnoredTokens: newAllIgnoredTokens,\n      allDetectedTokens: newAllDetectedTokens,\n      allTokens: newAllTokens,\n    });\n  }\n\n  /**\n   * Adds a batch of detected tokens to the stored token list.\n   *\n   * @param incomingDetectedTokens - Array of detected tokens to be added or updated.\n   * @param detectionDetails - An object containing the chain ID and address of the currently selected network on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.selectedAddress - the account address on which the incomingDetectedTokens were detected.\n   * @param detectionDetails.chainId - the chainId on which the incomingDetectedTokens were detected.\n   */\n  async addDetectedTokens(\n    incomingDetectedTokens: Token[],\n    detectionDetails?: { selectedAddress: string; chainId: string },\n  ) {\n    const releaseLock = await this.mutex.acquire();\n    const { tokens, detectedTokens, ignoredTokens } = this.state;\n    const newTokens: Token[] = [...tokens];\n    let newDetectedTokens: Token[] = [...detectedTokens];\n\n    try {\n      incomingDetectedTokens.forEach((tokenToAdd) => {\n        const { address, symbol, decimals, image, aggregators, isERC721 } =\n          tokenToAdd;\n        const checksumAddress = toChecksumHexAddress(address);\n        const newEntry: Token = {\n          address: checksumAddress,\n          symbol,\n          decimals,\n          image,\n          isERC721,\n          aggregators,\n        };\n        const previousImportedEntry = newTokens.find(\n          (token) =>\n            token.address.toLowerCase() === checksumAddress.toLowerCase(),\n        );\n        if (previousImportedEntry) {\n          // Update existing data of imported token\n          const previousImportedIndex = newTokens.indexOf(\n            previousImportedEntry,\n          );\n          newTokens[previousImportedIndex] = newEntry;\n        } else {\n          const ignoredTokenIndex = ignoredTokens.indexOf(address);\n          if (ignoredTokenIndex === -1) {\n            // Add detected token\n            const previousDetectedEntry = newDetectedTokens.find(\n              (token) =>\n                token.address.toLowerCase() === checksumAddress.toLowerCase(),\n            );\n            if (previousDetectedEntry) {\n              const previousDetectedIndex = newDetectedTokens.indexOf(\n                previousDetectedEntry,\n              );\n              newDetectedTokens[previousDetectedIndex] = newEntry;\n            } else {\n              newDetectedTokens.push(newEntry);\n            }\n          }\n        }\n      });\n\n      const {\n        selectedAddress: interactingAddress,\n        chainId: interactingChainId,\n      } = detectionDetails || {};\n\n      const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState(\n        {\n          newTokens,\n          newDetectedTokens,\n          interactingAddress,\n          interactingChainId,\n        },\n      );\n\n      const { chainId, selectedAddress } = this.config;\n      // if the newly added detectedTokens were detected on (and therefore added to) a different chainId/selectedAddress than the currently configured combo\n      // the newDetectedTokens (which should contain the detectedTokens on the current chainId/address combo) needs to be repointed to the current chainId/address pair\n      // if the detectedTokens were detected on the current chainId/address then this won't change anything.\n      newDetectedTokens =\n        newAllDetectedTokens?.[chainId]?.[selectedAddress] || [];\n\n      this.update({\n        tokens: newTokens,\n        allTokens: newAllTokens,\n        detectedTokens: newDetectedTokens,\n        allDetectedTokens: newAllDetectedTokens,\n      });\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Adds isERC721 field to token object. This is called when a user attempts to add tokens that\n   * were previously added which do not yet had isERC721 field.\n   *\n   * @param tokenAddress - The contract address of the token requiring the isERC721 field added.\n   * @returns The new token object with the added isERC721 field.\n   */\n  async updateTokenType(tokenAddress: string) {\n    const isERC721 = await this._detectIsERC721(tokenAddress);\n    const { tokens } = this.state;\n    const tokenIndex = tokens.findIndex((token) => {\n      return token.address.toLowerCase() === tokenAddress.toLowerCase();\n    });\n    tokens[tokenIndex].isERC721 = isERC721;\n    this.update({ tokens });\n    return tokens[tokenIndex];\n  }\n\n  /**\n   * Detects whether or not a token is ERC-721 compatible.\n   *\n   * @param tokenAddress - The token contract address.\n   * @returns A boolean indicating whether the token address passed in supports the EIP-721\n   * interface.\n   */\n  async _detectIsERC721(tokenAddress: string) {\n    const checksumAddress = toChecksumHexAddress(tokenAddress);\n    // if this token is already in our contract metadata map we don't need\n    // to check against the contract\n    if (contractsMap[checksumAddress]?.erc721 === true) {\n      return Promise.resolve(true);\n    } else if (contractsMap[checksumAddress]?.erc20 === true) {\n      return Promise.resolve(false);\n    }\n\n    const tokenContract = this._createEthersContract(\n      tokenAddress,\n      abiERC721,\n      this.ethersProvider,\n    );\n    try {\n      return await tokenContract.supportsInterface(ERC721_INTERFACE_ID);\n    } catch (error: any) {\n      // currently we see a variety of errors across different networks when\n      // token contracts are not ERC721 compatible. We need to figure out a better\n      // way of differentiating token interface types but for now if we get an error\n      // we have to assume the token is not ERC721 compatible.\n      return false;\n    }\n  }\n\n  _createEthersContract(\n    tokenAddress: string,\n    abi: string,\n    ethersProvider: any,\n  ): Contract {\n    const tokenContract = new Contract(tokenAddress, abi, ethersProvider);\n    return tokenContract;\n  }\n\n  _generateRandomId(): string {\n    return random();\n  }\n\n  /**\n   * Adds a new suggestedAsset to state. Parameters will be validated according to\n   * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.\n   *\n   * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.\n   * @param type - The asset type.\n   * @param interactingAddress - The address of the account that is requesting to watch the asset.\n   * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.\n   */\n  async watchAsset(\n    asset: Token,\n    type: string,\n    interactingAddress?: string,\n  ): Promise<AssetSuggestionResult> {\n    const { selectedAddress } = this.config;\n\n    const suggestedAssetMeta: SuggestedAssetMeta = {\n      asset,\n      id: this._generateRandomId(),\n      status: SuggestedAssetStatus.pending as SuggestedAssetStatus.pending,\n      time: Date.now(),\n      type,\n      interactingAddress: interactingAddress || selectedAddress,\n    };\n\n    try {\n      switch (type) {\n        case 'ERC20':\n          validateTokenToWatch(asset);\n          break;\n        default:\n          throw new Error(`Asset of type ${type} not supported`);\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n      return Promise.reject(error);\n    }\n\n    const result: Promise<string> = new Promise((resolve, reject) => {\n      this.hub.once(\n        `${suggestedAssetMeta.id}:finished`,\n        (meta: SuggestedAssetMeta) => {\n          switch (meta.status) {\n            case SuggestedAssetStatus.accepted:\n              return resolve(meta.asset.address);\n            case SuggestedAssetStatus.rejected:\n              return reject(new Error('User rejected to watch the asset.'));\n            case SuggestedAssetStatus.failed:\n              return reject(new Error(meta.error.message));\n            /* istanbul ignore next */\n            default:\n              return reject(new Error(`Unknown status: ${meta.status}`));\n          }\n        },\n      );\n    });\n\n    const { suggestedAssets } = this.state;\n    suggestedAssets.push(suggestedAssetMeta);\n    this.update({ suggestedAssets: [...suggestedAssets] });\n\n    this.messagingSystem\n      .call(\n        'ApprovalController:addRequest',\n        {\n          id: suggestedAssetMeta.id,\n          origin: ORIGIN_METAMASK,\n          type: WATCH_ASSET_METHOD_NAME,\n        },\n        true,\n      )\n      .catch(() => {\n        // Intentionally ignored as promise not currently used\n      });\n\n    return { result, suggestedAssetMeta };\n  }\n\n  /**\n   * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,\n   * adding the asset to corresponding asset state. In this case ERC20 tokens.\n   * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.\n   *\n   * @param suggestedAssetID - The ID of the suggestedAsset to accept.\n   */\n  async acceptWatchAsset(suggestedAssetID: string): Promise<void> {\n    const { selectedAddress } = this.config;\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(\n      ({ id }) => suggestedAssetID === id,\n    );\n    const suggestedAssetMeta = suggestedAssets[index];\n    try {\n      switch (suggestedAssetMeta.type) {\n        case 'ERC20':\n          const { address, symbol, decimals, image } = suggestedAssetMeta.asset;\n          await this.addToken(\n            address,\n            symbol,\n            decimals,\n            image,\n            suggestedAssetMeta?.interactingAddress || selectedAddress,\n          );\n          suggestedAssetMeta.status = SuggestedAssetStatus.accepted;\n\n          try {\n            this.messagingSystem.call(\n              'ApprovalController:acceptRequest',\n              suggestedAssetMeta.id,\n            );\n          } catch (error) {\n            console.error(\n              'Failed to accept token watch approval request',\n              error,\n            );\n          }\n\n          this.hub.emit(\n            `${suggestedAssetMeta.id}:finished`,\n            suggestedAssetMeta,\n          );\n          break;\n        default:\n          throw new Error(\n            `Asset of type ${suggestedAssetMeta.type} not supported`,\n          );\n      }\n    } catch (error) {\n      this.failSuggestedAsset(suggestedAssetMeta, error);\n\n      try {\n        this.messagingSystem.call(\n          'ApprovalController:rejectRequest',\n          suggestedAssetMeta.id,\n          new Error('Rejected'),\n        );\n      } catch (messageCallError) {\n        console.error(\n          'Failed to reject transaction approval request',\n          messageCallError,\n        );\n      }\n    }\n    const newSuggestedAssets = suggestedAssets.filter(\n      ({ id }) => id !== suggestedAssetID,\n    );\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n  }\n\n  /**\n   * Rejects a watchAsset request based on its ID by setting its status to \"rejected\"\n   * and emitting a `<suggestedAssetMeta.id>:finished` hub event.\n   *\n   * @param suggestedAssetID - The ID of the suggestedAsset to accept.\n   */\n  rejectWatchAsset(suggestedAssetID: string) {\n    const { suggestedAssets } = this.state;\n    const index = suggestedAssets.findIndex(\n      ({ id }) => suggestedAssetID === id,\n    );\n    const suggestedAssetMeta = suggestedAssets[index];\n    if (!suggestedAssetMeta) {\n      return;\n    }\n    suggestedAssetMeta.status = SuggestedAssetStatus.rejected;\n\n    this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n    const newSuggestedAssets = suggestedAssets.filter(\n      ({ id }) => id !== suggestedAssetID,\n    );\n    this.update({ suggestedAssets: [...newSuggestedAssets] });\n\n    try {\n      this.messagingSystem.call(\n        'ApprovalController:rejectRequest',\n        suggestedAssetMeta.id,\n        new Error('Rejected'),\n      );\n    } catch (error) {\n      console.error('Failed to reject transaction approval request', error);\n    }\n  }\n\n  /**\n   * Takes a new tokens and ignoredTokens array for the current network/account combination\n   * and returns new allTokens and allIgnoredTokens state to update to.\n   *\n   * @param params - Object that holds token params.\n   * @param params.newTokens - The new tokens to set for the current network and selected account.\n   * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.\n   * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.\n   * @param params.interactingAddress - The account address to use to store the tokens.\n   * @param params.interactingChainId - The chainId to use to store the tokens.\n   * @returns The updated `allTokens` and `allIgnoredTokens` state.\n   */\n  _getNewAllTokensState(params: {\n    newTokens?: Token[];\n    newIgnoredTokens?: string[];\n    newDetectedTokens?: Token[];\n    interactingAddress?: string;\n    interactingChainId?: string;\n  }) {\n    const {\n      newTokens,\n      newIgnoredTokens,\n      newDetectedTokens,\n      interactingAddress,\n      interactingChainId,\n    } = params;\n    const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;\n    const { chainId, selectedAddress } = this.config;\n\n    const userAddressToAddTokens = interactingAddress ?? selectedAddress;\n    const chainIdToAddTokens = interactingChainId ?? chainId;\n\n    let newAllTokens = allTokens;\n    if (\n      newTokens?.length ||\n      (newTokens &&\n        allTokens &&\n        allTokens[chainIdToAddTokens] &&\n        allTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkTokens = allTokens[chainIdToAddTokens];\n      const newNetworkTokens = {\n        ...networkTokens,\n        ...{ [userAddressToAddTokens]: newTokens },\n      };\n      newAllTokens = {\n        ...allTokens,\n        ...{ [chainIdToAddTokens]: newNetworkTokens },\n      };\n    }\n\n    let newAllIgnoredTokens = allIgnoredTokens;\n    if (\n      newIgnoredTokens?.length ||\n      (newIgnoredTokens &&\n        allIgnoredTokens &&\n        allIgnoredTokens[chainIdToAddTokens] &&\n        allIgnoredTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkIgnoredTokens = allIgnoredTokens[chainIdToAddTokens];\n      const newIgnoredNetworkTokens = {\n        ...networkIgnoredTokens,\n        ...{ [userAddressToAddTokens]: newIgnoredTokens },\n      };\n      newAllIgnoredTokens = {\n        ...allIgnoredTokens,\n        ...{ [chainIdToAddTokens]: newIgnoredNetworkTokens },\n      };\n    }\n\n    let newAllDetectedTokens = allDetectedTokens;\n    if (\n      newDetectedTokens?.length ||\n      (newDetectedTokens &&\n        allDetectedTokens &&\n        allDetectedTokens[chainIdToAddTokens] &&\n        allDetectedTokens[chainIdToAddTokens][userAddressToAddTokens])\n    ) {\n      const networkDetectedTokens = allDetectedTokens[chainIdToAddTokens];\n      const newDetectedNetworkTokens = {\n        ...networkDetectedTokens,\n        ...{ [userAddressToAddTokens]: newDetectedTokens },\n      };\n      newAllDetectedTokens = {\n        ...allDetectedTokens,\n        ...{ [chainIdToAddTokens]: newDetectedNetworkTokens },\n      };\n    }\n    return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };\n  }\n\n  /**\n   * Removes all tokens from the ignored list.\n   */\n  clearIgnoredTokens() {\n    this.update({ ignoredTokens: [], allIgnoredTokens: {} });\n  }\n}\n\nexport default TokensController;\n"]}
\ No newline at end of file
diff --git a/dist/assetsUtil.d.ts b/dist/assetsUtil.d.ts
index a58b709020fab09cdd2323bd69875c8fe9197504..1b69903a3f8e19f5a451c94791ea16fb18e94d93 100644
--- a/dist/assetsUtil.d.ts
+++ b/dist/assetsUtil.d.ts
@@ -104,3 +104,4 @@ export declare function addUrlProtocolPrefix(urlString: string): string;
  * @returns A BN object.
  */
 export declare function ethersBigNumberToBN(bigNumber: BigNumber): BN;
+//# sourceMappingURL=assetsUtil.d.ts.map
\ No newline at end of file
diff --git a/dist/crypto-compare.d.ts b/dist/crypto-compare.d.ts
index a62342e4fe5bd2c15d6b5c411ab953d82d61afc1..da659b7ce54ab69e9a8496ec808f4ebcf17f7598 100644
--- a/dist/crypto-compare.d.ts
+++ b/dist/crypto-compare.d.ts
@@ -10,3 +10,4 @@ export declare function fetchExchangeRate(currency: string, nativeCurrency: stri
     conversionRate: number;
     usdConversionRate: number;
 }>;
+//# sourceMappingURL=crypto-compare.d.ts.map
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index b580f40d4268507b01671e6c5a1db0a8c609c004..95263210f7136994df87a134d67754b4ee2c1545 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -9,3 +9,4 @@ export * from './TokenListController';
 export * from './TokenRatesController';
 export * from './TokensController';
 export { isTokenDetectionSupportedForNetwork, formatIconUrlWithProxy, getFormattedIpfsUrl, } from './assetsUtil';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/token-service.d.ts b/dist/token-service.d.ts
index 25542efd6f38a5f38f7666207920b871f5160ac9..995987bedc27d0af4405074146b4de537138fa8b 100644
--- a/dist/token-service.d.ts
+++ b/dist/token-service.d.ts
@@ -27,3 +27,4 @@ export declare function fetchTokenList(chainId: string, abortSignal: AbortSignal
 export declare function fetchTokenMetadata<T>(chainId: string, tokenAddress: string, abortSignal: AbortSignal, { timeout }?: {
     timeout?: number | undefined;
 }): Promise<T | undefined>;
+//# sourceMappingURL=token-service.d.ts.map
\ No newline at end of file
diff --git a/package.json b/package.json
index a95d55ed9eae4036a93e6da450dbef592971cdcd..41d33a554edfb6c65030d30365f4c5f4ee48638a 100644
--- a/package.json
+++ b/package.json
@@ -33,6 +33,7 @@
     "@ethersproject/contracts": "^5.7.0",
     "@ethersproject/providers": "^5.7.0",
     "@metamask/abi-utils": "^1.1.0",
+    "@metamask/approval-controller": "^2.0.0",
     "@metamask/base-controller": "^1.1.2",
     "@metamask/contract-metadata": "^2.1.0",
     "@metamask/controller-utils": "^2.0.0",
@@ -68,6 +69,7 @@
     "typescript": "~4.6.3"
   },
   "peerDependencies": {
+    "@metamask/approval-controller": "^2.0.0",
     "@metamask/network-controller": "^4.0.0"
   },
   "engines": {
