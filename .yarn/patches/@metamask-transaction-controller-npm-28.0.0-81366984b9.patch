diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index b40a9c5a71c024e718acf89391e32b58d6e0b74f..2c506af5a48aa95eca30d4ed7b67900e495898e3 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -4,31 +4,33 @@
 
 
 
-var _chunkX5WPBDI5js = require('./chunk-X5WPBDI5.js');
+var _chunkKAWQSLDOjs = require('./chunk-KAWQSLDO.js');
+require('./chunk-JAYYMCBQ.js');
+require('./chunk-KT6UAKBB.js');
 require('./chunk-SD6CWFDF.js');
 require('./chunk-VH47Q6TS.js');
-require('./chunk-AO3AE3L7.js');
+require('./chunk-7LXE4KHV.js');
+require('./chunk-V72C4MCR.js');
 require('./chunk-QP75SWIQ.js');
 require('./chunk-ZNZEJDOE.js');
-require('./chunk-3VF7ZGRV.js');
-require('./chunk-KT6UAKBB.js');
-require('./chunk-ETMW527M.js');
-require('./chunk-V6UIRCOF.js');
-require('./chunk-2XKEAKQG.js');
 require('./chunk-DTDTOMTB.js');
-require('./chunk-CPYXP2OC.js');
-require('./chunk-3JEUO765.js');
+require('./chunk-5XQ2KRYL.js');
 require('./chunk-5KMU2IAT.js');
-require('./chunk-F247MMTE.js');
-require('./chunk-7LXE4KHV.js');
-require('./chunk-HMOSP33F.js');
-require('./chunk-UBXRAA6G.js');
-require('./chunk-LYD4TEKH.js');
-require('./chunk-L337FYVS.js');
-require('./chunk-WLCFETHR.js');
+require('./chunk-LNX4JTOL.js');
+require('./chunk-4RJXBKSR.js');
+require('./chunk-EQNKFFTM.js');
+require('./chunk-C2LNDHP4.js');
 require('./chunk-UGFBA4GV.js');
+require('./chunk-PVLJMHKL.js');
+require('./chunk-Q7KPVQHQ.js');
+require('./chunk-HXEBV7KA.js');
+require('./chunk-HMOSP33F.js');
+require('./chunk-EQT25RSP.js');
+require('./chunk-FDUCRHYT.js');
+require('./chunk-UGN7PBON.js');
+require('./chunk-V6UIRCOF.js');
+require('./chunk-2XKEAKQG.js');
 require('./chunk-UH7FNVKS.js');
-require('./chunk-LQS2M5QR.js');
 require('./chunk-S6VGOPUY.js');
 require('./chunk-FK7AP6SH.js');
 require('./chunk-Z4BLTVTB.js');
@@ -38,5 +40,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.ApprovalState = _chunkX5WPBDI5js.ApprovalState; exports.CANCEL_RATE = _chunkX5WPBDI5js.CANCEL_RATE; exports.HARDFORK = _chunkX5WPBDI5js.HARDFORK; exports.SPEED_UP_RATE = _chunkX5WPBDI5js.SPEED_UP_RATE; exports.TransactionController = _chunkX5WPBDI5js.TransactionController;
+exports.ApprovalState = _chunkKAWQSLDOjs.ApprovalState; exports.CANCEL_RATE = _chunkKAWQSLDOjs.CANCEL_RATE; exports.HARDFORK = _chunkKAWQSLDOjs.HARDFORK; exports.SPEED_UP_RATE = _chunkKAWQSLDOjs.SPEED_UP_RATE; exports.TransactionController = _chunkKAWQSLDOjs.TransactionController;
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/chunk-4RJXBKSR.js b/dist/chunk-4RJXBKSR.js
new file mode 100644
index 0000000000000000000000000000000000000000..00754fe61e3d426d748b472bd8aaaa6bd4a8c7c7
--- /dev/null
+++ b/dist/chunk-4RJXBKSR.js
@@ -0,0 +1,90 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkEQNKFFTMjs = require('./chunk-EQNKFFTM.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunkFK7AP6SHjs = require('./chunk-FK7AP6SH.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/DefaultGasFeeFlow.ts
+var _gasfeecontroller = require('@metamask/gas-fee-controller');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "default-gas-fee-flow");
+var _getEstimateLevel, getEstimateLevel_fn, _getFeeMarketLevel, getFeeMarketLevel_fn, _getLegacyLevel, getLegacyLevel_fn;
+var DefaultGasFeeFlow = class {
+  constructor() {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getEstimateLevel);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getFeeMarketLevel);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLegacyLevel);
+  }
+  matchesTransaction(_transactionMeta) {
+    return true;
+  }
+  async getGasFees(request) {
+    const { getGasFeeControllerEstimates, transactionMeta } = request;
+    const { networkClientId } = transactionMeta;
+    const { gasEstimateType, gasFeeEstimates } = await getGasFeeControllerEstimates({ networkClientId });
+    if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+      log("Using fee market estimates", gasFeeEstimates);
+    } else if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.LEGACY) {
+      log("Using legacy estimates", gasFeeEstimates);
+    } else {
+      throw new Error(`'No gas fee estimates available`);
+    }
+    const estimates = Object.values(_chunkFK7AP6SHjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getEstimateLevel, getEstimateLevel_fn).call(this, {
+          gasEstimateType,
+          gasFeeEstimates,
+          level
+        })
+      }),
+      {}
+    );
+    return { estimates };
+  }
+};
+_getEstimateLevel = new WeakSet();
+getEstimateLevel_fn = function({
+  gasEstimateType,
+  gasFeeEstimates,
+  level
+}) {
+  if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+    return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getFeeMarketLevel, getFeeMarketLevel_fn).call(this, gasFeeEstimates, level);
+  }
+  return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLegacyLevel, getLegacyLevel_fn).call(this, gasFeeEstimates, level);
+};
+_getFeeMarketLevel = new WeakSet();
+getFeeMarketLevel_fn = function(gasFeeEstimates, level) {
+  const maxFeePerGas = _chunkEQNKFFTMjs.gweiDecimalToWeiHex.call(void 0, 
+    gasFeeEstimates[level].suggestedMaxFeePerGas
+  );
+  const maxPriorityFeePerGas = _chunkEQNKFFTMjs.gweiDecimalToWeiHex.call(void 0, 
+    gasFeeEstimates[level].suggestedMaxPriorityFeePerGas
+  );
+  return {
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  };
+};
+_getLegacyLevel = new WeakSet();
+getLegacyLevel_fn = function(gasFeeEstimates, level) {
+  const gasPrice = _chunkEQNKFFTMjs.gweiDecimalToWeiHex.call(void 0, gasFeeEstimates[level]);
+  return {
+    maxFeePerGas: gasPrice,
+    maxPriorityFeePerGas: gasPrice
+  };
+};
+
+
+
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+//# sourceMappingURL=chunk-4RJXBKSR.js.map
\ No newline at end of file
diff --git a/dist/chunk-5XQ2KRYL.js b/dist/chunk-5XQ2KRYL.js
new file mode 100644
index 0000000000000000000000000000000000000000..4edeff2e0b9f8c12212109b79fb53dce4521ea0d
--- /dev/null
+++ b/dist/chunk-5XQ2KRYL.js
@@ -0,0 +1,335 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkEQT25RSPjs = require('./chunk-EQT25RSP.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/helpers/MultichainTrackingHelper.ts
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _asyncmutex = require('async-mutex');
+var _isMultichainEnabled, _provider, _nonceTracker, _incomingTransactionOptions, _findNetworkClientIdByChainId, _getNetworkClientById, _getNetworkClientRegistry, _removeIncomingTransactionHelperListeners, _removePendingTransactionTrackerListeners, _createNonceTracker, _createIncomingTransactionHelper, _createPendingTransactionTracker, _nonceMutexesByChainId, _trackingMap, _etherscanRemoteTransactionSourcesMap, _refreshTrackingMap, _stopTrackingByNetworkClientId, stopTrackingByNetworkClientId_fn, _startTrackingByNetworkClientId, startTrackingByNetworkClientId_fn, _refreshEtherscanRemoteTransactionSources, _getNetworkClient, getNetworkClient_fn;
+var MultichainTrackingHelper = class {
+  constructor({
+    isMultichainEnabled,
+    provider,
+    nonceTracker,
+    incomingTransactionOptions,
+    findNetworkClientIdByChainId,
+    getNetworkClientById,
+    getNetworkClientRegistry,
+    removeIncomingTransactionHelperListeners,
+    removePendingTransactionTrackerListeners,
+    createNonceTracker,
+    createIncomingTransactionHelper,
+    createPendingTransactionTracker,
+    onNetworkStateChange
+  }) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopTrackingByNetworkClientId);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _startTrackingByNetworkClientId);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNetworkClient);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isMultichainEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _provider, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _nonceTracker, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _incomingTransactionOptions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _findNetworkClientIdByChainId, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNetworkClientById, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNetworkClientRegistry, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removeIncomingTransactionHelperListeners, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removePendingTransactionTrackerListeners, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createNonceTracker, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createIncomingTransactionHelper, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createPendingTransactionTracker, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _nonceMutexesByChainId, /* @__PURE__ */ new Map());
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _trackingMap, /* @__PURE__ */ new Map());
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _etherscanRemoteTransactionSourcesMap, /* @__PURE__ */ new Map());
+    this.checkForPendingTransactionAndStartPolling = () => {
+      for (const [, trackers] of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap)) {
+        trackers.pendingTransactionTracker.startIfPendingTransactions();
+      }
+    };
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _refreshTrackingMap, (networkClients) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _refreshEtherscanRemoteTransactionSources).call(this, networkClients);
+      const networkClientIds = Object.keys(networkClients);
+      const existingNetworkClientIds = Array.from(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).keys());
+      const networkClientIdsToRemove = existingNetworkClientIds.filter(
+        (id) => !networkClientIds.includes(id)
+      );
+      networkClientIdsToRemove.forEach((id) => {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopTrackingByNetworkClientId, stopTrackingByNetworkClientId_fn).call(this, id);
+      });
+      const networkClientIdsToAdd = networkClientIds.filter(
+        (id) => !existingNetworkClientIds.includes(id)
+      );
+      networkClientIdsToAdd.forEach((id) => {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _startTrackingByNetworkClientId, startTrackingByNetworkClientId_fn).call(this, id);
+      });
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _refreshEtherscanRemoteTransactionSources, (networkClients) => {
+      const chainIdsInRegistry = /* @__PURE__ */ new Set();
+      Object.values(networkClients).forEach(
+        (networkClient) => chainIdsInRegistry.add(networkClient.configuration.chainId)
+      );
+      const existingChainIds = Array.from(
+        _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _etherscanRemoteTransactionSourcesMap).keys()
+      );
+      const chainIdsToRemove = existingChainIds.filter(
+        (chainId) => !chainIdsInRegistry.has(chainId)
+      );
+      chainIdsToRemove.forEach((chainId) => {
+        _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _etherscanRemoteTransactionSourcesMap).delete(chainId);
+      });
+    });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isMultichainEnabled, isMultichainEnabled);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _provider, provider);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _nonceTracker, nonceTracker);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _incomingTransactionOptions, incomingTransactionOptions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _findNetworkClientIdByChainId, findNetworkClientIdByChainId);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getNetworkClientById, getNetworkClientById);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getNetworkClientRegistry, getNetworkClientRegistry);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _createNonceTracker, createNonceTracker);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker);
+    onNetworkStateChange((_, patches) => {
+      if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isMultichainEnabled)) {
+        const networkClients = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNetworkClientRegistry).call(this);
+        patches.forEach(({ op, path }) => {
+          if (op === "remove" && path[0] === "networkConfigurations") {
+            const networkClientId = path[1];
+            delete networkClients[networkClientId];
+          }
+        });
+        _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _refreshTrackingMap).call(this, networkClients);
+      }
+    });
+  }
+  initialize() {
+    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isMultichainEnabled)) {
+      return;
+    }
+    const networkClients = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNetworkClientRegistry).call(this);
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _refreshTrackingMap).call(this, networkClients);
+  }
+  has(networkClientId) {
+    return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).has(networkClientId);
+  }
+  getEthQuery({
+    networkClientId,
+    chainId
+  } = {}) {
+    return new (0, _ethquery2.default)(this.getProvider({ networkClientId, chainId }));
+  }
+  getProvider({
+    networkClientId,
+    chainId
+  } = {}) {
+    if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isMultichainEnabled)) {
+      return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _provider);
+    }
+    const networkClient = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNetworkClient, getNetworkClient_fn).call(this, {
+      networkClientId,
+      chainId
+    });
+    return networkClient?.provider || _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _provider);
+  }
+  /**
+   * Gets the mutex intended to guard the nonceTracker for a particular chainId and key .
+   *
+   * @param opts - The options object.
+   * @param opts.chainId - The hex chainId.
+   * @param opts.key - The hex address (or constant) pertaining to the chainId
+   * @returns Mutex instance for the given chainId and key pair
+   */
+  async acquireNonceLockForChainIdKey({
+    chainId,
+    key = "global"
+  }) {
+    let nonceMutexesForChainId = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _nonceMutexesByChainId).get(chainId);
+    if (!nonceMutexesForChainId) {
+      nonceMutexesForChainId = /* @__PURE__ */ new Map();
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _nonceMutexesByChainId).set(chainId, nonceMutexesForChainId);
+    }
+    let nonceMutexForKey = nonceMutexesForChainId.get(key);
+    if (!nonceMutexForKey) {
+      nonceMutexForKey = new (0, _asyncmutex.Mutex)();
+      nonceMutexesForChainId.set(key, nonceMutexForKey);
+    }
+    return await nonceMutexForKey.acquire();
+  }
+  /**
+   * Gets the next nonce according to the nonce-tracker.
+   * Ensure `releaseLock` is called once processing of the `nonce` value is complete.
+   *
+   * @param address - The hex string address for the transaction.
+   * @param networkClientId - The network client ID for the transaction, used to fetch the correct nonce tracker.
+   * @returns object with the `nextNonce` `nonceDetails`, and the releaseLock.
+   */
+  async getNonceLock(address, networkClientId) {
+    let releaseLockForChainIdKey;
+    let nonceTracker = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _nonceTracker);
+    if (networkClientId && _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isMultichainEnabled)) {
+      const networkClient = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNetworkClientById).call(this, networkClientId);
+      releaseLockForChainIdKey = await this.acquireNonceLockForChainIdKey({
+        chainId: networkClient.configuration.chainId,
+        key: address
+      });
+      const trackers = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).get(networkClientId);
+      if (!trackers) {
+        throw new Error("missing nonceTracker for networkClientId");
+      }
+      nonceTracker = trackers.nonceTracker;
+    }
+    try {
+      const nonceLock = await nonceTracker.getNonceLock(address);
+      return {
+        ...nonceLock,
+        releaseLock: () => {
+          nonceLock.releaseLock();
+          releaseLockForChainIdKey?.();
+        }
+      };
+    } catch (err) {
+      releaseLockForChainIdKey?.();
+      throw err;
+    }
+  }
+  startIncomingTransactionPolling(networkClientIds = []) {
+    networkClientIds.forEach((networkClientId) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).get(networkClientId)?.incomingTransactionHelper.start();
+    });
+  }
+  stopIncomingTransactionPolling(networkClientIds = []) {
+    networkClientIds.forEach((networkClientId) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).get(networkClientId)?.incomingTransactionHelper.stop();
+    });
+  }
+  stopAllIncomingTransactionPolling() {
+    for (const [, trackers] of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap)) {
+      trackers.incomingTransactionHelper.stop();
+    }
+  }
+  async updateIncomingTransactions(networkClientIds = []) {
+    const promises = await Promise.allSettled(
+      networkClientIds.map(async (networkClientId) => {
+        return await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).get(networkClientId)?.incomingTransactionHelper.update();
+      })
+    );
+    promises.filter((result) => result.status === "rejected").forEach((result) => {
+      _chunkS6VGOPUYjs.incomingTransactionsLogger.call(void 0, 
+        "failed to update incoming transactions",
+        result.reason
+      );
+    });
+  }
+  stopAllTracking() {
+    for (const [networkClientId] of _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap)) {
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopTrackingByNetworkClientId, stopTrackingByNetworkClientId_fn).call(this, networkClientId);
+    }
+  }
+};
+_isMultichainEnabled = new WeakMap();
+_provider = new WeakMap();
+_nonceTracker = new WeakMap();
+_incomingTransactionOptions = new WeakMap();
+_findNetworkClientIdByChainId = new WeakMap();
+_getNetworkClientById = new WeakMap();
+_getNetworkClientRegistry = new WeakMap();
+_removeIncomingTransactionHelperListeners = new WeakMap();
+_removePendingTransactionTrackerListeners = new WeakMap();
+_createNonceTracker = new WeakMap();
+_createIncomingTransactionHelper = new WeakMap();
+_createPendingTransactionTracker = new WeakMap();
+_nonceMutexesByChainId = new WeakMap();
+_trackingMap = new WeakMap();
+_etherscanRemoteTransactionSourcesMap = new WeakMap();
+_refreshTrackingMap = new WeakMap();
+_stopTrackingByNetworkClientId = new WeakSet();
+stopTrackingByNetworkClientId_fn = function(networkClientId) {
+  const trackers = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).get(networkClientId);
+  if (trackers) {
+    trackers.pendingTransactionTracker.stop();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _removePendingTransactionTrackerListeners).call(this, trackers.pendingTransactionTracker);
+    trackers.incomingTransactionHelper.stop();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _removeIncomingTransactionHelperListeners).call(this, trackers.incomingTransactionHelper);
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).delete(networkClientId);
+  }
+};
+_startTrackingByNetworkClientId = new WeakSet();
+startTrackingByNetworkClientId_fn = function(networkClientId) {
+  const trackers = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).get(networkClientId);
+  if (trackers) {
+    return;
+  }
+  const {
+    provider,
+    blockTracker,
+    configuration: { chainId }
+  } = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNetworkClientById).call(this, networkClientId);
+  let etherscanRemoteTransactionSource = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _etherscanRemoteTransactionSourcesMap).get(chainId);
+  if (!etherscanRemoteTransactionSource) {
+    etherscanRemoteTransactionSource = new (0, _chunkEQT25RSPjs.EtherscanRemoteTransactionSource)({
+      includeTokenTransfers: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).includeTokenTransfers
+    });
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _etherscanRemoteTransactionSourcesMap).set(
+      chainId,
+      etherscanRemoteTransactionSource
+    );
+  }
+  const nonceTracker = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _createNonceTracker).call(this, {
+    provider,
+    blockTracker,
+    chainId
+  });
+  const incomingTransactionHelper = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _createIncomingTransactionHelper).call(this, {
+    blockTracker,
+    etherscanRemoteTransactionSource,
+    chainId
+  });
+  const pendingTransactionTracker = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _createPendingTransactionTracker).call(this, {
+    provider,
+    blockTracker,
+    chainId
+  });
+  _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _trackingMap).set(networkClientId, {
+    nonceTracker,
+    incomingTransactionHelper,
+    pendingTransactionTracker
+  });
+};
+_refreshEtherscanRemoteTransactionSources = new WeakMap();
+_getNetworkClient = new WeakSet();
+getNetworkClient_fn = function({
+  networkClientId,
+  chainId
+} = {}) {
+  let networkClient;
+  if (networkClientId) {
+    try {
+      networkClient = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNetworkClientById).call(this, networkClientId);
+    } catch (err) {
+      _chunkS6VGOPUYjs.incomingTransactionsLogger.call(void 0, "failed to get network client by networkClientId");
+    }
+  }
+  if (!networkClient && chainId) {
+    try {
+      const networkClientIdForChainId = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _findNetworkClientIdByChainId).call(this, chainId);
+      networkClient = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getNetworkClientById).call(this, networkClientIdForChainId);
+    } catch (err) {
+      _chunkS6VGOPUYjs.incomingTransactionsLogger.call(void 0, "failed to get network client by chainId");
+    }
+  }
+  return networkClient;
+};
+
+
+
+exports.MultichainTrackingHelper = MultichainTrackingHelper;
+//# sourceMappingURL=chunk-5XQ2KRYL.js.map
\ No newline at end of file
diff --git a/dist/chunk-C2LNDHP4.js b/dist/chunk-C2LNDHP4.js
new file mode 100644
index 0000000000000000000000000000000000000000..cd260da3bd86dac12343f6b7b77080b76ae927a8
--- /dev/null
+++ b/dist/chunk-C2LNDHP4.js
@@ -0,0 +1,211 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
+
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/swaps.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _lodash = require('lodash');
+var log = _chunkS6VGOPUYjs.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "swaps");
+var UPDATE_POST_TX_BALANCE_TIMEOUT = 5e3;
+var UPDATE_POST_TX_BALANCE_ATTEMPTS = 6;
+var SWAPS_TESTNET_CHAIN_ID = "0x539";
+var DEFAULT_TOKEN_ADDRESS = "0x0000000000000000000000000000000000000000";
+var ETH_SWAPS_TOKEN_OBJECT = {
+  name: "Ether",
+  address: DEFAULT_TOKEN_ADDRESS,
+  decimals: 18
+};
+var BNB_SWAPS_TOKEN_OBJECT = {
+  name: "Binance Coin",
+  address: DEFAULT_TOKEN_ADDRESS,
+  decimals: 18
+};
+var MATIC_SWAPS_TOKEN_OBJECT = {
+  name: "Matic",
+  address: DEFAULT_TOKEN_ADDRESS,
+  decimals: 18
+};
+var AVAX_SWAPS_TOKEN_OBJECT = {
+  name: "Avalanche",
+  address: DEFAULT_TOKEN_ADDRESS,
+  decimals: 18
+};
+var TEST_ETH_SWAPS_TOKEN_OBJECT = {
+  name: "Test Ether",
+  address: DEFAULT_TOKEN_ADDRESS,
+  decimals: 18
+};
+var GOERLI_SWAPS_TOKEN_OBJECT = {
+  name: "Ether",
+  address: DEFAULT_TOKEN_ADDRESS,
+  decimals: 18
+};
+var ARBITRUM_SWAPS_TOKEN_OBJECT = {
+  ...ETH_SWAPS_TOKEN_OBJECT
+};
+var OPTIMISM_SWAPS_TOKEN_OBJECT = {
+  ...ETH_SWAPS_TOKEN_OBJECT
+};
+var ZKSYNC_ERA_SWAPS_TOKEN_OBJECT = {
+  ...ETH_SWAPS_TOKEN_OBJECT
+};
+var SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
+  [_chunkUGN7PBONjs.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
+  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT,
+  [_chunkUGN7PBONjs.CHAIN_IDS.ZKSYNC_ERA]: ZKSYNC_ERA_SWAPS_TOKEN_OBJECT
+};
+var SWAP_TRANSACTION_TYPES = [
+  "swap" /* swap */,
+  "swapApproval" /* swapApproval */
+];
+function updateSwapsTransaction(transactionMeta, transactionType, swaps, {
+  isSwapsDisabled,
+  cancelTransaction,
+  messenger
+}) {
+  if (isSwapsDisabled || !SWAP_TRANSACTION_TYPES.includes(transactionType)) {
+    return transactionMeta;
+  }
+  if (transactionType === "swap" /* swap */ && swaps?.hasApproveTx === false && transactionMeta.simulationFails) {
+    cancelTransaction(transactionMeta.id);
+    throw new Error("Simulation failed");
+  }
+  const swapsMeta = swaps?.meta;
+  if (!swapsMeta) {
+    return transactionMeta;
+  }
+  let updatedTransactionMeta = transactionMeta;
+  if (transactionType === "swapApproval" /* swapApproval */) {
+    updatedTransactionMeta = updateSwapApprovalTransaction(
+      transactionMeta,
+      swapsMeta
+    );
+    messenger.publish("TransactionController:transactionNewSwapApproval", {
+      transactionMeta: updatedTransactionMeta
+    });
+  }
+  if (transactionType === "swap" /* swap */) {
+    updatedTransactionMeta = updateSwapTransaction(transactionMeta, swapsMeta);
+    messenger.publish("TransactionController:transactionNewSwap", {
+      transactionMeta: updatedTransactionMeta
+    });
+  }
+  return updatedTransactionMeta;
+}
+async function updatePostTransactionBalance(transactionMeta, {
+  ethQuery,
+  getTransaction,
+  updateTransaction
+}) {
+  log("Updating post transaction balance", transactionMeta.id);
+  const transactionId = transactionMeta.id;
+  let latestTransactionMeta;
+  let approvalTransactionMeta;
+  for (let i = 0; i < UPDATE_POST_TX_BALANCE_ATTEMPTS; i++) {
+    log("Querying balance", { attempt: i });
+    const postTransactionBalance = await _controllerutils.query.call(void 0, ethQuery, "getBalance", [
+      transactionMeta.txParams.from
+    ]);
+    latestTransactionMeta = {
+      ...getTransaction(transactionId) ?? {}
+    };
+    approvalTransactionMeta = latestTransactionMeta.approvalTxId ? getTransaction(latestTransactionMeta.approvalTxId) : void 0;
+    latestTransactionMeta.postTxBalance = postTransactionBalance.toString(16);
+    const isDefaultTokenAddress = isSwapsDefaultTokenAddress(
+      transactionMeta.destinationTokenAddress,
+      transactionMeta.chainId
+    );
+    if (!isDefaultTokenAddress || transactionMeta.preTxBalance !== latestTransactionMeta.postTxBalance) {
+      log("Finishing post balance update", {
+        isDefaultTokenAddress,
+        preTxBalance: transactionMeta.preTxBalance,
+        postTxBalance: latestTransactionMeta.postTxBalance
+      });
+      break;
+    }
+    log("Waiting for balance to update", {
+      delay: UPDATE_POST_TX_BALANCE_TIMEOUT
+    });
+    await sleep(UPDATE_POST_TX_BALANCE_TIMEOUT);
+  }
+  updateTransaction(
+    latestTransactionMeta,
+    "TransactionController#updatePostTransactionBalance - Add post transaction balance"
+  );
+  log("Completed post balance update", latestTransactionMeta?.postTxBalance);
+  return {
+    updatedTransactionMeta: latestTransactionMeta,
+    approvalTransactionMeta
+  };
+}
+function updateSwapTransaction(transactionMeta, {
+  sourceTokenSymbol,
+  destinationTokenSymbol,
+  type,
+  destinationTokenDecimals,
+  destinationTokenAddress,
+  swapMetaData,
+  swapTokenValue,
+  estimatedBaseFee,
+  approvalTxId
+}) {
+  _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updateSwapTransaction");
+  let swapTransaction = {
+    sourceTokenSymbol,
+    destinationTokenSymbol,
+    type,
+    destinationTokenDecimals,
+    destinationTokenAddress,
+    swapMetaData,
+    swapTokenValue,
+    estimatedBaseFee,
+    approvalTxId
+  };
+  swapTransaction = _lodash.pickBy.call(void 0, swapTransaction);
+  return _lodash.merge.call(void 0, {}, transactionMeta, swapTransaction);
+}
+function updateSwapApprovalTransaction(transactionMeta, { type, sourceTokenSymbol }) {
+  _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+    transactionMeta,
+    "updateSwapApprovalTransaction"
+  );
+  let swapApprovalTransaction = { type, sourceTokenSymbol };
+  swapApprovalTransaction = _lodash.pickBy.call(void 0, {
+    type,
+    sourceTokenSymbol
+  });
+  return _lodash.merge.call(void 0, {}, transactionMeta, swapApprovalTransaction);
+}
+function isSwapsDefaultTokenAddress(address, chainId) {
+  if (!address || !chainId) {
+    return false;
+  }
+  return address === SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]?.address;
+}
+function sleep(ms) {
+  return new Promise((resolve) => setTimeout(resolve, ms));
+}
+
+
+
+
+
+
+
+
+
+exports.UPDATE_POST_TX_BALANCE_TIMEOUT = UPDATE_POST_TX_BALANCE_TIMEOUT; exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = UPDATE_POST_TX_BALANCE_ATTEMPTS; exports.DEFAULT_TOKEN_ADDRESS = DEFAULT_TOKEN_ADDRESS; exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = SWAPS_CHAINID_DEFAULT_TOKEN_MAP; exports.SWAP_TRANSACTION_TYPES = SWAP_TRANSACTION_TYPES; exports.updateSwapsTransaction = updateSwapsTransaction; exports.updatePostTransactionBalance = updatePostTransactionBalance;
+//# sourceMappingURL=chunk-C2LNDHP4.js.map
\ No newline at end of file
diff --git a/dist/chunk-EQNKFFTM.js b/dist/chunk-EQNKFFTM.js
new file mode 100644
index 0000000000000000000000000000000000000000..c5e6bece86a0785e5b77ae80d193dcd1c73c00d0
--- /dev/null
+++ b/dist/chunk-EQNKFFTM.js
@@ -0,0 +1,208 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkC2LNDHP4js = require('./chunk-C2LNDHP4.js');
+
+
+var _chunkUH7FNVKSjs = require('./chunk-UH7FNVKS.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/gas-fees.ts
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "gas-fees");
+async function updateGasFees(request) {
+  const { txMeta } = request;
+  const initialParams = { ...txMeta.txParams };
+  const isSwap = _chunkC2LNDHP4js.SWAP_TRANSACTION_TYPES.includes(
+    txMeta.type
+  );
+  const savedGasFees = isSwap ? void 0 : request.getSavedGasFees(txMeta.chainId);
+  const suggestedGasFees = await getSuggestedGasFees(request);
+  log("Suggested gas fees", suggestedGasFees);
+  const getGasFeeRequest = {
+    ...request,
+    initialParams,
+    savedGasFees,
+    suggestedGasFees
+  };
+  txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
+  txMeta.txParams.maxPriorityFeePerGas = getMaxPriorityFeePerGas(getGasFeeRequest);
+  txMeta.txParams.gasPrice = getGasPrice(getGasFeeRequest);
+  txMeta.userFeeLevel = getUserFeeLevel(getGasFeeRequest);
+  log("Updated gas fee properties", {
+    maxFeePerGas: txMeta.txParams.maxFeePerGas,
+    maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas,
+    gasPrice: txMeta.txParams.gasPrice
+  });
+  if (txMeta.txParams.maxFeePerGas || txMeta.txParams.maxPriorityFeePerGas) {
+    delete txMeta.txParams.gasPrice;
+  }
+  if (txMeta.txParams.gasPrice) {
+    delete txMeta.txParams.maxFeePerGas;
+    delete txMeta.txParams.maxPriorityFeePerGas;
+  }
+  updateDefaultGasEstimates(txMeta);
+}
+function gweiDecimalToWeiHex(value) {
+  return _controllerutils.toHex.call(void 0, _controllerutils.gweiDecToWEIBN.call(void 0, value));
+}
+function getMaxFeePerGas(request) {
+  const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    const maxFeePerGas = gweiDecimalToWeiHex(savedGasFees.maxBaseFee);
+    log("Using maxFeePerGas from savedGasFees", maxFeePerGas);
+    return maxFeePerGas;
+  }
+  if (initialParams.maxFeePerGas) {
+    log("Using maxFeePerGas from request", initialParams.maxFeePerGas);
+    return initialParams.maxFeePerGas;
+  }
+  if (initialParams.gasPrice && !initialParams.maxPriorityFeePerGas) {
+    log(
+      "Setting maxFeePerGas to gasPrice from request",
+      initialParams.gasPrice
+    );
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxFeePerGas) {
+    log("Using suggested maxFeePerGas", suggestedGasFees.maxFeePerGas);
+    return suggestedGasFees.maxFeePerGas;
+  }
+  if (suggestedGasFees.gasPrice) {
+    log(
+      "Setting maxFeePerGas to suggested gasPrice",
+      suggestedGasFees.gasPrice
+    );
+    return suggestedGasFees.gasPrice;
+  }
+  log("maxFeePerGas not set");
+  return void 0;
+}
+function getMaxPriorityFeePerGas(request) {
+  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    const maxPriorityFeePerGas = gweiDecimalToWeiHex(savedGasFees.priorityFee);
+    log(
+      "Using maxPriorityFeePerGas from savedGasFees.priorityFee",
+      maxPriorityFeePerGas
+    );
+    return maxPriorityFeePerGas;
+  }
+  if (initialParams.maxPriorityFeePerGas) {
+    log(
+      "Using maxPriorityFeePerGas from request",
+      initialParams.maxPriorityFeePerGas
+    );
+    return initialParams.maxPriorityFeePerGas;
+  }
+  if (initialParams.gasPrice && !initialParams.maxFeePerGas) {
+    log(
+      "Setting maxPriorityFeePerGas to gasPrice from request",
+      initialParams.gasPrice
+    );
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxPriorityFeePerGas) {
+    log(
+      "Using suggested maxPriorityFeePerGas",
+      suggestedGasFees.maxPriorityFeePerGas
+    );
+    return suggestedGasFees.maxPriorityFeePerGas;
+  }
+  if (txMeta.txParams.maxFeePerGas) {
+    log(
+      "Setting maxPriorityFeePerGas to maxFeePerGas",
+      txMeta.txParams.maxFeePerGas
+    );
+    return txMeta.txParams.maxFeePerGas;
+  }
+  log("maxPriorityFeePerGas not set");
+  return void 0;
+}
+function getGasPrice(request) {
+  const { eip1559, initialParams, suggestedGasFees } = request;
+  if (eip1559) {
+    return void 0;
+  }
+  if (initialParams.gasPrice) {
+    log("Using gasPrice from request", initialParams.gasPrice);
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxFeePerGas) {
+    log("Using suggested maxFeePerGas", suggestedGasFees.maxFeePerGas);
+    return suggestedGasFees.maxFeePerGas;
+  }
+  if (suggestedGasFees.gasPrice) {
+    log("Using suggested gasPrice", suggestedGasFees.gasPrice);
+    return suggestedGasFees.gasPrice;
+  }
+  log("gasPrice not set");
+  return void 0;
+}
+function getUserFeeLevel(request) {
+  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    return "custom" /* CUSTOM */;
+  }
+  if (!initialParams.maxFeePerGas && !initialParams.maxPriorityFeePerGas && initialParams.gasPrice) {
+    return txMeta.origin === _controllerutils.ORIGIN_METAMASK ? "custom" /* CUSTOM */ : "dappSuggested" /* DAPP_SUGGESTED */;
+  }
+  if (!initialParams.maxFeePerGas && !initialParams.maxPriorityFeePerGas && suggestedGasFees.maxFeePerGas && suggestedGasFees.maxPriorityFeePerGas) {
+    return "medium" /* MEDIUM */;
+  }
+  if (txMeta.origin === _controllerutils.ORIGIN_METAMASK) {
+    return "medium" /* MEDIUM */;
+  }
+  return "dappSuggested" /* DAPP_SUGGESTED */;
+}
+function updateDefaultGasEstimates(txMeta) {
+  if (!txMeta.defaultGasEstimates) {
+    txMeta.defaultGasEstimates = {};
+  }
+  txMeta.defaultGasEstimates.maxFeePerGas = txMeta.txParams.maxFeePerGas;
+  txMeta.defaultGasEstimates.maxPriorityFeePerGas = txMeta.txParams.maxPriorityFeePerGas;
+  txMeta.defaultGasEstimates.gasPrice = txMeta.txParams.gasPrice;
+  txMeta.defaultGasEstimates.estimateType = txMeta.userFeeLevel;
+}
+async function getSuggestedGasFees(request) {
+  const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
+  if (!eip1559 && txMeta.txParams.gasPrice || eip1559 && txMeta.txParams.maxFeePerGas && txMeta.txParams.maxPriorityFeePerGas) {
+    return {};
+  }
+  const gasFeeFlow = _chunkUH7FNVKSjs.getGasFeeFlow.call(void 0, txMeta, gasFeeFlows);
+  try {
+    const response = await gasFeeFlow.getGasFees({
+      ethQuery,
+      getGasFeeControllerEstimates: getGasFeeEstimates,
+      transactionMeta: txMeta
+    });
+    return response.estimates.medium;
+  } catch (error) {
+    log("Failed to get suggested gas fees", error);
+  }
+  const gasPriceDecimal = await _controllerutils.query.call(void 0, ethQuery, "gasPrice");
+  const gasPrice = gasPriceDecimal ? _utils.add0x.call(void 0, gasPriceDecimal.toString(16)) : void 0;
+  return { gasPrice };
+}
+
+
+
+
+exports.updateGasFees = updateGasFees; exports.gweiDecimalToWeiHex = gweiDecimalToWeiHex;
+//# sourceMappingURL=chunk-EQNKFFTM.js.map
\ No newline at end of file
diff --git a/dist/chunk-EQT25RSP.js b/dist/chunk-EQT25RSP.js
new file mode 100644
index 0000000000000000000000000000000000000000..c166766fd872495ab061bc2549bea8e8d7a3c244
--- /dev/null
+++ b/dist/chunk-EQT25RSP.js
@@ -0,0 +1,170 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+
+var _chunkFDUCRHYTjs = require('./chunk-FDUCRHYT.js');
+
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/helpers/EtherscanRemoteTransactionSource.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _asyncmutex = require('async-mutex');
+var _bnjs = require('bn.js'); var _bnjs2 = _interopRequireDefault(_bnjs);
+var _uuid = require('uuid');
+var ETHERSCAN_RATE_LIMIT_INTERVAL = 5e3;
+var _includeTokenTransfers, _isTokenRequestPending, _mutex, _releaseLockAfterInterval, releaseLockAfterInterval_fn, _fetchNormalTransactions, _fetchTokenTransactions, _getResponseTransactions, getResponseTransactions_fn, _normalizeTransaction, normalizeTransaction_fn, _normalizeTokenTransaction, normalizeTokenTransaction_fn, _normalizeTransactionBase, normalizeTransactionBase_fn;
+var EtherscanRemoteTransactionSource = class {
+  constructor({
+    includeTokenTransfers
+  } = {}) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _releaseLockAfterInterval);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getResponseTransactions);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _normalizeTransaction);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _normalizeTokenTransaction);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _normalizeTransactionBase);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _includeTokenTransfers, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isTokenRequestPending, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _mutex, new (0, _asyncmutex.Mutex)());
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchNormalTransactions, async (request, etherscanRequest) => {
+      const { currentChainId } = request;
+      const etherscanTransactions = await _chunkFDUCRHYTjs.fetchEtherscanTransactions.call(void 0, 
+        etherscanRequest
+      );
+      return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getResponseTransactions, getResponseTransactions_fn).call(this, etherscanTransactions).map(
+        (tx) => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _normalizeTransaction, normalizeTransaction_fn).call(this, tx, currentChainId)
+      );
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _fetchTokenTransactions, async (request, etherscanRequest) => {
+      const { currentChainId } = request;
+      const etherscanTransactions = await _chunkFDUCRHYTjs.fetchEtherscanTokenTransactions.call(void 0, 
+        etherscanRequest
+      );
+      return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getResponseTransactions, getResponseTransactions_fn).call(this, etherscanTransactions).map(
+        (tx) => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _normalizeTokenTransaction, normalizeTokenTransaction_fn).call(this, tx, currentChainId)
+      );
+    });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _includeTokenTransfers, includeTokenTransfers ?? true);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isTokenRequestPending, false);
+  }
+  isSupportedNetwork(chainId) {
+    return Object.keys(_chunkUGN7PBONjs.ETHERSCAN_SUPPORTED_NETWORKS).includes(chainId);
+  }
+  getLastBlockVariations() {
+    return [_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isTokenRequestPending) ? "token" : "normal"];
+  }
+  async fetchTransactions(request) {
+    const releaseLock = await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _mutex).acquire();
+    const acquiredTime = Date.now();
+    const etherscanRequest = {
+      ...request,
+      chainId: request.currentChainId
+    };
+    try {
+      const transactions = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isTokenRequestPending) ? await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _fetchTokenTransactions).call(this, request, etherscanRequest) : await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _fetchNormalTransactions).call(this, request, etherscanRequest);
+      if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _includeTokenTransfers)) {
+        _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isTokenRequestPending, !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isTokenRequestPending));
+      }
+      return transactions;
+    } finally {
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _releaseLockAfterInterval, releaseLockAfterInterval_fn).call(this, acquiredTime, releaseLock);
+    }
+  }
+};
+_includeTokenTransfers = new WeakMap();
+_isTokenRequestPending = new WeakMap();
+_mutex = new WeakMap();
+_releaseLockAfterInterval = new WeakSet();
+releaseLockAfterInterval_fn = function(acquireTime, releaseLock) {
+  const elapsedTime = Date.now() - acquireTime;
+  const remainingTime = Math.max(
+    0,
+    ETHERSCAN_RATE_LIMIT_INTERVAL - elapsedTime
+  );
+  if (remainingTime > 0) {
+    setTimeout(releaseLock, remainingTime);
+  } else {
+    releaseLock();
+  }
+};
+_fetchNormalTransactions = new WeakMap();
+_fetchTokenTransactions = new WeakMap();
+_getResponseTransactions = new WeakSet();
+getResponseTransactions_fn = function(response) {
+  let result = response.result;
+  if (response.status === "0") {
+    result = [];
+    if (response.result.length) {
+      _chunkS6VGOPUYjs.incomingTransactionsLogger.call(void 0, "Ignored Etherscan request error", {
+        message: response.result,
+        type: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isTokenRequestPending) ? "token" : "normal"
+      });
+    }
+  }
+  return result;
+};
+_normalizeTransaction = new WeakSet();
+normalizeTransaction_fn = function(txMeta, currentChainId) {
+  const base = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _normalizeTransactionBase, normalizeTransactionBase_fn).call(this, txMeta, currentChainId);
+  return {
+    ...base,
+    txParams: {
+      ...base.txParams,
+      data: txMeta.input
+    },
+    ...txMeta.isError === "0" ? { status: "confirmed" /* confirmed */ } : {
+      error: new Error("Transaction failed"),
+      status: "failed" /* failed */
+    }
+  };
+};
+_normalizeTokenTransaction = new WeakSet();
+normalizeTokenTransaction_fn = function(txMeta, currentChainId) {
+  const base = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _normalizeTransactionBase, normalizeTransactionBase_fn).call(this, txMeta, currentChainId);
+  return {
+    ...base,
+    isTransfer: true,
+    transferInformation: {
+      contractAddress: txMeta.contractAddress,
+      decimals: Number(txMeta.tokenDecimal),
+      symbol: txMeta.tokenSymbol
+    }
+  };
+};
+_normalizeTransactionBase = new WeakSet();
+normalizeTransactionBase_fn = function(txMeta, currentChainId) {
+  const time = parseInt(txMeta.timeStamp, 10) * 1e3;
+  return {
+    blockNumber: txMeta.blockNumber,
+    chainId: currentChainId,
+    hash: txMeta.hash,
+    id: _uuid.v1.call(void 0, { msecs: time }),
+    status: "confirmed" /* confirmed */,
+    time,
+    txParams: {
+      chainId: currentChainId,
+      from: txMeta.from,
+      gas: _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(txMeta.gas)),
+      gasPrice: _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(txMeta.gasPrice)),
+      gasUsed: _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(txMeta.gasUsed)),
+      nonce: _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(txMeta.nonce)),
+      to: txMeta.to,
+      value: _controllerutils.BNToHex.call(void 0, new (0, _bnjs2.default)(txMeta.value))
+    },
+    type: "incoming" /* incoming */,
+    verifiedOnBlockchain: false
+  };
+};
+
+
+
+exports.EtherscanRemoteTransactionSource = EtherscanRemoteTransactionSource;
+//# sourceMappingURL=chunk-EQT25RSP.js.map
\ No newline at end of file
diff --git a/dist/chunk-FDUCRHYT.js b/dist/chunk-FDUCRHYT.js
new file mode 100644
index 0000000000000000000000000000000000000000..712462dc14738fc29b916d1f8a4ccc1d55865d95
--- /dev/null
+++ b/dist/chunk-FDUCRHYT.js
@@ -0,0 +1,85 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/etherscan.ts
+var _controllerutils = require('@metamask/controller-utils');
+async function fetchEtherscanTransactions({
+  address,
+  chainId,
+  fromBlock,
+  limit
+}) {
+  return await fetchTransactions("txlist", {
+    address,
+    chainId,
+    fromBlock,
+    limit
+  });
+}
+async function fetchEtherscanTokenTransactions({
+  address,
+  chainId,
+  fromBlock,
+  limit
+}) {
+  return await fetchTransactions("tokentx", {
+    address,
+    chainId,
+    fromBlock,
+    limit
+  });
+}
+async function fetchTransactions(action, {
+  address,
+  chainId,
+  fromBlock,
+  limit
+}) {
+  const urlParams = {
+    module: "account",
+    address,
+    startBlock: fromBlock?.toString(),
+    offset: limit?.toString(),
+    sort: "desc"
+  };
+  const etherscanTxUrl = getEtherscanApiUrl(chainId, {
+    ...urlParams,
+    action
+  });
+  _chunkS6VGOPUYjs.incomingTransactionsLogger.call(void 0, "Sending Etherscan request", etherscanTxUrl);
+  const response = await _controllerutils.handleFetch.call(void 0, 
+    etherscanTxUrl
+  );
+  return response;
+}
+function getEtherscanApiUrl(chainId, urlParams) {
+  const apiUrl = getEtherscanApiHost(chainId);
+  let url = `${apiUrl}/api?`;
+  for (const paramKey of Object.keys(urlParams)) {
+    const value = urlParams[paramKey];
+    if (!value) {
+      continue;
+    }
+    url += `${paramKey}=${value}&`;
+  }
+  url += "tag=latest&page=1";
+  return url;
+}
+function getEtherscanApiHost(chainId) {
+  const networkInfo = _chunkUGN7PBONjs.ETHERSCAN_SUPPORTED_NETWORKS[chainId];
+  if (!networkInfo) {
+    throw new Error(`Etherscan does not support chain with ID: ${chainId}`);
+  }
+  return `https://${networkInfo.subdomain}.${networkInfo.domain}`;
+}
+
+
+
+
+
+exports.fetchEtherscanTransactions = fetchEtherscanTransactions; exports.fetchEtherscanTokenTransactions = fetchEtherscanTokenTransactions; exports.getEtherscanApiHost = getEtherscanApiHost;
+//# sourceMappingURL=chunk-FDUCRHYT.js.map
\ No newline at end of file
diff --git a/dist/chunk-HXEBV7KA.js b/dist/chunk-HXEBV7KA.js
new file mode 100644
index 0000000000000000000000000000000000000000..2060267cf17bc219316635134ac6777598418f19
--- /dev/null
+++ b/dist/chunk-HXEBV7KA.js
@@ -0,0 +1,102 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/OracleLayer1GasFeeFlow.ts
+var _common = require('@ethereumjs/common');
+var _tx = require('@ethereumjs/tx');
+var _contracts = require('@ethersproject/contracts');
+var _providers = require('@ethersproject/providers');
+var _utils = require('@metamask/utils');
+var _lodash = require('lodash');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "optimisim-layer1-gas-fee-flow");
+var DUMMY_KEY = "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789";
+var GAS_PRICE_ORACLE_ABI = [
+  {
+    inputs: [{ internalType: "bytes", name: "_data", type: "bytes" }],
+    name: "getL1Fee",
+    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
+    stateMutability: "view",
+    type: "function"
+  }
+];
+var _oracleAddress, _signTransaction, _getOracleLayer1GasFee, getOracleLayer1GasFee_fn, _buildUnserializedTransaction, buildUnserializedTransaction_fn, _buildTransactionParams, buildTransactionParams_fn, _buildTransactionCommon, buildTransactionCommon_fn;
+var OracleLayer1GasFeeFlow = class {
+  constructor(oracleAddress, signTransaction) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getOracleLayer1GasFee);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildUnserializedTransaction);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildTransactionParams);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _buildTransactionCommon);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _oracleAddress, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _signTransaction, void 0);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _oracleAddress, oracleAddress);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _signTransaction, signTransaction ?? false);
+  }
+  async getLayer1Fee(request) {
+    try {
+      return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getOracleLayer1GasFee, getOracleLayer1GasFee_fn).call(this, request);
+    } catch (error) {
+      log("Failed to get oracle layer 1 gas fee", error);
+      throw new Error(`Failed to get oracle layer 1 gas fee`);
+    }
+  }
+};
+_oracleAddress = new WeakMap();
+_signTransaction = new WeakMap();
+_getOracleLayer1GasFee = new WeakSet();
+getOracleLayer1GasFee_fn = async function(request) {
+  const { provider, transactionMeta } = request;
+  const contract = new (0, _contracts.Contract)(
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _oracleAddress),
+    GAS_PRICE_ORACLE_ABI,
+    // Network controller provider type is incompatible with ethers provider
+    new (0, _providers.Web3Provider)(provider)
+  );
+  const serializedTransaction = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildUnserializedTransaction, buildUnserializedTransaction_fn).call(this, transactionMeta, _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _signTransaction)).serialize();
+  const result = await contract.getL1Fee(serializedTransaction);
+  if (result === void 0) {
+    throw new Error("No value returned from oracle contract");
+  }
+  return {
+    layer1Fee: result.toHexString()
+  };
+};
+_buildUnserializedTransaction = new WeakSet();
+buildUnserializedTransaction_fn = function(transactionMeta, sign) {
+  const txParams = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildTransactionParams, buildTransactionParams_fn).call(this, transactionMeta);
+  const common = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _buildTransactionCommon, buildTransactionCommon_fn).call(this, transactionMeta);
+  let unserializedTransaction = _tx.TransactionFactory.fromTxData(txParams, {
+    common
+  });
+  if (sign) {
+    const keyBuffer = Buffer.from(DUMMY_KEY, "hex");
+    unserializedTransaction = unserializedTransaction.sign(keyBuffer);
+  }
+  return unserializedTransaction;
+};
+_buildTransactionParams = new WeakSet();
+buildTransactionParams_fn = function(transactionMeta) {
+  return {
+    ..._lodash.omit.call(void 0, transactionMeta.txParams, "gas"),
+    gasLimit: transactionMeta.txParams.gas
+  };
+};
+_buildTransactionCommon = new WeakSet();
+buildTransactionCommon_fn = function(transactionMeta) {
+  const chainId = Number(transactionMeta.chainId);
+  return _common.Common.custom({
+    chainId,
+    defaultHardfork: _common.Hardfork.London
+  });
+};
+
+
+
+exports.OracleLayer1GasFeeFlow = OracleLayer1GasFeeFlow;
+//# sourceMappingURL=chunk-HXEBV7KA.js.map
\ No newline at end of file
diff --git a/dist/chunk-JAYYMCBQ.js b/dist/chunk-JAYYMCBQ.js
new file mode 100644
index 0000000000000000000000000000000000000000..ab556f373ffd9ffbd0786e7cbb12678fc2871bd2
--- /dev/null
+++ b/dist/chunk-JAYYMCBQ.js
@@ -0,0 +1,336 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkKT6UAKBBjs = require('./chunk-KT6UAKBB.js');
+
+
+
+
+var _chunkHMOSP33Fjs = require('./chunk-HMOSP33F.js');
+
+
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/simulation.ts
+var _abi = require('@ethersproject/abi');
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var _utils = require('@metamask/utils');
+var SupportedToken = /* @__PURE__ */ ((SupportedToken2) => {
+  SupportedToken2["ERC20"] = "erc20";
+  SupportedToken2["ERC721"] = "erc721";
+  SupportedToken2["ERC1155"] = "erc1155";
+  SupportedToken2["ERC20_WRAPPED"] = "erc20Wrapped";
+  SupportedToken2["ERC721_LEGACY"] = "erc721Legacy";
+  return SupportedToken2;
+})(SupportedToken || {});
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "simulation");
+var SUPPORTED_EVENTS = [
+  "Transfer",
+  "TransferSingle",
+  "TransferBatch",
+  "Deposit",
+  "Withdrawal"
+];
+var SUPPORTED_TOKEN_ABIS = {
+  ["erc20" /* ERC20 */]: {
+    abi: _metamaskethabis.abiERC20,
+    standard: "erc20" /* erc20 */
+  },
+  ["erc721" /* ERC721 */]: {
+    abi: _metamaskethabis.abiERC721,
+    standard: "erc721" /* erc721 */
+  },
+  ["erc1155" /* ERC1155 */]: {
+    abi: _metamaskethabis.abiERC1155,
+    standard: "erc1155" /* erc1155 */
+  },
+  ["erc20Wrapped" /* ERC20_WRAPPED */]: {
+    abi: _chunkUGN7PBONjs.ABI_SIMULATION_ERC20_WRAPPED,
+    standard: "erc20" /* erc20 */
+  },
+  ["erc721Legacy" /* ERC721_LEGACY */]: {
+    abi: _chunkUGN7PBONjs.ABI_SIMULATION_ERC721_LEGACY,
+    standard: "erc721" /* erc721 */
+  }
+};
+var REVERTED_ERRORS = ["execution reverted", "insufficient funds for gas"];
+async function getSimulationData(request) {
+  const { chainId, from, to, value, data } = request;
+  log("Getting simulation data", request);
+  try {
+    const response = await _chunkKT6UAKBBjs.simulateTransactions.call(void 0, chainId, {
+      transactions: [
+        {
+          data,
+          from,
+          maxFeePerGas: "0x0",
+          maxPriorityFeePerGas: "0x0",
+          to,
+          value
+        }
+      ],
+      withCallTrace: true,
+      withLogs: true
+    });
+    const transactionError = response.transactions?.[0]?.error;
+    if (transactionError) {
+      throw new (0, _chunkHMOSP33Fjs.SimulationError)(transactionError);
+    }
+    const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+    const events = getEvents(response);
+    log("Parsed events", events);
+    const tokenBalanceChanges = await getTokenBalanceChanges(request, events);
+    return {
+      nativeBalanceChange,
+      tokenBalanceChanges
+    };
+  } catch (error) {
+    log("Failed to get simulation data", error, request);
+    let simulationError = error;
+    if (REVERTED_ERRORS.some(
+      (revertErrorMessage) => simulationError.message?.includes(revertErrorMessage)
+    )) {
+      simulationError = new (0, _chunkHMOSP33Fjs.SimulationRevertedError)();
+    }
+    const { code, message } = simulationError;
+    return {
+      tokenBalanceChanges: [],
+      error: {
+        code,
+        message
+      }
+    };
+  }
+}
+function getNativeBalanceChange(userAddress, response) {
+  const transactionResponse = response.transactions[0];
+  if (!transactionResponse) {
+    return void 0;
+  }
+  const { stateDiff } = transactionResponse;
+  const previousBalance = stateDiff?.pre?.[userAddress]?.balance;
+  const newBalance = stateDiff?.post?.[userAddress]?.balance;
+  if (!previousBalance || !newBalance) {
+    return void 0;
+  }
+  return getSimulationBalanceChange(previousBalance, newBalance);
+}
+function getEvents(response) {
+  const logs = extractLogs(
+    response.transactions[0]?.callTrace ?? {}
+  );
+  log("Extracted logs", logs);
+  const interfaces = getContractInterfaces();
+  return logs.map((currentLog) => {
+    const event = parseLog(currentLog, interfaces);
+    if (!event) {
+      log("Failed to parse log", currentLog);
+      return void 0;
+    }
+    const inputs = event.abi.find((e) => e.name === event.name)?.inputs;
+    if (!inputs) {
+      log("Failed to find inputs for event", event);
+      return void 0;
+    }
+    const args = parseEventArgs(event.args, inputs);
+    return {
+      contractAddress: currentLog.address,
+      tokenStandard: event.standard,
+      name: event.name,
+      args,
+      abi: event.abi
+    };
+  }).filter((e) => e !== void 0);
+}
+function parseEventArgs(args, abiInputs) {
+  return args.reduce((result, arg, index) => {
+    const name = abiInputs[index].name.replace("_", "");
+    const value = parseEventArgValue(arg);
+    result[name] = value;
+    return result;
+  }, {});
+}
+function parseEventArgValue(value) {
+  if (Array.isArray(value)) {
+    return value.map(parseEventArgValue);
+  }
+  return (value.toHexString?.() ?? value).toLowerCase();
+}
+async function getTokenBalanceChanges(request, events) {
+  const balanceTransactionsByToken = getTokenBalanceTransactions(
+    request,
+    events
+  );
+  const balanceTransactions = [...balanceTransactionsByToken.values()];
+  log("Generated balance transactions", balanceTransactions);
+  if (!balanceTransactions.length) {
+    return [];
+  }
+  const response = await _chunkKT6UAKBBjs.simulateTransactions.call(void 0, request.chainId, {
+    transactions: [...balanceTransactions, request, ...balanceTransactions]
+  });
+  log("Balance simulation response", response);
+  if (response.transactions.length !== balanceTransactions.length * 2 + 1) {
+    throw new (0, _chunkHMOSP33Fjs.SimulationInvalidResponseError)();
+  }
+  return [...balanceTransactionsByToken.keys()].map((token, index) => {
+    const previousBalance = getValueFromBalanceTransaction(
+      request.from,
+      token,
+      response.transactions[index]
+    );
+    const newBalance = getValueFromBalanceTransaction(
+      request.from,
+      token,
+      response.transactions[index + balanceTransactions.length + 1]
+    );
+    const balanceChange = getSimulationBalanceChange(
+      previousBalance,
+      newBalance
+    );
+    if (!balanceChange) {
+      return void 0;
+    }
+    return {
+      ...token,
+      ...balanceChange
+    };
+  }).filter((change) => change !== void 0);
+}
+function getTokenBalanceTransactions(request, events) {
+  const tokenKeys = /* @__PURE__ */ new Set();
+  const userEvents = events.filter(
+    (event) => SUPPORTED_EVENTS.includes(event.name) && [event.args.from, event.args.to].includes(request.from)
+  );
+  log("Filtered user events", userEvents);
+  return userEvents.reduce((result, event) => {
+    const tokenIds = getEventTokenIds(event);
+    log("Extracted token ids", tokenIds);
+    for (const tokenId of tokenIds) {
+      const simulationToken = {
+        address: event.contractAddress,
+        standard: event.tokenStandard,
+        id: tokenId
+      };
+      const tokenKey = JSON.stringify(simulationToken);
+      if (tokenKeys.has(tokenKey)) {
+        log(
+          "Ignoring additional event with same contract and token ID",
+          simulationToken
+        );
+        continue;
+      }
+      tokenKeys.add(tokenKey);
+      const data = getBalanceTransactionData(
+        event.tokenStandard,
+        request.from,
+        tokenId
+      );
+      result.set(simulationToken, {
+        from: request.from,
+        to: event.contractAddress,
+        data
+      });
+    }
+    return result;
+  }, /* @__PURE__ */ new Map());
+}
+function getEventTokenIds(event) {
+  if (event.tokenStandard === "erc721" /* erc721 */) {
+    return [event.args.tokenId];
+  }
+  if (event.tokenStandard === "erc1155" /* erc1155 */ && event.name === "TransferSingle") {
+    return [event.args.id];
+  }
+  if (event.tokenStandard === "erc1155" /* erc1155 */ && event.name === "TransferBatch") {
+    return event.args.ids;
+  }
+  return [void 0];
+}
+function getValueFromBalanceTransaction(from, token, response) {
+  const normalizedReturn = normalizeReturnValue(response.return);
+  if (token.standard === "erc721" /* erc721 */) {
+    return normalizedReturn === from ? "0x1" : "0x0";
+  }
+  return normalizedReturn;
+}
+function getBalanceTransactionData(tokenStandard, from, tokenId) {
+  switch (tokenStandard) {
+    case "erc721" /* erc721 */:
+      return new (0, _abi.Interface)(_metamaskethabis.abiERC721).encodeFunctionData("ownerOf", [
+        tokenId
+      ]);
+    case "erc1155" /* erc1155 */:
+      return new (0, _abi.Interface)(_metamaskethabis.abiERC1155).encodeFunctionData("balanceOf", [
+        from,
+        tokenId
+      ]);
+    default:
+      return new (0, _abi.Interface)(_metamaskethabis.abiERC20).encodeFunctionData("balanceOf", [
+        from
+      ]);
+  }
+}
+function parseLog(eventLog, interfaces) {
+  const supportedTokens = Object.values(SupportedToken);
+  for (const token of supportedTokens) {
+    try {
+      const contractInterface = interfaces.get(token);
+      const { abi, standard } = SUPPORTED_TOKEN_ABIS[token];
+      return {
+        ...contractInterface.parseLog(eventLog),
+        abi,
+        standard
+      };
+    } catch (e) {
+      continue;
+    }
+  }
+  return void 0;
+}
+function extractLogs(call) {
+  const logs = call.logs ?? [];
+  const nestedCalls = call.calls ?? [];
+  return [
+    ...logs,
+    ...nestedCalls.map((nestedCall) => extractLogs(nestedCall)).flat()
+  ];
+}
+function getSimulationBalanceChange(previousBalance, newBalance) {
+  const differenceBN = _controllerutils.hexToBN.call(void 0, newBalance).sub(_controllerutils.hexToBN.call(void 0, previousBalance));
+  const isDecrease = differenceBN.isNeg();
+  const difference = _controllerutils.toHex.call(void 0, differenceBN.abs());
+  if (differenceBN.isZero()) {
+    log("Balance change is zero");
+    return void 0;
+  }
+  return {
+    previousBalance,
+    newBalance,
+    difference,
+    isDecrease
+  };
+}
+function normalizeReturnValue(value) {
+  return _controllerutils.toHex.call(void 0, _controllerutils.hexToBN.call(void 0, value));
+}
+function getContractInterfaces() {
+  const supportedTokens = Object.values(SupportedToken);
+  return new Map(
+    supportedTokens.map((tokenType) => {
+      const { abi } = SUPPORTED_TOKEN_ABIS[tokenType];
+      const contractInterface = new (0, _abi.Interface)(abi);
+      return [tokenType, contractInterface];
+    })
+  );
+}
+
+
+
+
+exports.SupportedToken = SupportedToken; exports.getSimulationData = getSimulationData;
+//# sourceMappingURL=chunk-JAYYMCBQ.js.map
\ No newline at end of file
diff --git a/dist/chunk-KAWQSLDO.js b/dist/chunk-KAWQSLDO.js
new file mode 100644
index 0000000000000000000000000000000000000000..0f5bfb1564e9a37973587396821221ce0599b352
--- /dev/null
+++ b/dist/chunk-KAWQSLDO.js
@@ -0,0 +1,2464 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkJAYYMCBQjs = require('./chunk-JAYYMCBQ.js');
+
+
+var _chunkSD6CWFDFjs = require('./chunk-SD6CWFDF.js');
+
+
+
+var _chunkVH47Q6TSjs = require('./chunk-VH47Q6TS.js');
+
+
+var _chunk7LXE4KHVjs = require('./chunk-7LXE4KHV.js');
+
+
+
+
+var _chunkV72C4MCRjs = require('./chunk-V72C4MCR.js');
+
+
+
+var _chunkQP75SWIQjs = require('./chunk-QP75SWIQ.js');
+
+
+
+var _chunkZNZEJDOEjs = require('./chunk-ZNZEJDOE.js');
+
+
+var _chunkDTDTOMTBjs = require('./chunk-DTDTOMTB.js');
+
+
+var _chunk5XQ2KRYLjs = require('./chunk-5XQ2KRYL.js');
+
+
+var _chunk5KMU2IATjs = require('./chunk-5KMU2IAT.js');
+
+
+var _chunkLNX4JTOLjs = require('./chunk-LNX4JTOL.js');
+
+
+var _chunk4RJXBKSRjs = require('./chunk-4RJXBKSR.js');
+
+
+var _chunkEQNKFFTMjs = require('./chunk-EQNKFFTM.js');
+
+
+
+var _chunkC2LNDHP4js = require('./chunk-C2LNDHP4.js');
+
+
+
+
+
+
+
+
+
+
+
+var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
+
+
+var _chunkPVLJMHKLjs = require('./chunk-PVLJMHKL.js');
+
+
+var _chunkQ7KPVQHQjs = require('./chunk-Q7KPVQHQ.js');
+
+
+var _chunkEQT25RSPjs = require('./chunk-EQT25RSP.js');
+
+
+var _chunkV6UIRCOFjs = require('./chunk-V6UIRCOF.js');
+
+
+
+var _chunk2XKEAKQGjs = require('./chunk-2XKEAKQG.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TransactionController.ts
+var _common = require('@ethereumjs/common');
+var _tx = require('@ethereumjs/tx');
+var _util = require('@ethereumjs/util');
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _networkcontroller = require('@metamask/network-controller');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _ethmethodregistry = require('eth-method-registry');
+var _events = require('events');
+var _lodash = require('lodash');
+var _noncetracker = require('nonce-tracker');
+var _uuid = require('uuid');
+var metadata = {
+  transactions: {
+    persist: true,
+    anonymous: false
+  },
+  methodData: {
+    persist: true,
+    anonymous: false
+  },
+  lastFetchedBlockNumbers: {
+    persist: true,
+    anonymous: false
+  }
+};
+var HARDFORK = _common.Hardfork.London;
+var CANCEL_RATE = 1.1;
+var SPEED_UP_RATE = 1.1;
+var controllerName = "TransactionController";
+var ApprovalState = /* @__PURE__ */ ((ApprovalState2) => {
+  ApprovalState2["Approved"] = "approved";
+  ApprovalState2["NotApproved"] = "not-approved";
+  ApprovalState2["SkippedViaBeforePublishHook"] = "skipped-via-before-publish-hook";
+  return ApprovalState2;
+})(ApprovalState || {});
+function getDefaultTransactionControllerState() {
+  return {
+    methodData: {},
+    transactions: [],
+    lastFetchedBlockNumbers: {}
+  };
+}
+var _internalEvents, _incomingTransactionOptions, _pendingTransactionOptions, _transactionHistoryLimit, _isSimulationEnabled, _multichainTrackingHelper, _createNonceTracker, createNonceTracker_fn, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn, _createPendingTransactionTracker, createPendingTransactionTracker_fn, _checkForPendingTransactionAndStartPolling, _stopAllTracking, stopAllTracking_fn, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn, _getGasFeeFlows, getGasFeeFlows_fn, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn, _updateTransactionInternal, updateTransactionInternal_fn, _checkIfTransactionParamsUpdated, checkIfTransactionParamsUpdated_fn, _onTransactionParamsUpdated, onTransactionParamsUpdated_fn, _updateSimulationData, updateSimulationData_fn, _onGasFeePollerTransactionUpdate, onGasFeePollerTransactionUpdate_fn;
+var TransactionController = class extends _basecontroller.BaseController {
+  /**
+   * Constructs a TransactionController.
+   *
+   * @param options - The controller options.
+   * @param options.blockTracker - The block tracker used to poll for new blocks data.
+   * @param options.disableHistory - Whether to disable storing history in transaction metadata.
+   * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.
+   * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.
+   * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
+   * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
+   * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+   * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
+   * @param options.getNetworkClientRegistry - Gets the network client registry.
+   * @param options.getNetworkState - Gets the state of the network controller.
+   * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.
+   * @param options.getSavedGasFees - Gets the saved gas fee config.
+   * @param options.getSelectedAddress - Gets the address of the currently selected account.
+   * @param options.incomingTransactions - Configuration options for incoming transaction support.
+   * @param options.isMultichainEnabled - Enable multichain support.
+   * @param options.isSimulationEnabled - Whether new transactions will be automatically simulated.
+   * @param options.messenger - The controller messenger.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.pendingTransactions - Configuration options for pending transaction support.
+   * @param options.provider - The provider used to create the underlying EthQuery instance.
+   * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
+   * @param options.sign - Function used to sign transactions.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.transactionHistoryLimit - Transaction history limit.
+   * @param options.hooks - The controller hooks.
+   */
+  constructor({
+    blockTracker,
+    disableHistory,
+    disableSendFlowHistory,
+    disableSwaps,
+    getCurrentAccountEIP1559Compatibility,
+    getCurrentNetworkEIP1559Compatibility,
+    getExternalPendingTransactions,
+    getGasFeeEstimates,
+    getNetworkClientRegistry,
+    getNetworkState,
+    getPermittedAccounts,
+    getSavedGasFees,
+    getSelectedAddress,
+    incomingTransactions = {},
+    isMultichainEnabled = false,
+    isSimulationEnabled,
+    messenger,
+    onNetworkStateChange,
+    pendingTransactions = {},
+    provider,
+    securityProviderRequest,
+    sign,
+    state,
+    transactionHistoryLimit = 40,
+    hooks
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultTransactionControllerState(),
+        ...state
+      }
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createNonceTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createIncomingTransactionHelper);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createPendingTransactionTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopAllTracking);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removeIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removePendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addPendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNonceTrackerPendingTransactions);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getGasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLayer1GasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionInternal);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkIfTransactionParamsUpdated);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onTransactionParamsUpdated);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateSimulationData);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onGasFeePollerTransactionUpdate);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _internalEvents, new (0, _events.EventEmitter)());
+    this.inProcessOfSigning = /* @__PURE__ */ new Set();
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _incomingTransactionOptions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pendingTransactionOptions, void 0);
+    this.signAbortCallbacks = /* @__PURE__ */ new Map();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _transactionHistoryLimit, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isSimulationEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _multichainTrackingHelper, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkForPendingTransactionAndStartPolling, () => {
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).checkForPendingTransactionAndStartPolling();
+    });
+    this.messagingSystem = messenger;
+    this.getNetworkState = getNetworkState;
+    this.isSendFlowHistoryDisabled = disableSendFlowHistory ?? false;
+    this.isHistoryDisabled = disableHistory ?? false;
+    this.isSwapsDisabled = disableSwaps ?? false;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isSimulationEnabled, isSimulationEnabled ?? (() => true));
+    this.registry = new (0, _ethmethodregistry.MethodRegistry)({ provider });
+    this.getSavedGasFees = getSavedGasFees ?? ((_chainId) => void 0);
+    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility ?? (() => Promise.resolve(true));
+    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
+    this.getGasFeeEstimates = getGasFeeEstimates || (() => Promise.resolve({}));
+    this.getPermittedAccounts = getPermittedAccounts;
+    this.getSelectedAddress = getSelectedAddress;
+    this.getExternalPendingTransactions = getExternalPendingTransactions ?? (() => []);
+    this.securityProviderRequest = securityProviderRequest;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _incomingTransactionOptions, incomingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pendingTransactionOptions, pendingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _transactionHistoryLimit, transactionHistoryLimit);
+    this.sign = sign;
+    this.afterSign = hooks?.afterSign ?? (() => true);
+    this.beforeApproveOnInit = hooks?.beforeApproveOnInit ?? (() => true);
+    this.beforeCheckPendingTransaction = hooks?.beforeCheckPendingTransaction ?? /* istanbul ignore next */
+    (() => true);
+    this.beforePublish = hooks?.beforePublish ?? (() => true);
+    this.getAdditionalSignArguments = hooks?.getAdditionalSignArguments ?? (() => []);
+    this.publish = hooks?.publish ?? (() => Promise.resolve({ transactionHash: void 0 }));
+    this.nonceTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _multichainTrackingHelper, new (0, _chunk5XQ2KRYLjs.MultichainTrackingHelper)({
+      isMultichainEnabled,
+      provider,
+      nonceTracker: this.nonceTracker,
+      incomingTransactionOptions: incomingTransactions,
+      findNetworkClientIdByChainId: (chainId) => {
+        return this.messagingSystem.call(
+          `NetworkController:findNetworkClientIdByChainId`,
+          chainId
+        );
+      },
+      getNetworkClientById: (networkClientId) => {
+        return this.messagingSystem.call(
+          `NetworkController:getNetworkClientById`,
+          networkClientId
+        );
+      },
+      getNetworkClientRegistry,
+      removeIncomingTransactionHelperListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).bind(this),
+      removePendingTransactionTrackerListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).bind(this),
+      createNonceTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).bind(this),
+      createIncomingTransactionHelper: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).bind(this),
+      createPendingTransactionTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).bind(this),
+      onNetworkStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "NetworkController:stateChange",
+          listener
+        );
+      }
+    }));
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).initialize();
+    const etherscanRemoteTransactionSource = new (0, _chunkEQT25RSPjs.EtherscanRemoteTransactionSource)({
+      includeTokenTransfers: incomingTransactions.includeTokenTransfers
+    });
+    this.incomingTransactionHelper = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).call(this, {
+      blockTracker,
+      etherscanRemoteTransactionSource
+    });
+    this.pendingTransactionTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    this.gasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getGasFeeFlows, getGasFeeFlows_fn).call(this);
+    this.layer1GasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn).call(this);
+    const gasFeePoller = new (0, _chunkV6UIRCOFjs.GasFeePoller)({
+      // Default gas fee polling is not yet supported by the clients
+      gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+      getGasFeeControllerEstimates: this.getGasFeeEstimates,
+      getProvider: (chainId, networkClientId) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getProvider({
+        networkClientId,
+        chainId
+      }),
+      getTransactions: () => this.state.transactions,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      onStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "TransactionController:stateChange",
+          listener
+        );
+      }
+    });
+    gasFeePoller.hub.on(
+      "transaction-updated",
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onGasFeePollerTransactionUpdate, onGasFeePollerTransactionUpdate_fn).bind(this)
+    );
+    this.messagingSystem.subscribe(
+      "TransactionController:stateChange",
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _checkForPendingTransactionAndStartPolling)
+    );
+    onNetworkStateChange(() => {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Detected network change", this.getChainId());
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      this.onBootCleanup();
+    });
+    this.onBootCleanup();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _checkForPendingTransactionAndStartPolling).call(this);
+  }
+  failTransaction(transactionMeta, error, actionId) {
+    const newTransactionMeta = _lodash.merge.call(void 0, {}, transactionMeta, {
+      error: _chunkUGFBA4GVjs.normalizeTxError.call(void 0, error),
+      status: "failed" /* failed */
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionFailed`, {
+      actionId,
+      error: error.message,
+      transactionMeta: newTransactionMeta
+    });
+    this.updateTransaction(
+      newTransactionMeta,
+      "TransactionController#failTransaction - Add error message and set status to failed"
+    );
+    this.onTransactionStatusChange(newTransactionMeta);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      newTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      newTransactionMeta
+    );
+  }
+  async registryLookup(fourBytePrefix) {
+    const registryMethod = await this.registry.lookup(fourBytePrefix);
+    if (!registryMethod) {
+      return {
+        registryMethod: "",
+        parsedRegistryMethod: { name: void 0, args: void 0 }
+      };
+    }
+    const parsedRegistryMethod = this.registry.parse(registryMethod);
+    return { registryMethod, parsedRegistryMethod };
+  }
+  /**
+   * Stops polling and removes listeners to prepare the controller for garbage collection.
+   */
+  destroy() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopAllTracking, stopAllTracking_fn).call(this);
+  }
+  /**
+   * Handle new method data request.
+   *
+   * @param fourBytePrefix - The method prefix.
+   * @returns The method data object corresponding to the given signature prefix.
+   */
+  async handleMethodData(fourBytePrefix) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      const { methodData } = this.state;
+      const knownMethod = Object.keys(methodData).find(
+        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix
+      );
+      if (knownMethod) {
+        return methodData[fourBytePrefix];
+      }
+      const registry = await this.registryLookup(fourBytePrefix);
+      this.update((state) => {
+        state.methodData[fourBytePrefix] = registry;
+      });
+      return registry;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a new unapproved transaction to state. Parameters will be validated, a
+   * unique transaction id will be generated, and gas and gasPrice will be calculated
+   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
+   *
+   * @param txParams - Standard parameters for an Ethereum transaction.
+   * @param opts - Additional options to control how the transaction is added.
+   * @param opts.actionId - Unique ID to prevent duplicate requests.
+   * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+   * @param opts.method - RPC method that requested the transaction.
+   * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+   * @param opts.requireApproval - Whether the transaction requires approval by the user, defaults to true unless explicitly disabled.
+   * @param opts.securityAlertResponse - Response from security validator.
+   * @param opts.sendFlowHistory - The sendFlowHistory entries to add.
+   * @param opts.type - Type of transaction to add, such as 'cancel' or 'swap'.
+   * @param opts.swaps - Options for swaps transactions.
+   * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.
+   * @param opts.swaps.meta - Metadata for swap transaction.
+   * @param opts.networkClientId - The id of the network client for this transaction.
+   * @returns Object containing a promise resolving to the transaction hash if approved.
+   */
+  async addTransaction(txParams, {
+    actionId,
+    deviceConfirmedOn,
+    method,
+    origin,
+    requireApproval,
+    securityAlertResponse,
+    sendFlowHistory,
+    swaps = {},
+    type,
+    networkClientId
+  } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Adding transaction", txParams);
+    txParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, txParams);
+    if (networkClientId && !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).has(networkClientId)) {
+      throw new Error(
+        "The networkClientId for this transaction could not be found"
+      );
+    }
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(
+      networkClientId
+    );
+    _chunkVH47Q6TSjs.validateTxParams.call(void 0, txParams, isEIP1559Compatible);
+    if (origin) {
+      await _chunkVH47Q6TSjs.validateTransactionOrigin.call(void 0, 
+        await this.getPermittedAccounts(origin),
+        this.getSelectedAddress(),
+        txParams.from,
+        origin
+      );
+    }
+    const dappSuggestedGasFees = this.generateDappSuggestedGasFees(
+      txParams,
+      origin
+    );
+    const chainId = this.getChainId(networkClientId);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    const transactionType = type ?? (await _chunkSD6CWFDFjs.determineTransactionType.call(void 0, txParams, ethQuery)).type;
+    const existingTransactionMeta = this.getTransactionWithActionId(actionId);
+    let addedTransactionMeta = existingTransactionMeta ? _lodash.cloneDeep.call(void 0, existingTransactionMeta) : {
+      // Add actionId to txMeta to check if same actionId is seen again
+      actionId,
+      chainId,
+      dappSuggestedGasFees,
+      deviceConfirmedOn,
+      id: _uuid.v1.call(void 0, ),
+      origin,
+      securityAlertResponse,
+      status: "unapproved" /* unapproved */,
+      time: Date.now(),
+      txParams,
+      userEditedGasLimit: false,
+      verifiedOnBlockchain: false,
+      type: transactionType,
+      networkClientId
+    };
+    await this.updateGasProperties(addedTransactionMeta);
+    if (!existingTransactionMeta) {
+      if (method && this.securityProviderRequest) {
+        const securityProviderResponse = await this.securityProviderRequest(
+          addedTransactionMeta,
+          method
+        );
+        addedTransactionMeta.securityProviderResponse = securityProviderResponse;
+      }
+      if (!this.isSendFlowHistoryDisabled) {
+        addedTransactionMeta.sendFlowHistory = sendFlowHistory ?? [];
+      }
+      if (!this.isHistoryDisabled) {
+        addedTransactionMeta = _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, addedTransactionMeta);
+      }
+      addedTransactionMeta = _chunkC2LNDHP4js.updateSwapsTransaction.call(void 0, 
+        addedTransactionMeta,
+        transactionType,
+        swaps,
+        {
+          isSwapsDisabled: this.isSwapsDisabled,
+          cancelTransaction: this.cancelTransaction.bind(this),
+          messenger: this.messagingSystem
+        }
+      );
+      this.addMetadata(addedTransactionMeta);
+      if (requireApproval !== false) {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateSimulationData, updateSimulationData_fn).call(this, addedTransactionMeta);
+      } else {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping simulation as approval not required");
+      }
+      this.messagingSystem.publish(
+        `${controllerName}:unapprovedTransactionAdded`,
+        addedTransactionMeta
+      );
+    }
+    return {
+      result: this.processApproval(addedTransactionMeta, {
+        isExisting: Boolean(existingTransactionMeta),
+        requireApproval,
+        actionId
+      }),
+      transactionMeta: addedTransactionMeta
+    };
+  }
+  startIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.start();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).startIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.stop();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopAllIncomingTransactionPolling() {
+    this.incomingTransactionHelper.stop();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllIncomingTransactionPolling();
+  }
+  async updateIncomingTransactions(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      await this.incomingTransactionHelper.update();
+      return;
+    }
+    await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).updateIncomingTransactions(
+      networkClientIds
+    );
+  }
+  /**
+   * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param gasValues - The gas values to use for the cancellation transaction.
+   * @param options - The options for the cancellation transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests.
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async stopTransaction(transactionId, gasValues, {
+    estimatedBaseFee,
+    actionId
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating cancel transaction", transactionId, gasValues);
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      CANCEL_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      CANCEL_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      CANCEL_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const newTxParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    } : {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      newTxParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = newTxParams.maxFeePerGas ?? newTxParams.gasPrice;
+    const oldFee = newTxParams.maxFeePerGas ? transactionMeta.txParams.maxFeePerGas : transactionMeta.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting cancel transaction", {
+      oldFee,
+      newFee,
+      txParams: newTxParams
+    });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const cancelTransactionMeta = {
+      actionId,
+      chainId: transactionMeta.chainId,
+      networkClientId: transactionMeta.networkClientId,
+      estimatedBaseFee,
+      hash,
+      id: _uuid.v1.call(void 0, ),
+      originalGasEstimate: transactionMeta.txParams.gas,
+      status: "submitted" /* submitted */,
+      time: Date.now(),
+      type: "cancel" /* cancel */,
+      txParams: newTxParams
+    };
+    this.addMetadata(cancelTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      cancelTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      cancelTransactionMeta
+    );
+  }
+  /**
+   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.
+   *
+   * @param transactionId - The ID of the transaction to speed up.
+   * @param gasValues - The gas values to use for the speed up transaction.
+   * @param options - The options for the speed up transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async speedUpTransaction(transactionId, gasValues, {
+    actionId,
+    estimatedBaseFee
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating speed up transaction", transactionId, gasValues);
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      SPEED_UP_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */
+    } : {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const transactionMetaWithRsv = await this.updateTransactionMetaRSV(
+      transactionMeta,
+      signedTx
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = txParams.maxFeePerGas ?? txParams.gasPrice;
+    const oldFee = txParams.maxFeePerGas ? transactionMetaWithRsv.txParams.maxFeePerGas : transactionMetaWithRsv.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting speed up transaction", { oldFee, newFee, txParams });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const baseTransactionMeta = {
+      ...transactionMetaWithRsv,
+      estimatedBaseFee,
+      id: _uuid.v1.call(void 0, ),
+      time: Date.now(),
+      hash,
+      actionId,
+      originalGasEstimate: transactionMeta.txParams.gas,
+      type: "retry" /* retry */,
+      originalType: transactionMeta.type
+    };
+    const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        maxFeePerGas: newMaxFeePerGas,
+        maxPriorityFeePerGas: newMaxPriorityFeePerGas
+      }
+    } : {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        gasPrice: newGasPrice
+      }
+    };
+    this.addMetadata(newTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:speedupTransactionAdded`,
+      newTransactionMeta
+    );
+  }
+  /**
+   * Estimates required gas for a given transaction.
+   *
+   * @param transaction - The transaction to estimate gas for.
+   * @param networkClientId - The network client id to use for the estimate.
+   * @returns The gas and gas price.
+   */
+  async estimateGas(transaction, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { estimatedGas, simulationFails } = await _chunkV72C4MCRjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    return { gas: estimatedGas, simulationFails };
+  }
+  /**
+   * Estimates required gas for a given transaction and add additional gas buffer with the given multiplier.
+   *
+   * @param transaction - The transaction params to estimate gas for.
+   * @param multiplier - The multiplier to use for the gas buffer.
+   * @param networkClientId - The network client id to use for the estimate.
+   */
+  async estimateGasBuffered(transaction, multiplier, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { blockGasLimit, estimatedGas, simulationFails } = await _chunkV72C4MCRjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    const gas = _chunkV72C4MCRjs.addGasBuffer.call(void 0, estimatedGas, blockGasLimit, multiplier);
+    return {
+      gas,
+      simulationFails
+    };
+  }
+  /**
+   * Updates an existing transaction in state.
+   *
+   * @param transactionMeta - The new transaction to store in state.
+   * @param note - A note or update reason to include in the transaction history.
+   */
+  updateTransaction(transactionMeta, note) {
+    const { id: transactionId } = transactionMeta;
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, { transactionId, note, skipHistory: this.isHistoryDisabled }, () => ({ ...transactionMeta }));
+  }
+  /**
+   * Update the security alert response for a transaction.
+   *
+   * @param transactionId - ID of the transaction.
+   * @param securityAlertResponse - The new security alert response for the transaction.
+   */
+  updateSecurityAlertResponse(transactionId, securityAlertResponse) {
+    if (!securityAlertResponse) {
+      throw new Error(
+        "updateSecurityAlertResponse: securityAlertResponse should not be null"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update security alert response as no transaction metadata found`
+      );
+    }
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      securityAlertResponse
+    };
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updatesecurityAlertResponse - securityAlertResponse updated`
+    );
+  }
+  /**
+   * Removes all transactions from state, optionally based on the current network.
+   *
+   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the
+   * current network. If `true`, all transactions are wiped.
+   * @param address - If specified, only transactions originating from this address will be
+   * wiped on current network.
+   */
+  wipeTransactions(ignoreNetwork, address) {
+    if (ignoreNetwork && !address) {
+      this.update((state) => {
+        state.transactions = [];
+      });
+      return;
+    }
+    const currentChainId = this.getChainId();
+    const newTransactions = this.state.transactions.filter(
+      ({ chainId, txParams }) => {
+        const isMatchingNetwork = ignoreNetwork || chainId === currentChainId;
+        if (!isMatchingNetwork) {
+          return true;
+        }
+        const isMatchingAddress = !address || txParams.from?.toLowerCase() === address.toLowerCase();
+        return !isMatchingAddress;
+      }
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(newTransactions);
+    });
+  }
+  /**
+   * Adds external provided transaction to state as confirmed transaction.
+   *
+   * @param transactionMeta - TransactionMeta to add transactions.
+   * @param transactionReceipt - TransactionReceipt of the external transaction.
+   * @param baseFeePerGas - Base fee per gas of the external transaction.
+   */
+  async confirmExternalTransaction(transactionMeta, transactionReceipt, baseFeePerGas) {
+    const newTransactionMeta = this.addExternalTransaction(transactionMeta);
+    try {
+      const transactionId = newTransactionMeta.id;
+      const updatedTransactionMeta = {
+        ...newTransactionMeta,
+        status: "confirmed" /* confirmed */,
+        txReceipt: transactionReceipt
+      };
+      if (baseFeePerGas) {
+        updatedTransactionMeta.baseFeePerGas = baseFeePerGas;
+      }
+      this.markNonceDuplicatesDropped(transactionId);
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:confirmExternalTransaction - Add external transaction`
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      this.updatePostBalance(updatedTransactionMeta);
+      this.messagingSystem.publish(
+        `${controllerName}:transactionConfirmed`,
+        updatedTransactionMeta
+      );
+    } catch (error) {
+      console.error("Failed to confirm external transaction", error);
+    }
+  }
+  /**
+   * Append new send flow history to a transaction.
+   *
+   * @param transactionID - The ID of the transaction to update.
+   * @param currentSendFlowHistoryLength - The length of the current sendFlowHistory array.
+   * @param sendFlowHistoryToAdd - The sendFlowHistory entries to add.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionSendFlowHistory(transactionID, currentSendFlowHistoryLength, sendFlowHistoryToAdd) {
+    if (this.isSendFlowHistoryDisabled) {
+      throw new Error(
+        "Send flow history is disabled for the current transaction controller"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionID);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update send flow history as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionSendFlowHistory"
+    );
+    const sendFlowHistory = transactionMeta.sendFlowHistory ?? [];
+    if (currentSendFlowHistoryLength === sendFlowHistory.length) {
+      const updatedTransactionMeta = {
+        ...transactionMeta,
+        sendFlowHistory: [...sendFlowHistory, ...sendFlowHistoryToAdd]
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:updateTransactionSendFlowHistory - sendFlowHistory updated`
+      );
+    }
+    return this.getTransaction(transactionID);
+  }
+  /**
+   * Update the gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param gasValues - Gas values to update.
+   * @param gasValues.gas - Same as transaction.gasLimit.
+   * @param gasValues.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param gasValues.gasPrice - Price per gas for legacy transactions.
+   * @param gasValues.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @param gasValues.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param gasValues.estimateUsed - Which estimate level was used.
+   * @param gasValues.estimateSuggested - Which estimate level that the API suggested.
+   * @param gasValues.defaultGasEstimates - The default estimate for gas.
+   * @param gasValues.originalGasEstimate - Original estimate for gas.
+   * @param gasValues.userEditedGasLimit - The gas limit supplied by user.
+   * @param gasValues.userFeeLevel - Estimate level user selected.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionGasFees(transactionId, {
+    defaultGasEstimates,
+    estimateUsed,
+    estimateSuggested,
+    gas,
+    gasLimit,
+    gasPrice,
+    maxPriorityFeePerGas,
+    maxFeePerGas,
+    originalGasEstimate,
+    userEditedGasLimit,
+    userFeeLevel
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionGasFees"
+    );
+    let transactionGasFees = {
+      txParams: {
+        gas,
+        gasLimit,
+        gasPrice,
+        maxPriorityFeePerGas,
+        maxFeePerGas
+      },
+      defaultGasEstimates,
+      estimateUsed,
+      estimateSuggested,
+      originalGasEstimate,
+      userEditedGasLimit,
+      userFeeLevel
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionGasFees.txParams = _lodash.pickBy.call(void 0, transactionGasFees.txParams);
+    transactionGasFees = _lodash.pickBy.call(void 0, transactionGasFees);
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionGasFees);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updateTransactionGasFees - gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  /**
+   * Update the previous gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param previousGas - Previous gas values to update.
+   * @param previousGas.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param previousGas.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param previousGas.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @returns The updated transactionMeta.
+   */
+  updatePreviousGasParams(transactionId, {
+    gasLimit,
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updatePreviousGasParams");
+    const transactionPreviousGas = {
+      previousGas: {
+        gasLimit,
+        maxFeePerGas,
+        maxPriorityFeePerGas
+      }
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionPreviousGas.previousGas = _lodash.pickBy.call(void 0, 
+      transactionPreviousGas.previousGas
+    );
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionPreviousGas);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updatePreviousGasParams - Previous gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  async getNonceLock(address, networkClientId) {
+    return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(
+      address,
+      networkClientId
+    );
+  }
+  /**
+   * Updates the editable parameters of a transaction.
+   *
+   * @param txId - The ID of the transaction to update.
+   * @param params - The editable parameters to update.
+   * @param params.data - Data to pass with the transaction.
+   * @param params.gas - Maximum number of units of gas to use for the transaction.
+   * @param params.gasPrice - Price per gas for legacy transactions.
+   * @param params.from - Address to send the transaction from.
+   * @param params.to - Address to send the transaction to.
+   * @param params.value - Value associated with the transaction.
+   * @returns The updated transaction metadata.
+   */
+  async updateEditableParams(txId, {
+    data,
+    gas,
+    gasPrice,
+    from,
+    to,
+    value
+  }) {
+    const transactionMeta = this.getTransaction(txId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update editable params as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updateEditableParams");
+    const editableParams = {
+      txParams: {
+        data,
+        from,
+        to,
+        value,
+        gas,
+        gasPrice
+      }
+    };
+    editableParams.txParams = _lodash.pickBy.call(void 0, 
+      editableParams.txParams
+    );
+    const updatedTransaction = _lodash.merge.call(void 0, {}, transactionMeta, editableParams);
+    const provider = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getProvider({
+      chainId: transactionMeta.chainId,
+      networkClientId: transactionMeta.networkClientId
+    });
+    const ethQuery = new (0, _ethquery2.default)(provider);
+    const { type } = await _chunkSD6CWFDFjs.determineTransactionType.call(void 0, 
+      updatedTransaction.txParams,
+      ethQuery
+    );
+    updatedTransaction.type = type;
+    await _chunk2XKEAKQGjs.updateTransactionLayer1GasFee.call(void 0, {
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      provider,
+      transactionMeta: updatedTransaction
+    });
+    this.updateTransaction(
+      updatedTransaction,
+      `Update Editable Params for ${txId}`
+    );
+    return this.getTransaction(txId);
+  }
+  /**
+   * Signs and returns the raw transaction data for provided transaction params list.
+   *
+   * @param listOfTxParams - The list of transaction params to approve.
+   * @param opts - Options bag.
+   * @param opts.hasNonce - Whether the transactions already have a nonce.
+   * @returns The raw transactions.
+   */
+  async approveTransactionsWithSameNonce(listOfTxParams = [], { hasNonce } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Approving transactions with same nonce", {
+      transactions: listOfTxParams
+    });
+    if (listOfTxParams.length === 0) {
+      return "";
+    }
+    const initialTx = listOfTxParams[0];
+    const common = this.getCommonConfiguration(initialTx.chainId);
+    let networkClientId;
+    try {
+      networkClientId = this.messagingSystem.call(
+        `NetworkController:findNetworkClientIdByChainId`,
+        initialTx.chainId
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "failed to find networkClientId from chainId", err);
+    }
+    const initialTxAsEthTx = _tx.TransactionFactory.fromTxData(initialTx, {
+      common
+    });
+    const initialTxAsSerializedHex = _util.bufferToHex.call(void 0, initialTxAsEthTx.serialize());
+    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
+      return "";
+    }
+    this.inProcessOfSigning.add(initialTxAsSerializedHex);
+    let rawTransactions, nonceLock;
+    try {
+      const fromAddress = initialTx.from;
+      const requiresNonce = hasNonce !== true;
+      nonceLock = requiresNonce ? await this.getNonceLock(fromAddress, networkClientId) : void 0;
+      const nonce = nonceLock ? _utils.add0x.call(void 0, nonceLock.nextNonce.toString(16)) : initialTx.nonce;
+      if (nonceLock) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Using nonce from nonce tracker", nonce, nonceLock.nonceDetails);
+      }
+      rawTransactions = await Promise.all(
+        listOfTxParams.map((txParams) => {
+          txParams.nonce = nonce;
+          return this.signExternalTransaction(txParams.chainId, txParams);
+        })
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while signing transactions with same nonce", err);
+      throw err;
+    } finally {
+      nonceLock?.releaseLock();
+      this.inProcessOfSigning.delete(initialTxAsSerializedHex);
+    }
+    return rawTransactions;
+  }
+  /**
+   * Update a custodial transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param options - The custodial transaction options to update.
+   * @param options.errorMessage - The error message to be assigned in case transaction status update to failed.
+   * @param options.hash - The new hash value to be assigned.
+   * @param options.status - The new status value to be assigned.
+   */
+  updateCustodialTransaction(transactionId, {
+    errorMessage,
+    hash,
+    status
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update custodial transaction as no transaction metadata found`
+      );
+    }
+    if (!transactionMeta.custodyId) {
+      throw new Error("Transaction must be a custodian transaction");
+    }
+    if (status && ![
+      "submitted" /* submitted */,
+      "signed" /* signed */,
+      "failed" /* failed */
+    ].includes(status)) {
+      throw new Error(
+        `Cannot update custodial transaction with status: ${status}`
+      );
+    }
+    const updatedTransactionMeta = _lodash.merge.call(void 0, 
+      {},
+      transactionMeta,
+      _lodash.pickBy.call(void 0, { hash, status })
+    );
+    if (status === "submitted" /* submitted */) {
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+    }
+    if (status === "failed" /* failed */) {
+      updatedTransactionMeta.error = _chunkUGFBA4GVjs.normalizeTxError.call(void 0, new Error(errorMessage));
+    }
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updateCustodialTransaction - Custodial transaction updated`
+    );
+    if (["submitted" /* submitted */, "failed" /* failed */].includes(
+      status
+    )) {
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+    }
+  }
+  /**
+   * Creates approvals for all unapproved transactions persisted.
+   */
+  initApprovals() {
+    const chainId = this.getChainId();
+    const unapprovedTxs = this.state.transactions.filter(
+      (transaction) => transaction.status === "unapproved" /* unapproved */ && transaction.chainId === chainId && !transaction.isUserOperation
+    );
+    for (const txMeta of unapprovedTxs) {
+      this.processApproval(txMeta, {
+        shouldShowRequest: false
+      }).catch((error) => {
+        if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+          return;
+        }
+        console.error("Error during persisted transaction approval", error);
+      });
+    }
+  }
+  /**
+   * Search transaction metadata for matching entries.
+   *
+   * @param opts - Options bag.
+   * @param opts.searchCriteria - An object containing values or functions for transaction properties to filter transactions with.
+   * @param opts.initialList - The transactions to search. Defaults to the current state.
+   * @param opts.filterToCurrentNetwork - Whether to filter the results to the current network. Defaults to true.
+   * @param opts.limit - The maximum number of transactions to return. No limit by default.
+   * @returns An array of transactions matching the provided options.
+   */
+  getTransactions({
+    searchCriteria = {},
+    initialList,
+    filterToCurrentNetwork = true,
+    limit
+  } = {}) {
+    const chainId = this.getChainId();
+    const predicateMethods = _lodash.mapValues.call(void 0, searchCriteria, (predicate) => {
+      return typeof predicate === "function" ? predicate : (
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        (v) => v === predicate
+      );
+    });
+    const transactionsToFilter = initialList ?? this.state.transactions;
+    const filteredTransactions = _lodash.sortBy.call(void 0, 
+      _lodash.pickBy.call(void 0, transactionsToFilter, (transaction) => {
+        if (filterToCurrentNetwork && transaction.chainId !== chainId) {
+          return false;
+        }
+        for (const [key, predicate] of Object.entries(predicateMethods)) {
+          if (key in transaction.txParams) {
+            if (predicate(transaction.txParams[key]) === false) {
+              return false;
+            }
+          } else if (predicate(transaction[key]) === false) {
+            return false;
+          }
+        }
+        return true;
+      }),
+      "time"
+    );
+    if (limit !== void 0) {
+      const nonces = /* @__PURE__ */ new Set();
+      const txs = [];
+      for (let i = filteredTransactions.length - 1; i > -1; i--) {
+        const txMeta = filteredTransactions[i];
+        const { nonce } = txMeta.txParams;
+        if (!nonces.has(nonce)) {
+          if (nonces.size < limit) {
+            nonces.add(nonce);
+          } else {
+            continue;
+          }
+        }
+        txs.unshift(txMeta);
+      }
+      return txs;
+    }
+    return filteredTransactions;
+  }
+  /**
+   * Determine the layer 1 gas fee for the given transaction parameters.
+   *
+   * @param request - The request object.
+   * @param request.transactionParams - The transaction parameters to estimate the layer 1 gas fee for.
+   * @param request.chainId - The ID of the chain where the transaction will be executed.
+   * @param request.networkClientId - The ID of a specific network client to process the transaction.
+   */
+  async getLayer1GasFee({
+    transactionParams,
+    chainId,
+    networkClientId
+  }) {
+    const provider = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getProvider({
+      networkClientId,
+      chainId
+    });
+    return await _chunk2XKEAKQGjs.getTransactionLayer1GasFee.call(void 0, {
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      provider,
+      transactionMeta: {
+        txParams: transactionParams,
+        chainId
+      }
+    });
+  }
+  async signExternalTransaction(chainId, transactionParams) {
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const normalizedTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionParams);
+    const type = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, normalizedTransactionParams) ? "0x2" /* feeMarket */ : "0x0" /* legacy */;
+    const updatedTransactionParams = {
+      ...normalizedTransactionParams,
+      type,
+      gasLimit: normalizedTransactionParams.gas,
+      chainId
+    };
+    const { from } = updatedTransactionParams;
+    const common = this.getCommonConfiguration(chainId);
+    const unsignedTransaction = _tx.TransactionFactory.fromTxData(
+      updatedTransactionParams,
+      { common }
+    );
+    const signedTransaction = await this.sign(unsignedTransaction, from);
+    const rawTransaction = _util.bufferToHex.call(void 0, signedTransaction.serialize());
+    return rawTransaction;
+  }
+  /**
+   * Removes unapproved transactions from state.
+   */
+  clearUnapprovedTransactions() {
+    const transactions = this.state.transactions.filter(
+      ({ status }) => status !== "unapproved" /* unapproved */
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+  }
+  /**
+   * Stop the signing process for a specific transaction.
+   * Throws an error causing the transaction status to be set to failed.
+   * @param transactionId - The ID of the transaction to stop signing.
+   */
+  abortTransactionSigning(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(`Cannot abort signing as no transaction metadata found`);
+    }
+    const abortCallback = this.signAbortCallbacks.get(transactionId);
+    if (!abortCallback) {
+      throw new Error(
+        `Cannot abort signing as transaction is not waiting for signing`
+      );
+    }
+    abortCallback();
+    this.signAbortCallbacks.delete(transactionId);
+  }
+  addMetadata(transactionMeta) {
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        transactionMeta
+      ]);
+    });
+  }
+  async updateGasProperties(transactionMeta) {
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(transactionMeta.networkClientId) && transactionMeta.txParams.type !== "0x0" /* legacy */;
+    const { networkClientId, chainId } = transactionMeta;
+    const isCustomNetwork = networkClientId ? this.messagingSystem.call(
+      `NetworkController:getNetworkClientById`,
+      networkClientId
+    ).configuration.type === _networkcontroller.NetworkClientType.Custom : this.getNetworkState().providerConfig.type === _controllerutils.NetworkType.rpc;
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    const provider = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getProvider({
+      networkClientId,
+      chainId
+    });
+    await _chunkV72C4MCRjs.updateGas.call(void 0, {
+      ethQuery,
+      chainId,
+      isCustomNetwork,
+      txMeta: transactionMeta
+    });
+    await _chunkEQNKFFTMjs.updateGasFees.call(void 0, {
+      eip1559: isEIP1559Compatible,
+      ethQuery,
+      gasFeeFlows: this.gasFeeFlows,
+      getGasFeeEstimates: this.getGasFeeEstimates,
+      getSavedGasFees: this.getSavedGasFees.bind(this),
+      txMeta: transactionMeta
+    });
+    await _chunk2XKEAKQGjs.updateTransactionLayer1GasFee.call(void 0, {
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      provider,
+      transactionMeta
+    });
+  }
+  onBootCleanup() {
+    this.submitApprovedTransactions();
+  }
+  /**
+   * Force submit approved transactions for all chains.
+   */
+  submitApprovedTransactions() {
+    const approvedTransactions = this.state.transactions.filter(
+      (transaction) => transaction.status === "approved" /* approved */
+    );
+    for (const transactionMeta of approvedTransactions) {
+      if (this.beforeApproveOnInit(transactionMeta)) {
+        this.approveTransaction(transactionMeta.id).catch((error) => {
+          console.error("Error while submitting persisted transaction", error);
+        });
+      }
+    }
+  }
+  async processApproval(transactionMeta, {
+    isExisting = false,
+    requireApproval,
+    shouldShowRequest = true,
+    actionId
+  }) {
+    const transactionId = transactionMeta.id;
+    let resultCallbacks;
+    const { meta, isCompleted } = this.isTransactionCompleted(transactionId);
+    const finishedPromise = isCompleted ? Promise.resolve(meta) : this.waitForTransactionFinished(transactionId);
+    if (meta && !isExisting && !isCompleted) {
+      try {
+        if (requireApproval !== false) {
+          const acceptResult = await this.requestApproval(transactionMeta, {
+            shouldShowRequest
+          });
+          resultCallbacks = acceptResult.resultCallbacks;
+          const approvalValue = acceptResult.value;
+          const updatedTransaction = approvalValue?.txMeta;
+          if (updatedTransaction) {
+            _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating transaction with approval data", {
+              customNonce: updatedTransaction.customNonceValue,
+              params: updatedTransaction.txParams
+            });
+            this.updateTransaction(
+              updatedTransaction,
+              "TransactionController#processApproval - Updated with approval data"
+            );
+          }
+        }
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          const approvalResult = await this.approveTransaction(transactionId);
+          if (approvalResult === "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */ && resultCallbacks) {
+            resultCallbacks.success();
+          }
+          const updatedTransactionMeta = this.getTransaction(
+            transactionId
+          );
+          this.messagingSystem.publish(
+            `${controllerName}:transactionApproved`,
+            {
+              transactionMeta: updatedTransactionMeta,
+              actionId
+            }
+          );
+        }
+      } catch (error) {
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+            this.cancelTransaction(transactionId, actionId);
+            throw _rpcerrors.providerErrors.userRejectedRequest(
+              "MetaMask Tx Signature: User denied transaction signature."
+            );
+          } else {
+            this.failTransaction(meta, error, actionId);
+          }
+        }
+      }
+    }
+    const finalMeta = await finishedPromise;
+    switch (finalMeta?.status) {
+      case "failed" /* failed */:
+        resultCallbacks?.error(finalMeta.error);
+        throw _rpcerrors.rpcErrors.internal(finalMeta.error.message);
+      case "submitted" /* submitted */:
+        resultCallbacks?.success();
+        return finalMeta.hash;
+      default:
+        const internalError = _rpcerrors.rpcErrors.internal(
+          `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(
+            finalMeta || transactionId
+          )}`
+        );
+        resultCallbacks?.error(internalError);
+        throw internalError;
+    }
+  }
+  /**
+   * Approves a transaction and updates it's status in state. If this is not a
+   * retry transaction, a nonce will be generated. The transaction is signed
+   * using the sign configuration property, then published to the blockchain.
+   * A `<tx.id>:finished` hub event is fired after success or failure.
+   *
+   * @param transactionId - The ID of the transaction to approve.
+   */
+  async approveTransaction(transactionId) {
+    const { transactions } = this.state;
+    const releaseLock = await this.mutex.acquire();
+    const index = transactions.findIndex(({ id }) => transactionId === id);
+    const transactionMeta = transactions[index];
+    const updatedTransactionMeta = _lodash.cloneDeep.call(void 0, transactionMeta);
+    const {
+      txParams: { from },
+      networkClientId
+    } = transactionMeta;
+    let releaseNonceLock;
+    try {
+      if (!this.sign) {
+        releaseLock();
+        this.failTransaction(
+          transactionMeta,
+          new Error("No sign method defined.")
+        );
+        return "not-approved" /* NotApproved */;
+      } else if (!transactionMeta.chainId) {
+        releaseLock();
+        this.failTransaction(transactionMeta, new Error("No chainId defined."));
+        return "not-approved" /* NotApproved */;
+      }
+      if (this.inProcessOfSigning.has(transactionId)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping approval as signing in progress", transactionId);
+        return "not-approved" /* NotApproved */;
+      }
+      const [nonce, releaseNonce] = await _chunkZNZEJDOEjs.getNextNonce.call(void 0, 
+        transactionMeta,
+        (address) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(address, networkClientId)
+      );
+      releaseNonceLock = releaseNonce;
+      updatedTransactionMeta.status = "approved" /* approved */;
+      updatedTransactionMeta.txParams = {
+        ...updatedTransactionMeta.txParams,
+        nonce,
+        chainId: transactionMeta.chainId
+      };
+      const baseTxParams = {
+        ...updatedTransactionMeta.txParams,
+        gasLimit: updatedTransactionMeta.txParams.gas
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction approved"
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      const isEIP1559 = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, updatedTransactionMeta.txParams);
+      const txParams = isEIP1559 ? {
+        ...baseTxParams,
+        estimatedBaseFee: updatedTransactionMeta.txParams.estimatedBaseFee,
+        type: "0x2" /* feeMarket */
+      } : baseTxParams;
+      const rawTx = await this.signTransaction(
+        updatedTransactionMeta,
+        txParams
+      );
+      if (!this.beforePublish(updatedTransactionMeta)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping publishing transaction based on hook");
+        this.messagingSystem.publish(
+          `${controllerName}:transactionPublishingSkipped`,
+          updatedTransactionMeta
+        );
+        return "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */;
+      }
+      if (!rawTx) {
+        return "not-approved" /* NotApproved */;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      if (transactionMeta.type === "swap" /* swap */) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Determining pre-transaction balance");
+        const preTxBalance = await _controllerutils.query.call(void 0, ethQuery, "getBalance", [from]);
+        updatedTransactionMeta.preTxBalance = preTxBalance;
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+          "Updated pre-transaction balance",
+          updatedTransactionMeta.preTxBalance
+        );
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publishing transaction", txParams);
+      let { transactionHash: hash } = await this.publish(
+        updatedTransactionMeta,
+        rawTx
+      );
+      if (hash === void 0) {
+        hash = await this.publishTransaction(ethQuery, rawTx);
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publish successful", hash);
+      updatedTransactionMeta.hash = hash;
+      updatedTransactionMeta.status = "submitted" /* submitted */;
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction submitted"
+      );
+      this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+        transactionMeta: updatedTransactionMeta
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      return "approved" /* Approved */;
+    } catch (error) {
+      this.failTransaction(transactionMeta, error);
+      return "not-approved" /* NotApproved */;
+    } finally {
+      this.inProcessOfSigning.delete(transactionId);
+      releaseNonceLock?.();
+      releaseLock();
+    }
+  }
+  async publishTransaction(ethQuery, rawTransaction) {
+    return await _controllerutils.query.call(void 0, ethQuery, "sendRawTransaction", [rawTransaction]);
+  }
+  /**
+   * Cancels a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param actionId - The actionId passed from UI
+   */
+  cancelTransaction(transactionId, actionId) {
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    this.update((state) => {
+      const transactions = state.transactions.filter(
+        ({ id }) => id !== transactionId
+      );
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "rejected" /* rejected */
+    };
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      updatedTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      updatedTransactionMeta
+    );
+    this.messagingSystem.publish(`${controllerName}:transactionRejected`, {
+      transactionMeta: updatedTransactionMeta,
+      actionId
+    });
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Trim the amount of transactions that are set on the state. Checks
+   * if the length of the tx history is longer then desired persistence
+   * limit and then if it is removes the oldest confirmed or rejected tx.
+   * Pending or unapproved transactions will not be removed by this
+   * operation. For safety of presenting a fully functional transaction UI
+   * representation, this function will not break apart transactions with the
+   * same nonce, created on the same day, per network. Not accounting for
+   * transactions of the same nonce, same day and network combo can result in
+   * confusing or broken experiences in the UI.
+   *
+   * @param transactions - The transactions to be applied to the state.
+   * @returns The trimmed list of transactions.
+   */
+  trimTransactionsForState(transactions) {
+    const nonceNetworkSet = /* @__PURE__ */ new Set();
+    const txsToKeep = [...transactions].sort((a, b) => a.time > b.time ? -1 : 1).filter((tx) => {
+      const { chainId, status, txParams, time } = tx;
+      if (txParams) {
+        const key = `${String(txParams.nonce)}-${_controllerutils.convertHexToDecimal.call(void 0, 
+          chainId
+        )}-${new Date(time).toDateString()}`;
+        if (nonceNetworkSet.has(key)) {
+          return true;
+        } else if (nonceNetworkSet.size < _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit) || !this.isFinalState(status)) {
+          nonceNetworkSet.add(key);
+          return true;
+        }
+      }
+      return false;
+    });
+    txsToKeep.reverse();
+    return txsToKeep;
+  }
+  /**
+   * Determines if the transaction is in a final state.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isFinalState(status) {
+    return status === "rejected" /* rejected */ || status === "confirmed" /* confirmed */ || status === "failed" /* failed */;
+  }
+  /**
+   * Whether the transaction has at least completed all local processing.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isLocalFinalState(status) {
+    return [
+      "confirmed" /* confirmed */,
+      "failed" /* failed */,
+      "rejected" /* rejected */,
+      "submitted" /* submitted */
+    ].includes(status);
+  }
+  async requestApproval(txMeta, { shouldShowRequest }) {
+    const id = this.getApprovalId(txMeta);
+    const { origin } = txMeta;
+    const type = _controllerutils.ApprovalType.Transaction;
+    const requestData = { txId: txMeta.id };
+    return await this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id,
+        origin: origin || _controllerutils.ORIGIN_METAMASK,
+        type,
+        requestData,
+        expectsResult: true
+      },
+      shouldShowRequest
+    );
+  }
+  getTransaction(transactionId) {
+    const { transactions } = this.state;
+    return transactions.find(({ id }) => id === transactionId);
+  }
+  getApprovalId(txMeta) {
+    return String(txMeta.id);
+  }
+  isTransactionCompleted(transactionId) {
+    const transaction = this.getTransaction(transactionId);
+    if (!transaction) {
+      return { meta: void 0, isCompleted: false };
+    }
+    const isCompleted = this.isLocalFinalState(transaction.status);
+    return { meta: transaction, isCompleted };
+  }
+  getChainId(networkClientId) {
+    if (networkClientId) {
+      return this.messagingSystem.call(
+        `NetworkController:getNetworkClientById`,
+        networkClientId
+      ).configuration.chainId;
+    }
+    const { providerConfig } = this.getNetworkState();
+    return providerConfig.chainId;
+  }
+  prepareUnsignedEthTx(chainId, txParams) {
+    return _tx.TransactionFactory.fromTxData(txParams, {
+      freeze: false,
+      common: this.getCommonConfiguration(chainId)
+    });
+  }
+  /**
+   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
+   * specifying which chain, network, hardfork and EIPs to support for
+   * a transaction. By referencing this configuration, and analyzing the fields
+   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
+   * transaction type to use.
+   *
+   * @param chainId - The chainId to use for the configuration.
+   * @returns common configuration object
+   */
+  getCommonConfiguration(chainId) {
+    const customChainParams = {
+      chainId: parseInt(chainId, 16),
+      defaultHardfork: HARDFORK
+    };
+    return _common.Common.custom(customChainParams);
+  }
+  onIncomingTransactions({
+    added,
+    updated
+  }) {
+    this.update((state) => {
+      const { transactions: currentTransactions } = state;
+      const updatedTransactions = [
+        ...added,
+        ...currentTransactions.map((originalTransaction) => {
+          const updatedTransaction = updated.find(
+            ({ hash }) => hash === originalTransaction.hash
+          );
+          return updatedTransaction ?? originalTransaction;
+        })
+      ];
+      state.transactions = this.trimTransactionsForState(updatedTransactions);
+    });
+  }
+  onUpdatedLastFetchedBlockNumbers({
+    lastFetchedBlockNumbers,
+    blockNumber
+  }) {
+    this.update((state) => {
+      state.lastFetchedBlockNumbers = lastFetchedBlockNumbers;
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:incomingTransactionBlockReceived`,
+      blockNumber
+    );
+  }
+  generateDappSuggestedGasFees(txParams, origin) {
+    if (!origin || origin === _controllerutils.ORIGIN_METAMASK) {
+      return void 0;
+    }
+    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas, gas } = txParams;
+    if (gasPrice === void 0 && maxFeePerGas === void 0 && maxPriorityFeePerGas === void 0 && gas === void 0) {
+      return void 0;
+    }
+    const dappSuggestedGasFees = {};
+    if (gasPrice !== void 0) {
+      dappSuggestedGasFees.gasPrice = gasPrice;
+    } else if (maxFeePerGas !== void 0 || maxPriorityFeePerGas !== void 0) {
+      dappSuggestedGasFees.maxFeePerGas = maxFeePerGas;
+      dappSuggestedGasFees.maxPriorityFeePerGas = maxPriorityFeePerGas;
+    }
+    if (gas !== void 0) {
+      dappSuggestedGasFees.gas = gas;
+    }
+    return dappSuggestedGasFees;
+  }
+  /**
+   * Validates and adds external provided transaction to state.
+   *
+   * @param transactionMeta - Nominated external transaction to be added to state.
+   * @returns The new transaction.
+   */
+  addExternalTransaction(transactionMeta) {
+    const { chainId } = transactionMeta;
+    const { transactions } = this.state;
+    const fromAddress = transactionMeta?.txParams?.from;
+    const sameFromAndNetworkTransactions = transactions.filter(
+      (transaction) => transaction.txParams.from === fromAddress && transaction.chainId === chainId
+    );
+    const confirmedTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "confirmed" /* confirmed */
+    );
+    const pendingTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "submitted" /* submitted */
+    );
+    _chunk7LXE4KHVjs.validateConfirmedExternalTransaction.call(void 0, 
+      transactionMeta,
+      confirmedTxs,
+      pendingTxs
+    );
+    const newTransactionMeta = (transactionMeta.history ?? []).length === 0 && !this.isHistoryDisabled ? _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, transactionMeta) : transactionMeta;
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        newTransactionMeta
+      ]);
+    });
+    return newTransactionMeta;
+  }
+  /**
+   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
+   * in the transactions have the same nonce.
+   *
+   * @param transactionId - Used to identify original transaction.
+   */
+  markNonceDuplicatesDropped(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    const nonce = transactionMeta.txParams?.nonce;
+    const from = transactionMeta.txParams?.from;
+    const { chainId } = transactionMeta;
+    const sameNonceTransactions = this.state.transactions.filter(
+      (transaction) => transaction.id !== transactionId && transaction.txParams.from === from && transaction.txParams.nonce === nonce && transaction.chainId === chainId && transaction.type !== "incoming" /* incoming */
+    );
+    const sameNonceTransactionIds = sameNonceTransactions.map(
+      (transaction) => transaction.id
+    );
+    if (sameNonceTransactions.length === 0) {
+      return;
+    }
+    this.update((state) => {
+      for (const transaction of state.transactions) {
+        if (sameNonceTransactionIds.includes(transaction.id)) {
+          transaction.replacedBy = transactionMeta?.hash;
+          transaction.replacedById = transactionMeta?.id;
+        }
+      }
+    });
+    for (const transaction of this.state.transactions) {
+      if (sameNonceTransactionIds.includes(transaction.id) && transaction.status !== "failed" /* failed */) {
+        this.setTransactionStatusDropped(transaction);
+      }
+    }
+  }
+  /**
+   * Method to set transaction status to dropped.
+   *
+   * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.
+   */
+  setTransactionStatusDropped(transactionMeta) {
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "dropped" /* dropped */
+    };
+    this.messagingSystem.publish(`${controllerName}:transactionDropped`, {
+      transactionMeta: updatedTransactionMeta
+    });
+    this.updateTransaction(
+      updatedTransactionMeta,
+      "TransactionController#setTransactionStatusDropped - Transaction dropped"
+    );
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Get transaction with provided actionId.
+   *
+   * @param actionId - Unique ID to prevent duplicate requests
+   * @returns the filtered transaction
+   */
+  getTransactionWithActionId(actionId) {
+    return this.state.transactions.find(
+      (transaction) => actionId && transaction.actionId === actionId
+    );
+  }
+  async waitForTransactionFinished(transactionId) {
+    return new Promise((resolve) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).once(`${transactionId}:finished`, (txMeta) => {
+        resolve(txMeta);
+      });
+    });
+  }
+  /**
+   * Updates the r, s, and v properties of a TransactionMeta object
+   * with values from a signed transaction.
+   *
+   * @param transactionMeta - The TransactionMeta object to update.
+   * @param signedTx - The encompassing type for all transaction types containing r, s, and v values.
+   */
+  async updateTransactionMetaRSV(transactionMeta, signedTx) {
+    const transactionMetaWithRsv = _lodash.cloneDeep.call(void 0, transactionMeta);
+    for (const key of ["r", "s", "v"]) {
+      const value = signedTx[key];
+      if (value === void 0 || value === null) {
+        continue;
+      }
+      transactionMetaWithRsv[key] = _utils.add0x.call(void 0, value.toString(16));
+    }
+    return transactionMetaWithRsv;
+  }
+  async getEIP1559Compatibility(networkClientId) {
+    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility(networkClientId);
+    const currentAccountIsEIP1559Compatible = await this.getCurrentAccountEIP1559Compatibility();
+    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
+  }
+  async signTransaction(transactionMeta, txParams) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Signing transaction", txParams);
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    this.inProcessOfSigning.add(transactionMeta.id);
+    const signedTx = await new Promise((resolve, reject) => {
+      this.sign?.(
+        unsignedEthTx,
+        txParams.from,
+        ...this.getAdditionalSignArguments(transactionMeta)
+      ).then(resolve, reject);
+      this.signAbortCallbacks.set(
+        transactionMeta.id,
+        () => reject(new Error("Signing aborted by user"))
+      );
+    });
+    this.signAbortCallbacks.delete(transactionMeta.id);
+    if (!signedTx) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status as no signed transaction");
+      return void 0;
+    }
+    if (!this.afterSign(transactionMeta, signedTx)) {
+      this.updateTransaction(
+        transactionMeta,
+        "TransactionController#signTransaction - Update after sign"
+      );
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status based on hook");
+      return void 0;
+    }
+    const transactionMetaWithRsv = {
+      ...await this.updateTransactionMetaRSV(transactionMeta, signedTx),
+      status: "signed" /* signed */
+    };
+    this.updateTransaction(
+      transactionMetaWithRsv,
+      "TransactionController#approveTransaction - Transaction signed"
+    );
+    this.onTransactionStatusChange(transactionMetaWithRsv);
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const transactionMetaWithRawTx = _lodash.merge.call(void 0, {}, transactionMetaWithRsv, {
+      rawTx
+    });
+    this.updateTransaction(
+      transactionMetaWithRawTx,
+      "TransactionController#approveTransaction - RawTransaction added"
+    );
+    return rawTx;
+  }
+  onTransactionStatusChange(transactionMeta) {
+    this.messagingSystem.publish(`${controllerName}:transactionStatusUpdated`, {
+      transactionMeta
+    });
+  }
+  getNonceTrackerTransactions(status, address, chainId = this.getChainId()) {
+    return _chunkZNZEJDOEjs.getAndFormatTransactionsForNonceTracker.call(void 0, 
+      chainId,
+      address,
+      status,
+      this.state.transactions
+    );
+  }
+  onConfirmedTransaction(transactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Processing confirmed transaction", transactionMeta.id);
+    this.markNonceDuplicatesDropped(transactionMeta.id);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionConfirmed`,
+      transactionMeta
+    );
+    this.onTransactionStatusChange(transactionMeta);
+    this.updatePostBalance(transactionMeta);
+  }
+  async updatePostBalance(transactionMeta) {
+    try {
+      if (transactionMeta.type !== "swap" /* swap */) {
+        return;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      const { updatedTransactionMeta, approvalTransactionMeta } = await _chunkC2LNDHP4js.updatePostTransactionBalance.call(void 0, transactionMeta, {
+        ethQuery,
+        getTransaction: this.getTransaction.bind(this),
+        updateTransaction: this.updateTransaction.bind(this)
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:postTransactionBalanceUpdated`,
+        {
+          transactionMeta: updatedTransactionMeta,
+          approvalTransactionMeta
+        }
+      );
+    } catch (error) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while updating post transaction balance", error);
+    }
+  }
+  async publishTransactionForRetry(ethQuery, rawTx, transactionMeta) {
+    try {
+      const hash = await this.publishTransaction(ethQuery, rawTx);
+      return hash;
+    } catch (error) {
+      if (this.isTransactionAlreadyConfirmedError(error)) {
+        await this.pendingTransactionTracker.forceCheckTransaction(
+          transactionMeta
+        );
+        throw new Error("Previous transaction is already confirmed");
+      }
+      throw error;
+    }
+  }
+  /**
+   * Ensures that error is a nonce issue
+   *
+   * @param error - The error to check
+   * @returns Whether or not the error is a nonce issue
+   */
+  // TODO: Replace `any` with type
+  // Some networks are returning original error in the data field
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  isTransactionAlreadyConfirmedError(error) {
+    return error?.message?.includes("nonce too low") || error?.data?.message?.includes("nonce too low");
+  }
+};
+_internalEvents = new WeakMap();
+_incomingTransactionOptions = new WeakMap();
+_pendingTransactionOptions = new WeakMap();
+_transactionHistoryLimit = new WeakMap();
+_isSimulationEnabled = new WeakMap();
+_multichainTrackingHelper = new WeakMap();
+_createNonceTracker = new WeakSet();
+createNonceTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  return new (0, _noncetracker.NonceTracker)({
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    provider,
+    blockTracker,
+    getPendingTransactions: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn).bind(
+      this,
+      chainId
+    ),
+    getConfirmedTransactions: this.getNonceTrackerTransactions.bind(
+      this,
+      "confirmed" /* confirmed */
+    )
+  });
+};
+_createIncomingTransactionHelper = new WeakSet();
+createIncomingTransactionHelper_fn = function({
+  blockTracker,
+  etherscanRemoteTransactionSource,
+  chainId
+}) {
+  const incomingTransactionHelper = new (0, _chunkDTDTOMTBjs.IncomingTransactionHelper)({
+    blockTracker,
+    getCurrentAccount: this.getSelectedAddress,
+    getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+    getChainId: chainId ? () => chainId : this.getChainId.bind(this),
+    isEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).isEnabled,
+    queryEntireHistory: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).queryEntireHistory,
+    remoteTransactionSource: etherscanRemoteTransactionSource,
+    transactionLimit: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit),
+    updateTransactions: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).updateTransactions
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn).call(this, incomingTransactionHelper);
+  return incomingTransactionHelper;
+};
+_createPendingTransactionTracker = new WeakSet();
+createPendingTransactionTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  const ethQuery = new (0, _ethquery2.default)(provider);
+  const getChainId = chainId ? () => chainId : this.getChainId.bind(this);
+  const pendingTransactionTracker = new (0, _chunk5KMU2IATjs.PendingTransactionTracker)({
+    approveTransaction: async (transactionId) => {
+      await this.approveTransaction(transactionId);
+    },
+    blockTracker,
+    getChainId,
+    getEthQuery: () => ethQuery,
+    getTransactions: () => this.state.transactions,
+    isResubmitEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pendingTransactionOptions).isResubmitEnabled,
+    getGlobalLock: () => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).acquireNonceLockForChainIdKey({
+      chainId: getChainId()
+    }),
+    publishTransaction: this.publishTransaction.bind(this),
+    hooks: {
+      beforeCheckPendingTransaction: this.beforeCheckPendingTransaction.bind(this),
+      beforePublish: this.beforePublish.bind(this)
+    }
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn).call(this, pendingTransactionTracker);
+  return pendingTransactionTracker;
+};
+_checkForPendingTransactionAndStartPolling = new WeakMap();
+_stopAllTracking = new WeakSet();
+stopAllTracking_fn = function() {
+  this.pendingTransactionTracker.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).call(this, this.pendingTransactionTracker);
+  this.incomingTransactionHelper.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).call(this, this.incomingTransactionHelper);
+  _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllTracking();
+};
+_removeIncomingTransactionHelperListeners = new WeakSet();
+removeIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.removeAllListeners("transactions");
+  incomingTransactionHelper.hub.removeAllListeners(
+    "updatedLastFetchedBlockNumbers"
+  );
+};
+_addIncomingTransactionHelperListeners = new WeakSet();
+addIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.on(
+    "transactions",
+    this.onIncomingTransactions.bind(this)
+  );
+  incomingTransactionHelper.hub.on(
+    "updatedLastFetchedBlockNumbers",
+    this.onUpdatedLastFetchedBlockNumbers.bind(this)
+  );
+};
+_removePendingTransactionTrackerListeners = new WeakSet();
+removePendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.removeAllListeners("transaction-confirmed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-dropped");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-failed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-updated");
+};
+_addPendingTransactionTrackerListeners = new WeakSet();
+addPendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.on(
+    "transaction-confirmed",
+    this.onConfirmedTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-dropped",
+    this.setTransactionStatusDropped.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-failed",
+    this.failTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-updated",
+    this.updateTransaction.bind(this)
+  );
+};
+_getNonceTrackerPendingTransactions = new WeakSet();
+getNonceTrackerPendingTransactions_fn = function(chainId, address) {
+  const standardPendingTransactions = this.getNonceTrackerTransactions(
+    "submitted" /* submitted */,
+    address,
+    chainId
+  );
+  const externalPendingTransactions = this.getExternalPendingTransactions(
+    address,
+    chainId
+  );
+  return [...standardPendingTransactions, ...externalPendingTransactions];
+};
+_getGasFeeFlows = new WeakSet();
+getGasFeeFlows_fn = function() {
+  return [new (0, _chunkLNX4JTOLjs.LineaGasFeeFlow)(), new (0, _chunk4RJXBKSRjs.DefaultGasFeeFlow)()];
+};
+_getLayer1GasFeeFlows = new WeakSet();
+getLayer1GasFeeFlows_fn = function() {
+  return [new (0, _chunkPVLJMHKLjs.OptimismLayer1GasFeeFlow)(), new (0, _chunkQ7KPVQHQjs.ScrollLayer1GasFeeFlow)()];
+};
+_updateTransactionInternal = new WeakSet();
+updateTransactionInternal_fn = function({
+  transactionId,
+  note,
+  skipHistory
+}, callback) {
+  let updatedTransactionParams = [];
+  this.update((state) => {
+    const index = state.transactions.findIndex(
+      ({ id }) => id === transactionId
+    );
+    let transactionMeta2 = state.transactions[index];
+    transactionMeta2 = callback(transactionMeta2) ?? transactionMeta2;
+    transactionMeta2.txParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, 
+      transactionMeta2.txParams
+    );
+    _chunkVH47Q6TSjs.validateTxParams.call(void 0, transactionMeta2.txParams);
+    updatedTransactionParams = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _checkIfTransactionParamsUpdated, checkIfTransactionParamsUpdated_fn).call(this, transactionMeta2);
+    if (skipHistory !== true) {
+      transactionMeta2 = _chunkQP75SWIQjs.updateTransactionHistory.call(void 0, 
+        transactionMeta2,
+        note ?? "Transaction updated"
+      );
+    }
+    state.transactions[index] = transactionMeta2;
+  });
+  const transactionMeta = this.getTransaction(
+    transactionId
+  );
+  if (updatedTransactionParams.length > 0) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTransactionParamsUpdated, onTransactionParamsUpdated_fn).call(this, transactionMeta, updatedTransactionParams);
+  }
+};
+_checkIfTransactionParamsUpdated = new WeakSet();
+checkIfTransactionParamsUpdated_fn = function(newTransactionMeta) {
+  const { id: transactionId, txParams: newParams } = newTransactionMeta;
+  const originalParams = this.getTransaction(transactionId)?.txParams;
+  if (!originalParams || _lodash.isEqual.call(void 0, originalParams, newParams)) {
+    return [];
+  }
+  const params = Object.keys(newParams);
+  const updatedProperties = params.filter(
+    (param) => newParams[param] !== originalParams[param]
+  );
+  _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+    "Transaction parameters have been updated",
+    transactionId,
+    updatedProperties,
+    originalParams,
+    newParams
+  );
+  return updatedProperties;
+};
+_onTransactionParamsUpdated = new WeakSet();
+onTransactionParamsUpdated_fn = function(transactionMeta, updatedParams) {
+  if (["to", "value", "data"].some(
+    (param) => updatedParams.includes(param)
+  )) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating simulation data due to transaction parameter update");
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateSimulationData, updateSimulationData_fn).call(this, transactionMeta);
+  }
+};
+_updateSimulationData = new WeakSet();
+updateSimulationData_fn = async function(transactionMeta) {
+  const { id: transactionId, chainId, txParams } = transactionMeta;
+  const { from, to, value, data } = txParams;
+  let simulationData = {
+    error: {
+      code: "disabled" /* Disabled */,
+      message: "Simulation disabled"
+    },
+    tokenBalanceChanges: []
+  };
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isSimulationEnabled).call(this)) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, { transactionId, skipHistory: true }, (txMeta) => {
+      txMeta.simulationData = void 0;
+    });
+    simulationData = await _chunkJAYYMCBQjs.getSimulationData.call(void 0, {
+      chainId,
+      from,
+      to,
+      value,
+      data
+    });
+  }
+  const finalTransactionMeta = this.getTransaction(transactionId);
+  if (!finalTransactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+      "Cannot update simulation data as transaction not found",
+      transactionId,
+      simulationData
+    );
+    return;
+  }
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, {
+    transactionId,
+    note: "TransactionController#updateSimulationData - Update simulation data"
+  }, (txMeta) => {
+    txMeta.simulationData = simulationData;
+  });
+  _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updated simulation data", transactionId, simulationData);
+};
+_onGasFeePollerTransactionUpdate = new WeakSet();
+onGasFeePollerTransactionUpdate_fn = function({
+  transactionId,
+  gasFeeEstimates,
+  gasFeeEstimatesLoaded,
+  layer1GasFee
+}) {
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, { transactionId, skipHistory: true }, (txMeta) => {
+    if (gasFeeEstimates) {
+      txMeta.gasFeeEstimates = gasFeeEstimates;
+    }
+    if (gasFeeEstimatesLoaded !== void 0) {
+      txMeta.gasFeeEstimatesLoaded = gasFeeEstimatesLoaded;
+    }
+    if (layer1GasFee) {
+      txMeta.layer1GasFee = layer1GasFee;
+    }
+  });
+};
+
+
+
+
+
+
+
+exports.HARDFORK = HARDFORK; exports.CANCEL_RATE = CANCEL_RATE; exports.SPEED_UP_RATE = SPEED_UP_RATE; exports.ApprovalState = ApprovalState; exports.TransactionController = TransactionController;
+//# sourceMappingURL=chunk-KAWQSLDO.js.map
\ No newline at end of file
diff --git a/dist/chunk-LNX4JTOL.js b/dist/chunk-LNX4JTOL.js
new file mode 100644
index 0000000000000000000000000000000000000000..40413566125717743895fbcf62eebaba293da188
--- /dev/null
+++ b/dist/chunk-LNX4JTOL.js
@@ -0,0 +1,121 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunk4RJXBKSRjs = require('./chunk-4RJXBKSR.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunkFK7AP6SHjs = require('./chunk-FK7AP6SH.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/LineaGasFeeFlow.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "linea-gas-fee-flow");
+var LINEA_CHAIN_IDS = [
+  _controllerutils.ChainId["linea-mainnet"],
+  _controllerutils.ChainId["linea-goerli"],
+  _controllerutils.ChainId["linea-sepolia"]
+];
+var BASE_FEE_MULTIPLIERS = {
+  low: 1,
+  medium: 1.35,
+  high: 1.7
+};
+var PRIORITY_FEE_MULTIPLIERS = {
+  low: 1,
+  medium: 1.05,
+  high: 1.1
+};
+var _getLineaGasFees, getLineaGasFees_fn, _getLineaResponse, getLineaResponse_fn, _getValuesFromMultipliers, getValuesFromMultipliers_fn, _getMaxFees, getMaxFees_fn, _feesToString, feesToString_fn;
+var LineaGasFeeFlow = class {
+  constructor() {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLineaGasFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLineaResponse);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getValuesFromMultipliers);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getMaxFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _feesToString);
+  }
+  matchesTransaction(transactionMeta) {
+    return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+  }
+  async getGasFees(request) {
+    try {
+      return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLineaGasFees, getLineaGasFees_fn).call(this, request);
+    } catch (error) {
+      log("Using default flow as fallback due to error", error);
+      return new (0, _chunk4RJXBKSRjs.DefaultGasFeeFlow)().getGasFees(request);
+    }
+  }
+};
+_getLineaGasFees = new WeakSet();
+getLineaGasFees_fn = async function(request) {
+  const { ethQuery, transactionMeta } = request;
+  const lineaResponse = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLineaResponse, getLineaResponse_fn).call(this, transactionMeta, ethQuery);
+  log("Received Linea response", lineaResponse);
+  const baseFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getValuesFromMultipliers, getValuesFromMultipliers_fn).call(this, lineaResponse.baseFeePerGas, BASE_FEE_MULTIPLIERS);
+  log("Generated base fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, baseFees));
+  const priorityFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getValuesFromMultipliers, getValuesFromMultipliers_fn).call(this, lineaResponse.priorityFeePerGas, PRIORITY_FEE_MULTIPLIERS);
+  log("Generated priority fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, priorityFees));
+  const maxFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getMaxFees, getMaxFees_fn).call(this, baseFees, priorityFees);
+  log("Generated max fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, maxFees));
+  const estimates = Object.values(_chunkFK7AP6SHjs.GasFeeEstimateLevel).reduce(
+    (result, level) => ({
+      ...result,
+      [level]: {
+        maxFeePerGas: _controllerutils.toHex.call(void 0, maxFees[level]),
+        maxPriorityFeePerGas: _controllerutils.toHex.call(void 0, priorityFees[level])
+      }
+    }),
+    {}
+  );
+  return { estimates };
+};
+_getLineaResponse = new WeakSet();
+getLineaResponse_fn = function(transactionMeta, ethQuery) {
+  return _controllerutils.query.call(void 0, ethQuery, "linea_estimateGas", [
+    {
+      from: transactionMeta.txParams.from,
+      to: transactionMeta.txParams.to,
+      value: transactionMeta.txParams.value,
+      input: transactionMeta.txParams.data,
+      // Required in request but no impact on response.
+      gasPrice: "0x100000000"
+    }
+  ]);
+};
+_getValuesFromMultipliers = new WeakSet();
+getValuesFromMultipliers_fn = function(value, multipliers) {
+  const base = _controllerutils.hexToBN.call(void 0, value);
+  const low = base.muln(multipliers.low);
+  const medium = base.muln(multipliers.medium);
+  const high = base.muln(multipliers.high);
+  return {
+    low,
+    medium,
+    high
+  };
+};
+_getMaxFees = new WeakSet();
+getMaxFees_fn = function(baseFees, priorityFees) {
+  return {
+    low: baseFees.low.add(priorityFees.low),
+    medium: baseFees.medium.add(priorityFees.medium),
+    high: baseFees.high.add(priorityFees.high)
+  };
+};
+_feesToString = new WeakSet();
+feesToString_fn = function(fees) {
+  return Object.values(_chunkFK7AP6SHjs.GasFeeEstimateLevel).map(
+    (level) => fees[level].toString(10)
+  );
+};
+
+
+
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+//# sourceMappingURL=chunk-LNX4JTOL.js.map
\ No newline at end of file
diff --git a/dist/chunk-PVLJMHKL.js b/dist/chunk-PVLJMHKL.js
new file mode 100644
index 0000000000000000000000000000000000000000..dc8283b1174e7a8f198cefd4bc83659e34a44222
--- /dev/null
+++ b/dist/chunk-PVLJMHKL.js
@@ -0,0 +1,31 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkHXEBV7KAjs = require('./chunk-HXEBV7KA.js');
+
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+// src/gas-flows/OptimismLayer1GasFeeFlow.ts
+var OPTIMISM_STACK_CHAIN_IDS = [
+  _chunkUGN7PBONjs.CHAIN_IDS.OPTIMISM,
+  _chunkUGN7PBONjs.CHAIN_IDS.OPTIMISM_TESTNET,
+  _chunkUGN7PBONjs.CHAIN_IDS.BASE,
+  _chunkUGN7PBONjs.CHAIN_IDS.BASE_TESTNET,
+  _chunkUGN7PBONjs.CHAIN_IDS.OPBNB,
+  _chunkUGN7PBONjs.CHAIN_IDS.OPBNB_TESTNET,
+  _chunkUGN7PBONjs.CHAIN_IDS.ZORA
+];
+var OPTIMISM_GAS_PRICE_ORACLE_ADDRESS = "0x420000000000000000000000000000000000000F";
+var OptimismLayer1GasFeeFlow = class extends _chunkHXEBV7KAjs.OracleLayer1GasFeeFlow {
+  constructor() {
+    super(OPTIMISM_GAS_PRICE_ORACLE_ADDRESS);
+  }
+  matchesTransaction(transactionMeta) {
+    return OPTIMISM_STACK_CHAIN_IDS.includes(transactionMeta.chainId);
+  }
+};
+
+
+
+exports.OptimismLayer1GasFeeFlow = OptimismLayer1GasFeeFlow;
+//# sourceMappingURL=chunk-PVLJMHKL.js.map
\ No newline at end of file
diff --git a/dist/chunk-Q7KPVQHQ.js b/dist/chunk-Q7KPVQHQ.js
new file mode 100644
index 0000000000000000000000000000000000000000..2d1c6a091fbd1445738a4c95871f6efe4bbd6e3e
--- /dev/null
+++ b/dist/chunk-Q7KPVQHQ.js
@@ -0,0 +1,23 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkHXEBV7KAjs = require('./chunk-HXEBV7KA.js');
+
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+// src/gas-flows/ScrollLayer1GasFeeFlow.ts
+var SCROLL_CHAIN_IDS = [_chunkUGN7PBONjs.CHAIN_IDS.SCROLL, _chunkUGN7PBONjs.CHAIN_IDS.SCROLL_SEPOLIA];
+var SCROLL_GAS_PRICE_ORACLE_ADDRESS = "0x5300000000000000000000000000000000000002";
+var ScrollLayer1GasFeeFlow = class extends _chunkHXEBV7KAjs.OracleLayer1GasFeeFlow {
+  constructor() {
+    super(SCROLL_GAS_PRICE_ORACLE_ADDRESS, true);
+  }
+  matchesTransaction(transactionMeta) {
+    return SCROLL_CHAIN_IDS.includes(transactionMeta.chainId);
+  }
+};
+
+
+
+exports.ScrollLayer1GasFeeFlow = ScrollLayer1GasFeeFlow;
+//# sourceMappingURL=chunk-Q7KPVQHQ.js.map
\ No newline at end of file
diff --git a/dist/chunk-UGN7PBON.js b/dist/chunk-UGN7PBON.js
new file mode 100644
index 0000000000000000000000000000000000000000..99fe4b45d70fdc4442bd7938cb4b3a565a94010d
--- /dev/null
+++ b/dist/chunk-UGN7PBON.js
@@ -0,0 +1,176 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/constants.ts
+var CHAIN_IDS = {
+  MAINNET: "0x1",
+  GOERLI: "0x5",
+  BASE: "0x2105",
+  BASE_TESTNET: "0x14a33",
+  BSC: "0x38",
+  BSC_TESTNET: "0x61",
+  OPTIMISM: "0xa",
+  OPTIMISM_TESTNET: "0x1a4",
+  OPBNB: "0xcc",
+  OPBNB_TESTNET: "0x15eb",
+  OPTIMISM_SEPOLIA: "0xaa37dc",
+  POLYGON: "0x89",
+  POLYGON_TESTNET: "0x13881",
+  AVALANCHE: "0xa86a",
+  AVALANCHE_TESTNET: "0xa869",
+  FANTOM: "0xfa",
+  FANTOM_TESTNET: "0xfa2",
+  SEPOLIA: "0xaa36a7",
+  LINEA_GOERLI: "0xe704",
+  LINEA_SEPOLIA: "0xe705",
+  LINEA_MAINNET: "0xe708",
+  MOONBEAM: "0x504",
+  MOONBEAM_TESTNET: "0x507",
+  MOONRIVER: "0x505",
+  GNOSIS: "0x64",
+  ARBITRUM: "0xa4b1",
+  ZKSYNC_ERA: "0x144",
+  ZORA: "0x76adf1",
+  SCROLL: "0x82750",
+  SCROLL_SEPOLIA: "0x8274f"
+};
+var DEFAULT_ETHERSCAN_DOMAIN = "etherscan.io";
+var DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = "api";
+var ETHERSCAN_SUPPORTED_NETWORKS = {
+  [CHAIN_IDS.GOERLI]: {
+    domain: DEFAULT_ETHERSCAN_DOMAIN,
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-goerli`
+  },
+  [CHAIN_IDS.MAINNET]: {
+    domain: DEFAULT_ETHERSCAN_DOMAIN,
+    subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX
+  },
+  [CHAIN_IDS.SEPOLIA]: {
+    domain: DEFAULT_ETHERSCAN_DOMAIN,
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia`
+  },
+  [CHAIN_IDS.LINEA_GOERLI]: {
+    domain: "lineascan.build",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-goerli`
+  },
+  [CHAIN_IDS.LINEA_SEPOLIA]: {
+    domain: "lineascan.build",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia`
+  },
+  [CHAIN_IDS.LINEA_MAINNET]: {
+    domain: "lineascan.build",
+    subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX
+  },
+  [CHAIN_IDS.BSC]: {
+    domain: "bscscan.com",
+    subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX
+  },
+  [CHAIN_IDS.BSC_TESTNET]: {
+    domain: "bscscan.com",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`
+  },
+  [CHAIN_IDS.OPTIMISM]: {
+    domain: DEFAULT_ETHERSCAN_DOMAIN,
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-optimistic`
+  },
+  [CHAIN_IDS.OPTIMISM_SEPOLIA]: {
+    domain: DEFAULT_ETHERSCAN_DOMAIN,
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia-optimistic`
+  },
+  [CHAIN_IDS.POLYGON]: {
+    domain: "polygonscan.com",
+    subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX
+  },
+  [CHAIN_IDS.POLYGON_TESTNET]: {
+    domain: "polygonscan.com",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-mumbai`
+  },
+  [CHAIN_IDS.AVALANCHE]: {
+    domain: "snowtrace.io",
+    subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX
+  },
+  [CHAIN_IDS.AVALANCHE_TESTNET]: {
+    domain: "snowtrace.io",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`
+  },
+  [CHAIN_IDS.FANTOM]: {
+    domain: "ftmscan.com",
+    subdomain: DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX
+  },
+  [CHAIN_IDS.FANTOM_TESTNET]: {
+    domain: "ftmscan.com",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-testnet`
+  },
+  [CHAIN_IDS.MOONBEAM]: {
+    domain: "moonscan.io",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonbeam`
+  },
+  [CHAIN_IDS.MOONBEAM_TESTNET]: {
+    domain: "moonscan.io",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonbase`
+  },
+  [CHAIN_IDS.MOONRIVER]: {
+    domain: "moonscan.io",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-moonriver`
+  },
+  [CHAIN_IDS.GNOSIS]: {
+    domain: "gnosisscan.io",
+    subdomain: `${DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-gnosis`
+  }
+};
+var GAS_BUFFER_CHAIN_OVERRIDES = {
+  [CHAIN_IDS.OPTIMISM]: 1,
+  [CHAIN_IDS.OPTIMISM_SEPOLIA]: 1
+};
+var ABI_SIMULATION_ERC20_WRAPPED = [
+  {
+    anonymous: false,
+    inputs: [
+      { indexed: true, name: "to", type: "address" },
+      { indexed: false, name: "wad", type: "uint256" }
+    ],
+    name: "Deposit",
+    type: "event"
+  },
+  {
+    anonymous: false,
+    inputs: [
+      { indexed: true, name: "from", type: "address" },
+      { indexed: false, name: "wad", type: "uint256" }
+    ],
+    name: "Withdrawal",
+    type: "event"
+  }
+];
+var ABI_SIMULATION_ERC721_LEGACY = [
+  {
+    anonymous: false,
+    inputs: [
+      {
+        indexed: false,
+        name: "_from",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "_to",
+        type: "address"
+      },
+      {
+        indexed: false,
+        name: "_tokenId",
+        type: "uint256"
+      }
+    ],
+    name: "Transfer",
+    type: "event"
+  }
+];
+
+
+
+
+
+
+
+
+
+exports.CHAIN_IDS = CHAIN_IDS; exports.DEFAULT_ETHERSCAN_DOMAIN = DEFAULT_ETHERSCAN_DOMAIN; exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX; exports.ETHERSCAN_SUPPORTED_NETWORKS = ETHERSCAN_SUPPORTED_NETWORKS; exports.GAS_BUFFER_CHAIN_OVERRIDES = GAS_BUFFER_CHAIN_OVERRIDES; exports.ABI_SIMULATION_ERC20_WRAPPED = ABI_SIMULATION_ERC20_WRAPPED; exports.ABI_SIMULATION_ERC721_LEGACY = ABI_SIMULATION_ERC721_LEGACY;
+//# sourceMappingURL=chunk-UGN7PBON.js.map
\ No newline at end of file
diff --git a/dist/chunk-V72C4MCR.js b/dist/chunk-V72C4MCR.js
new file mode 100644
index 0000000000000000000000000000000000000000..3c76a3018ff7fb31b9d490f106e6eed6c0bb0826
--- /dev/null
+++ b/dist/chunk-V72C4MCR.js
@@ -0,0 +1,137 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/gas.ts
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "gas");
+var FIXED_GAS = "0x5208";
+var DEFAULT_GAS_MULTIPLIER = 1.5;
+async function updateGas(request) {
+  const { txMeta } = request;
+  const initialParams = { ...txMeta.txParams };
+  const [gas, simulationFails] = await getGas(request);
+  txMeta.txParams.gas = gas;
+  txMeta.simulationFails = simulationFails;
+  if (!initialParams.gas) {
+    txMeta.originalGasEstimate = txMeta.txParams.gas;
+  }
+  if (!txMeta.defaultGasEstimates) {
+    txMeta.defaultGasEstimates = {};
+  }
+  txMeta.defaultGasEstimates.gas = txMeta.txParams.gas;
+}
+async function estimateGas(txParams, ethQuery) {
+  const request = { ...txParams };
+  const { data, value } = request;
+  const { gasLimit: gasLimitHex, number: blockNumber } = await getLatestBlock(
+    ethQuery
+  );
+  const gasLimitBN = _controllerutils.hexToBN.call(void 0, gasLimitHex);
+  request.data = data ? _utils.add0x.call(void 0, data) : data;
+  request.gas = _controllerutils.BNToHex.call(void 0, _controllerutils.fractionBN.call(void 0, gasLimitBN, 19, 20));
+  request.value = value || "0x0";
+  let estimatedGas = request.gas;
+  let simulationFails;
+  try {
+    estimatedGas = await _controllerutils.query.call(void 0, ethQuery, "estimateGas", [request]);
+  } catch (error) {
+    simulationFails = {
+      reason: error.message,
+      errorKey: error.errorKey,
+      debug: {
+        blockNumber,
+        blockGasLimit: gasLimitHex
+      }
+    };
+    log("Estimation failed", { ...simulationFails, fallback: estimateGas });
+  }
+  return {
+    blockGasLimit: gasLimitHex,
+    estimatedGas,
+    simulationFails
+  };
+}
+function addGasBuffer(estimatedGas, blockGasLimit, multiplier) {
+  const estimatedGasBN = _controllerutils.hexToBN.call(void 0, estimatedGas);
+  const maxGasBN = _controllerutils.hexToBN.call(void 0, blockGasLimit).muln(0.9);
+  const paddedGasBN = estimatedGasBN.muln(multiplier);
+  if (estimatedGasBN.gt(maxGasBN)) {
+    const estimatedGasHex = _utils.add0x.call(void 0, estimatedGas);
+    log("Using estimated value", estimatedGasHex);
+    return estimatedGasHex;
+  }
+  if (paddedGasBN.lt(maxGasBN)) {
+    const paddedHex = _utils.add0x.call(void 0, _controllerutils.BNToHex.call(void 0, paddedGasBN));
+    log("Using padded estimate", paddedHex, multiplier);
+    return paddedHex;
+  }
+  const maxHex = _utils.add0x.call(void 0, _controllerutils.BNToHex.call(void 0, maxGasBN));
+  log("Using 90% of block gas limit", maxHex);
+  return maxHex;
+}
+async function getGas(request) {
+  const { isCustomNetwork, chainId, txMeta } = request;
+  if (txMeta.txParams.gas) {
+    log("Using value from request", txMeta.txParams.gas);
+    return [txMeta.txParams.gas];
+  }
+  if (await requiresFixedGas(request)) {
+    log("Using fixed value", FIXED_GAS);
+    return [FIXED_GAS];
+  }
+  const { blockGasLimit, estimatedGas, simulationFails } = await estimateGas(
+    txMeta.txParams,
+    request.ethQuery
+  );
+  if (isCustomNetwork) {
+    log("Using original estimate as custom network");
+    return [estimatedGas, simulationFails];
+  }
+  const bufferMultiplier = _chunkUGN7PBONjs.GAS_BUFFER_CHAIN_OVERRIDES[chainId] ?? DEFAULT_GAS_MULTIPLIER;
+  const bufferedGas = addGasBuffer(
+    estimatedGas,
+    blockGasLimit,
+    bufferMultiplier
+  );
+  return [bufferedGas, simulationFails];
+}
+async function requiresFixedGas({
+  ethQuery,
+  txMeta,
+  isCustomNetwork
+}) {
+  const {
+    txParams: { to, data }
+  } = txMeta;
+  if (isCustomNetwork || !to || data) {
+    return false;
+  }
+  const code = await getCode(ethQuery, to);
+  return !code || code === "0x";
+}
+async function getCode(ethQuery, address) {
+  return await _controllerutils.query.call(void 0, ethQuery, "getCode", [address]);
+}
+async function getLatestBlock(ethQuery) {
+  return await _controllerutils.query.call(void 0, ethQuery, "getBlockByNumber", ["latest", false]);
+}
+
+
+
+
+
+
+
+
+exports.log = log; exports.FIXED_GAS = FIXED_GAS; exports.DEFAULT_GAS_MULTIPLIER = DEFAULT_GAS_MULTIPLIER; exports.updateGas = updateGas; exports.estimateGas = estimateGas; exports.addGasBuffer = addGasBuffer;
+//# sourceMappingURL=chunk-V72C4MCR.js.map
\ No newline at end of file
diff --git a/dist/constants.js b/dist/constants.js
index 52fe2dab63048b0c32c6cf1568479ec197939aa6..8d9305cbe9d1390f3b83237164fbad5152ca16d7 100644
--- a/dist/constants.js
+++ b/dist/constants.js
@@ -6,7 +6,7 @@
 
 
 
-var _chunkLQS2M5QRjs = require('./chunk-LQS2M5QR.js');
+var _chunkUGN7PBONjs = require('./chunk-UGN7PBON.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -16,5 +16,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.ABI_SIMULATION_ERC20_WRAPPED = _chunkLQS2M5QRjs.ABI_SIMULATION_ERC20_WRAPPED; exports.ABI_SIMULATION_ERC721_LEGACY = _chunkLQS2M5QRjs.ABI_SIMULATION_ERC721_LEGACY; exports.CHAIN_IDS = _chunkLQS2M5QRjs.CHAIN_IDS; exports.DEFAULT_ETHERSCAN_DOMAIN = _chunkLQS2M5QRjs.DEFAULT_ETHERSCAN_DOMAIN; exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = _chunkLQS2M5QRjs.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX; exports.ETHERSCAN_SUPPORTED_NETWORKS = _chunkLQS2M5QRjs.ETHERSCAN_SUPPORTED_NETWORKS; exports.GAS_BUFFER_CHAIN_OVERRIDES = _chunkLQS2M5QRjs.GAS_BUFFER_CHAIN_OVERRIDES;
+exports.ABI_SIMULATION_ERC20_WRAPPED = _chunkUGN7PBONjs.ABI_SIMULATION_ERC20_WRAPPED; exports.ABI_SIMULATION_ERC721_LEGACY = _chunkUGN7PBONjs.ABI_SIMULATION_ERC721_LEGACY; exports.CHAIN_IDS = _chunkUGN7PBONjs.CHAIN_IDS; exports.DEFAULT_ETHERSCAN_DOMAIN = _chunkUGN7PBONjs.DEFAULT_ETHERSCAN_DOMAIN; exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = _chunkUGN7PBONjs.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX; exports.ETHERSCAN_SUPPORTED_NETWORKS = _chunkUGN7PBONjs.ETHERSCAN_SUPPORTED_NETWORKS; exports.GAS_BUFFER_CHAIN_OVERRIDES = _chunkUGN7PBONjs.GAS_BUFFER_CHAIN_OVERRIDES;
 //# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
index c3990d26c78caa6902663835ed049b3c6a7cf44d..78a8ff9de9b67ae75e775c9f435e5ef2f3d094e3 100644
--- a/dist/gas-flows/DefaultGasFeeFlow.js
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -1,15 +1,15 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkLYD4TEKHjs = require('../chunk-LYD4TEKH.js');
-require('../chunk-L337FYVS.js');
-require('../chunk-WLCFETHR.js');
+var _chunk4RJXBKSRjs = require('../chunk-4RJXBKSR.js');
+require('../chunk-EQNKFFTM.js');
+require('../chunk-C2LNDHP4.js');
 require('../chunk-UGFBA4GV.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-UH7FNVKS.js');
-require('../chunk-LQS2M5QR.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.DefaultGasFeeFlow = _chunkLYD4TEKHjs.DefaultGasFeeFlow;
+exports.DefaultGasFeeFlow = _chunk4RJXBKSRjs.DefaultGasFeeFlow;
 //# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
index 42bcad415165c8235f7b29176a2e03d560a28b60..b0525578f0a529dbcc755e8b53e6dab09e62101e 100644
--- a/dist/gas-flows/LineaGasFeeFlow.js
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -1,16 +1,16 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkUBXRAA6Gjs = require('../chunk-UBXRAA6G.js');
-require('../chunk-LYD4TEKH.js');
-require('../chunk-L337FYVS.js');
-require('../chunk-WLCFETHR.js');
+var _chunkLNX4JTOLjs = require('../chunk-LNX4JTOL.js');
+require('../chunk-4RJXBKSR.js');
+require('../chunk-EQNKFFTM.js');
+require('../chunk-C2LNDHP4.js');
 require('../chunk-UGFBA4GV.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-UH7FNVKS.js');
-require('../chunk-LQS2M5QR.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.LineaGasFeeFlow = _chunkUBXRAA6Gjs.LineaGasFeeFlow;
+exports.LineaGasFeeFlow = _chunkLNX4JTOLjs.LineaGasFeeFlow;
 //# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/OptimismLayer1GasFeeFlow.js b/dist/gas-flows/OptimismLayer1GasFeeFlow.js
index 7f3c4af8de3c1df1416ef6ff31a4787ae731bbe7..8ecdd52c215b88132381a8c71009ace7720d832b 100644
--- a/dist/gas-flows/OptimismLayer1GasFeeFlow.js
+++ b/dist/gas-flows/OptimismLayer1GasFeeFlow.js
@@ -1,10 +1,11 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkETMW527Mjs = require('../chunk-ETMW527M.js');
-require('../chunk-LQS2M5QR.js');
+var _chunkPVLJMHKLjs = require('../chunk-PVLJMHKL.js');
+require('../chunk-HXEBV7KA.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.OptimismLayer1GasFeeFlow = _chunkETMW527Mjs.OptimismLayer1GasFeeFlow;
+exports.OptimismLayer1GasFeeFlow = _chunkPVLJMHKLjs.OptimismLayer1GasFeeFlow;
 //# sourceMappingURL=OptimismLayer1GasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/OracleLayer1GasFeeFlow.js b/dist/gas-flows/OracleLayer1GasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..ba1fa9c8fa3aa8338132a5a12795f3def95ef577
--- /dev/null
+++ b/dist/gas-flows/OracleLayer1GasFeeFlow.js
@@ -0,0 +1,9 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkHXEBV7KAjs = require('../chunk-HXEBV7KA.js');
+require('../chunk-S6VGOPUY.js');
+require('../chunk-Z4BLTVTB.js');
+
+
+exports.OracleLayer1GasFeeFlow = _chunkHXEBV7KAjs.OracleLayer1GasFeeFlow;
+//# sourceMappingURL=OracleLayer1GasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/ScrollLayer1GasFeeFlow.js b/dist/gas-flows/ScrollLayer1GasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..12278786e1b7121da4cf22129f5bcd24214c5d29
--- /dev/null
+++ b/dist/gas-flows/ScrollLayer1GasFeeFlow.js
@@ -0,0 +1,11 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkQ7KPVQHQjs = require('../chunk-Q7KPVQHQ.js');
+require('../chunk-HXEBV7KA.js');
+require('../chunk-UGN7PBON.js');
+require('../chunk-S6VGOPUY.js');
+require('../chunk-Z4BLTVTB.js');
+
+
+exports.ScrollLayer1GasFeeFlow = _chunkQ7KPVQHQjs.ScrollLayer1GasFeeFlow;
+//# sourceMappingURL=ScrollLayer1GasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/EtherscanRemoteTransactionSource.js b/dist/helpers/EtherscanRemoteTransactionSource.js
index 78e92e55f5c59fcbe3ce4bd83da9e279ce127bfb..45aeca40c407b3889b935490908b3c14110e2890 100644
--- a/dist/helpers/EtherscanRemoteTransactionSource.js
+++ b/dist/helpers/EtherscanRemoteTransactionSource.js
@@ -1,12 +1,12 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunk3JEUO765js = require('../chunk-3JEUO765.js');
-require('../chunk-F247MMTE.js');
-require('../chunk-LQS2M5QR.js');
+var _chunkEQT25RSPjs = require('../chunk-EQT25RSP.js');
+require('../chunk-FDUCRHYT.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.EtherscanRemoteTransactionSource = _chunk3JEUO765js.EtherscanRemoteTransactionSource;
+exports.EtherscanRemoteTransactionSource = _chunkEQT25RSPjs.EtherscanRemoteTransactionSource;
 //# sourceMappingURL=EtherscanRemoteTransactionSource.js.map
\ No newline at end of file
diff --git a/dist/helpers/MultichainTrackingHelper.js b/dist/helpers/MultichainTrackingHelper.js
index 5ab81f0c729ae6a2d7b7e391770a5f70817153fd..88c35e43bed6cc62dbb1d5e733bf71370fe2ad5c 100644
--- a/dist/helpers/MultichainTrackingHelper.js
+++ b/dist/helpers/MultichainTrackingHelper.js
@@ -1,13 +1,13 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkCPYXP2OCjs = require('../chunk-CPYXP2OC.js');
-require('../chunk-3JEUO765.js');
-require('../chunk-F247MMTE.js');
-require('../chunk-LQS2M5QR.js');
+var _chunk5XQ2KRYLjs = require('../chunk-5XQ2KRYL.js');
+require('../chunk-EQT25RSP.js');
+require('../chunk-FDUCRHYT.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.MultichainTrackingHelper = _chunkCPYXP2OCjs.MultichainTrackingHelper;
+exports.MultichainTrackingHelper = _chunk5XQ2KRYLjs.MultichainTrackingHelper;
 //# sourceMappingURL=MultichainTrackingHelper.js.map
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index a46cc54ebe97a3c230f8c8b2595da5307dfc108e..83d7ff5ca7bf2479ebc84ea74431ea427e15f3e5 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -2,38 +2,40 @@
 
 
 
-var _chunkX5WPBDI5js = require('./chunk-X5WPBDI5.js');
+var _chunkKAWQSLDOjs = require('./chunk-KAWQSLDO.js');
+require('./chunk-JAYYMCBQ.js');
+require('./chunk-KT6UAKBB.js');
 
 
 var _chunkSD6CWFDFjs = require('./chunk-SD6CWFDF.js');
 require('./chunk-VH47Q6TS.js');
-require('./chunk-AO3AE3L7.js');
+require('./chunk-7LXE4KHV.js');
+require('./chunk-V72C4MCR.js');
 require('./chunk-QP75SWIQ.js');
 require('./chunk-ZNZEJDOE.js');
-require('./chunk-3VF7ZGRV.js');
-require('./chunk-KT6UAKBB.js');
-require('./chunk-ETMW527M.js');
-require('./chunk-V6UIRCOF.js');
-require('./chunk-2XKEAKQG.js');
 require('./chunk-DTDTOMTB.js');
-require('./chunk-CPYXP2OC.js');
-require('./chunk-3JEUO765.js');
+require('./chunk-5XQ2KRYL.js');
 require('./chunk-5KMU2IAT.js');
-require('./chunk-F247MMTE.js');
-require('./chunk-7LXE4KHV.js');
-require('./chunk-HMOSP33F.js');
-require('./chunk-UBXRAA6G.js');
-require('./chunk-LYD4TEKH.js');
-require('./chunk-L337FYVS.js');
-require('./chunk-WLCFETHR.js');
+require('./chunk-LNX4JTOL.js');
+require('./chunk-4RJXBKSR.js');
+require('./chunk-EQNKFFTM.js');
+require('./chunk-C2LNDHP4.js');
 
 
 
 var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
+require('./chunk-PVLJMHKL.js');
+require('./chunk-Q7KPVQHQ.js');
+require('./chunk-HXEBV7KA.js');
+require('./chunk-HMOSP33F.js');
+require('./chunk-EQT25RSP.js');
+require('./chunk-FDUCRHYT.js');
+require('./chunk-UGN7PBON.js');
+require('./chunk-V6UIRCOF.js');
+require('./chunk-2XKEAKQG.js');
 
 
 var _chunkUH7FNVKSjs = require('./chunk-UH7FNVKS.js');
-require('./chunk-LQS2M5QR.js');
 require('./chunk-S6VGOPUY.js');
 
 
@@ -60,5 +62,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.CANCEL_RATE = _chunkX5WPBDI5js.CANCEL_RATE; exports.HARDFORK = _chunkX5WPBDI5js.HARDFORK; exports.SimulationErrorCode = _chunkFK7AP6SHjs.SimulationErrorCode; exports.SimulationTokenStandard = _chunkFK7AP6SHjs.SimulationTokenStandard; exports.TransactionController = _chunkX5WPBDI5js.TransactionController; exports.TransactionEnvelopeType = _chunkFK7AP6SHjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkFK7AP6SHjs.TransactionStatus; exports.TransactionType = _chunkFK7AP6SHjs.TransactionType; exports.UserFeeLevel = _chunkFK7AP6SHjs.UserFeeLevel; exports.WalletDevice = _chunkFK7AP6SHjs.WalletDevice; exports.determineTransactionType = _chunkSD6CWFDFjs.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkUH7FNVKSjs.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
+exports.CANCEL_RATE = _chunkKAWQSLDOjs.CANCEL_RATE; exports.HARDFORK = _chunkKAWQSLDOjs.HARDFORK; exports.SimulationErrorCode = _chunkFK7AP6SHjs.SimulationErrorCode; exports.SimulationTokenStandard = _chunkFK7AP6SHjs.SimulationTokenStandard; exports.TransactionController = _chunkKAWQSLDOjs.TransactionController; exports.TransactionEnvelopeType = _chunkFK7AP6SHjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkFK7AP6SHjs.TransactionStatus; exports.TransactionType = _chunkFK7AP6SHjs.TransactionType; exports.UserFeeLevel = _chunkFK7AP6SHjs.UserFeeLevel; exports.WalletDevice = _chunkFK7AP6SHjs.WalletDevice; exports.determineTransactionType = _chunkSD6CWFDFjs.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkUH7FNVKSjs.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types/constants.d.ts b/dist/types/constants.d.ts
index aab207498ab06734554648f97c6eb4f780d93e28..68358e617c0e0fe517914552739d85c6f0bd6835 100644
--- a/dist/types/constants.d.ts
+++ b/dist/types/constants.d.ts
@@ -27,6 +27,8 @@ export declare const CHAIN_IDS: {
     readonly ARBITRUM: "0xa4b1";
     readonly ZKSYNC_ERA: "0x144";
     readonly ZORA: "0x76adf1";
+    readonly SCROLL: "0x82750";
+    readonly SCROLL_SEPOLIA: "0x8274f";
 };
 export declare const DEFAULT_ETHERSCAN_DOMAIN = "etherscan.io";
 export declare const DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX = "api";
diff --git a/dist/types/gas-flows/OptimismLayer1GasFeeFlow.d.ts b/dist/types/gas-flows/OptimismLayer1GasFeeFlow.d.ts
index cf268c997929ec1102e96e5275a5e78afd6036f5..ccfc44b0f41a86f4879f3edaa88e19915803575e 100644
--- a/dist/types/gas-flows/OptimismLayer1GasFeeFlow.d.ts
+++ b/dist/types/gas-flows/OptimismLayer1GasFeeFlow.d.ts
@@ -1,10 +1,10 @@
-import type { Layer1GasFeeFlow, Layer1GasFeeFlowRequest, Layer1GasFeeFlowResponse, TransactionMeta } from '../types';
+import type { TransactionMeta } from '../types';
+import { OracleLayer1GasFeeFlow } from './OracleLayer1GasFeeFlow';
 /**
- * Optimism layer 1 gas fee flow that obtains gas fee estimate using Optimisim oracle contract.
+ * Optimism layer 1 gas fee flow that obtains gas fee estimate using an oracle contract.
  */
-export declare class OptimismLayer1GasFeeFlow implements Layer1GasFeeFlow {
-    #private;
+export declare class OptimismLayer1GasFeeFlow extends OracleLayer1GasFeeFlow {
+    constructor();
     matchesTransaction(transactionMeta: TransactionMeta): boolean;
-    getLayer1Fee(request: Layer1GasFeeFlowRequest): Promise<Layer1GasFeeFlowResponse>;
 }
 //# sourceMappingURL=OptimismLayer1GasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/types/gas-flows/OracleLayer1GasFeeFlow.d.ts b/dist/types/gas-flows/OracleLayer1GasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b194c2658b071922d2ea8572fa85a1fa1de6f067
--- /dev/null
+++ b/dist/types/gas-flows/OracleLayer1GasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { Hex } from '@metamask/utils';
+import type { Layer1GasFeeFlow, Layer1GasFeeFlowRequest, Layer1GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Layer 1 gas fee flow that obtains gas fee estimate using an oracle smart contract.
+ */
+export declare abstract class OracleLayer1GasFeeFlow implements Layer1GasFeeFlow {
+    #private;
+    constructor(oracleAddress: Hex, signTransaction?: boolean);
+    abstract matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getLayer1Fee(request: Layer1GasFeeFlowRequest): Promise<Layer1GasFeeFlowResponse>;
+}
+//# sourceMappingURL=OracleLayer1GasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/types/gas-flows/ScrollLayer1GasFeeFlow.d.ts b/dist/types/gas-flows/ScrollLayer1GasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..130b90e654a5c56da0f8a3310a0bedf8b68e1e0e
--- /dev/null
+++ b/dist/types/gas-flows/ScrollLayer1GasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { TransactionMeta } from '../types';
+import { OracleLayer1GasFeeFlow } from './OracleLayer1GasFeeFlow';
+/**
+ * Scroll layer 1 gas fee flow that obtains gas fee estimate using an oracle contract.
+ */
+export declare class ScrollLayer1GasFeeFlow extends OracleLayer1GasFeeFlow {
+    constructor();
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+}
+//# sourceMappingURL=ScrollLayer1GasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/etherscan.js b/dist/utils/etherscan.js
index 06ba33862f1fe45e50630e395d88c885104af0f0..070f8a25b3066f73013831b98be5412129fde38e 100644
--- a/dist/utils/etherscan.js
+++ b/dist/utils/etherscan.js
@@ -2,13 +2,13 @@
 
 
 
-var _chunkF247MMTEjs = require('../chunk-F247MMTE.js');
-require('../chunk-LQS2M5QR.js');
+var _chunkFDUCRHYTjs = require('../chunk-FDUCRHYT.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
 
-exports.fetchEtherscanTokenTransactions = _chunkF247MMTEjs.fetchEtherscanTokenTransactions; exports.fetchEtherscanTransactions = _chunkF247MMTEjs.fetchEtherscanTransactions; exports.getEtherscanApiHost = _chunkF247MMTEjs.getEtherscanApiHost;
+exports.fetchEtherscanTokenTransactions = _chunkFDUCRHYTjs.fetchEtherscanTokenTransactions; exports.fetchEtherscanTransactions = _chunkFDUCRHYTjs.fetchEtherscanTransactions; exports.getEtherscanApiHost = _chunkFDUCRHYTjs.getEtherscanApiHost;
 //# sourceMappingURL=etherscan.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index fd721051c40e12819906c5a5b7be0a4d2e24f7a6..c56cf6851b5c0e1ae024e2254f0f9f4cfd468c3d 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -1,16 +1,16 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunkL337FYVSjs = require('../chunk-L337FYVS.js');
-require('../chunk-WLCFETHR.js');
+var _chunkEQNKFFTMjs = require('../chunk-EQNKFFTM.js');
+require('../chunk-C2LNDHP4.js');
 require('../chunk-UGFBA4GV.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-UH7FNVKS.js');
-require('../chunk-LQS2M5QR.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.gweiDecimalToWeiHex = _chunkL337FYVSjs.gweiDecimalToWeiHex; exports.updateGasFees = _chunkL337FYVSjs.updateGasFees;
+exports.gweiDecimalToWeiHex = _chunkEQNKFFTMjs.gweiDecimalToWeiHex; exports.updateGasFees = _chunkEQNKFFTMjs.updateGasFees;
 //# sourceMappingURL=gas-fees.js.map
\ No newline at end of file
diff --git a/dist/utils/gas.js b/dist/utils/gas.js
index 0db32ed7e3f7556509b3c3072e08baec37059aab..3c53d92300f407dbb29c0885d6f885a4278a7d93 100644
--- a/dist/utils/gas.js
+++ b/dist/utils/gas.js
@@ -5,8 +5,8 @@
 
 
 
-var _chunkAO3AE3L7js = require('../chunk-AO3AE3L7.js');
-require('../chunk-LQS2M5QR.js');
+var _chunkV72C4MCRjs = require('../chunk-V72C4MCR.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-Z4BLTVTB.js');
 
@@ -16,5 +16,5 @@ require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.DEFAULT_GAS_MULTIPLIER = _chunkAO3AE3L7js.DEFAULT_GAS_MULTIPLIER; exports.FIXED_GAS = _chunkAO3AE3L7js.FIXED_GAS; exports.addGasBuffer = _chunkAO3AE3L7js.addGasBuffer; exports.estimateGas = _chunkAO3AE3L7js.estimateGas; exports.log = _chunkAO3AE3L7js.log; exports.updateGas = _chunkAO3AE3L7js.updateGas;
+exports.DEFAULT_GAS_MULTIPLIER = _chunkV72C4MCRjs.DEFAULT_GAS_MULTIPLIER; exports.FIXED_GAS = _chunkV72C4MCRjs.FIXED_GAS; exports.addGasBuffer = _chunkV72C4MCRjs.addGasBuffer; exports.estimateGas = _chunkV72C4MCRjs.estimateGas; exports.log = _chunkV72C4MCRjs.log; exports.updateGas = _chunkV72C4MCRjs.updateGas;
 //# sourceMappingURL=gas.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
index 39fd30abdc7d9cd8c0bb11d91e1b4bb15d61435d..9ebe8da5469bc3e572d595d7ac0a88b9065a155b 100644
--- a/dist/utils/simulation.js
+++ b/dist/utils/simulation.js
@@ -1,15 +1,15 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunk3VF7ZGRVjs = require('../chunk-3VF7ZGRV.js');
+var _chunkJAYYMCBQjs = require('../chunk-JAYYMCBQ.js');
 require('../chunk-KT6UAKBB.js');
 require('../chunk-HMOSP33F.js');
-require('../chunk-LQS2M5QR.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.SupportedToken = _chunk3VF7ZGRVjs.SupportedToken; exports.getSimulationData = _chunk3VF7ZGRVjs.getSimulationData;
+exports.SupportedToken = _chunkJAYYMCBQjs.SupportedToken; exports.getSimulationData = _chunkJAYYMCBQjs.getSimulationData;
 //# sourceMappingURL=simulation.js.map
\ No newline at end of file
diff --git a/dist/utils/swaps.js b/dist/utils/swaps.js
index af6d14f45c972765107c7c8b2760ef3ebc178ac6..473a2974ff1121886b5afd5fdcde8eb2dc8145f9 100644
--- a/dist/utils/swaps.js
+++ b/dist/utils/swaps.js
@@ -6,9 +6,9 @@
 
 
 
-var _chunkWLCFETHRjs = require('../chunk-WLCFETHR.js');
+var _chunkC2LNDHP4js = require('../chunk-C2LNDHP4.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-LQS2M5QR.js');
+require('../chunk-UGN7PBON.js');
 require('../chunk-S6VGOPUY.js');
 require('../chunk-FK7AP6SH.js');
 require('../chunk-Z4BLTVTB.js');
@@ -20,5 +20,5 @@ require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.DEFAULT_TOKEN_ADDRESS = _chunkWLCFETHRjs.DEFAULT_TOKEN_ADDRESS; exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = _chunkWLCFETHRjs.SWAPS_CHAINID_DEFAULT_TOKEN_MAP; exports.SWAP_TRANSACTION_TYPES = _chunkWLCFETHRjs.SWAP_TRANSACTION_TYPES; exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = _chunkWLCFETHRjs.UPDATE_POST_TX_BALANCE_ATTEMPTS; exports.UPDATE_POST_TX_BALANCE_TIMEOUT = _chunkWLCFETHRjs.UPDATE_POST_TX_BALANCE_TIMEOUT; exports.updatePostTransactionBalance = _chunkWLCFETHRjs.updatePostTransactionBalance; exports.updateSwapsTransaction = _chunkWLCFETHRjs.updateSwapsTransaction;
+exports.DEFAULT_TOKEN_ADDRESS = _chunkC2LNDHP4js.DEFAULT_TOKEN_ADDRESS; exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = _chunkC2LNDHP4js.SWAPS_CHAINID_DEFAULT_TOKEN_MAP; exports.SWAP_TRANSACTION_TYPES = _chunkC2LNDHP4js.SWAP_TRANSACTION_TYPES; exports.UPDATE_POST_TX_BALANCE_ATTEMPTS = _chunkC2LNDHP4js.UPDATE_POST_TX_BALANCE_ATTEMPTS; exports.UPDATE_POST_TX_BALANCE_TIMEOUT = _chunkC2LNDHP4js.UPDATE_POST_TX_BALANCE_TIMEOUT; exports.updatePostTransactionBalance = _chunkC2LNDHP4js.updatePostTransactionBalance; exports.updateSwapsTransaction = _chunkC2LNDHP4js.updateSwapsTransaction;
 //# sourceMappingURL=swaps.js.map
\ No newline at end of file
