diff --git a/dist/AbstractMessageManager.d.ts b/dist/AbstractMessageManager.d.ts
index d3b00470e37f63380ba2069072cd65ec816f5b50..535c6e56aea0a7dc720debff1de76174f1782885 100644
--- a/dist/AbstractMessageManager.d.ts
+++ b/dist/AbstractMessageManager.d.ts
@@ -1,7 +1,8 @@
 /// <reference types="node" />
 import { EventEmitter } from 'events';
+import type { Hex } from '@metamask/utils';
 import { BaseController, BaseConfig, BaseState } from '@metamask/base-controller';
-import { Json } from '@metamask/controller-utils';
+import { Json } from '@metamask/utils';
 /**
  * @type OriginalRequest
  *
@@ -20,6 +21,7 @@ export interface OriginalRequest {
  * A 'Message' which always has a signing type
  * @property rawSig - Raw data of the signature request
  * @property securityProviderResponse - Response from a security provider, whether it is malicious or not
+ * @property metadata - Additional data for the message, for example external identifiers
  */
 export interface AbstractMessage {
     id: string;
@@ -28,6 +30,7 @@ export interface AbstractMessage {
     type: string;
     rawSig?: string;
     securityProviderResponse?: Record<string, Json>;
+    metadata?: Json;
 }
 /**
  * @type MessageParams
@@ -35,10 +38,12 @@ export interface AbstractMessage {
  * Represents the parameters to pass to the signing method once the signature request is approved.
  * @property from - Address from which the message is processed
  * @property origin? - Added for request origin identification
+ * @property deferSetAsSigned? - Whether to defer setting the message as signed immediately after the keyring is told to sign it
  */
 export interface AbstractMessageParams {
     from: string;
     origin?: string;
+    deferSetAsSigned?: boolean;
 }
 /**
  * @type MessageParamsMetamask
@@ -69,7 +74,7 @@ export interface MessageManagerState<M extends AbstractMessage> extends BaseStat
  * A function for verifying a message, whether it is malicious or not
  */
 export declare type SecurityProviderRequest = (requestData: AbstractMessage, messageType: string) => Promise<Json>;
-declare type getCurrentChainId = () => string;
+declare type getCurrentChainId = () => Hex;
 /**
  * Controller in charge of managing - storing, adding, removing, updating - Messages.
  */
@@ -153,6 +158,12 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      * if no Message has that id.
      */
     getMessage(messageId: string): M | undefined;
+    /**
+     * Returns all the messages.
+     *
+     * @returns An array of messages.
+     */
+    getAllMessages(): M[];
     /**
      * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,
      * and returns a promise with any the message params modified for proper signing.
@@ -168,6 +179,13 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      * @param messageId - The id of the Message to approve.
      */
     setMessageStatusApproved(messageId: string): void;
+    /**
+     * Sets message status to inProgress in order to allow users to use extension
+     * while waiting for a custodian signature.
+     *
+     * @param messageId - The id of the message to set to inProgress
+     */
+    setMessageStatusInProgress(messageId: string): void;
     /**
      * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates
      * that Message in this.messages by adding the raw signature data of the signature
@@ -192,6 +210,13 @@ export declare abstract class AbstractMessageManager<M extends AbstractMessage,
      * @param result - The data to update result in the message.
      */
     setResult(messageId: string, result: string): void;
+    /**
+     * Sets the messsage metadata
+     *
+     * @param messageId - The id of the Message to update
+     * @param metadata - The data with which to replace the metadata property in the message
+     */
+    setMetadata(messageId: string, metadata: Json): void;
     /**
      * Removes the metamaskId property from passed messageParams and returns a promise which
      * resolves the updated messageParams
diff --git a/dist/AbstractMessageManager.d.ts.map b/dist/AbstractMessageManager.d.ts.map
index ecfc3f2ba4656a297bb957d55bc2ea56d57f05ac..95afa4b184c5e68f709bace819b13199f42b386b 100644
--- a/dist/AbstractMessageManager.d.ts.map
+++ b/dist/AbstractMessageManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"AbstractMessageManager.d.ts","sourceRoot":"","sources":["../src/AbstractMessageManager.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"AbstractMessageManager.d.ts","sourceRoot":"","sources":["../src/AbstractMessageManager.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/dist/AbstractMessageManager.js b/dist/AbstractMessageManager.js
index ad19423d21dd719640cbcedf4abcd4e0f484b348..1867d39c5bbfa27610a4aaf80be047bf4f1b3c39 100644
--- a/dist/AbstractMessageManager.js
+++ b/dist/AbstractMessageManager.js
@@ -153,6 +153,14 @@ class AbstractMessageManager extends base_controller_1.BaseController {
     getMessage(messageId) {
         return this.messages.find((message) => message.id === messageId);
     }
+    /**
+     * Returns all the messages.
+     *
+     * @returns An array of messages.
+     */
+    getAllMessages() {
+        return this.messages;
+    }
     /**
      * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,
      * and returns a promise with any the message params modified for proper signing.
@@ -175,6 +183,15 @@ class AbstractMessageManager extends base_controller_1.BaseController {
     setMessageStatusApproved(messageId) {
         this.setMessageStatus(messageId, 'approved');
     }
+    /**
+     * Sets message status to inProgress in order to allow users to use extension
+     * while waiting for a custodian signature.
+     *
+     * @param messageId - The id of the message to set to inProgress
+     */
+    setMessageStatusInProgress(messageId) {
+        this.setMessageStatus(messageId, 'inProgress');
+    }
     /**
      * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates
      * that Message in this.messages by adding the raw signature data of the signature
@@ -212,6 +229,20 @@ class AbstractMessageManager extends base_controller_1.BaseController {
         message.rawSig = result;
         this.updateMessage(message, false);
     }
+    /**
+     * Sets the messsage metadata
+     *
+     * @param messageId - The id of the Message to update
+     * @param metadata - The data with which to replace the metadata property in the message
+     */
+    setMetadata(messageId, metadata) {
+        const message = this.getMessage(messageId);
+        if (!message) {
+            throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
+        }
+        message.metadata = metadata;
+        this.updateMessage(message, false);
+    }
     /**
      * Sets a Message status to 'rejected' via a call to this.setMessageStatus.
      *
diff --git a/dist/AbstractMessageManager.js.map b/dist/AbstractMessageManager.js.map
index e54fe270257094ec4ed09353ccb3b6c150012018..73ae771ea7a81cac50b372c1bcc1ab504cae726e 100644
--- a/dist/AbstractMessageManager.js.map
+++ b/dist/AbstractMessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"AbstractMessageManager.js","sourceRoot":"","sources":["../src/AbstractMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { Json } from '@metamask/controller-utils';\n\n/**\n * @type OriginalRequest\n *\n * Represents the original request object for adding a message.\n * @property origin? - Is it is specified, represents the origin\n */\nexport interface OriginalRequest {\n  origin?: string;\n}\n\n/**\n * @type Message\n *\n * Represents and contains data about a signing type signature request.\n * @property id - An id to track and identify the message object\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a signing type\n * @property rawSig - Raw data of the signature request\n * @property securityProviderResponse - Response from a security provider, whether it is malicious or not\n */\nexport interface AbstractMessage {\n  id: string;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n  securityProviderResponse?: Record<string, Json>;\n}\n\n/**\n * @type MessageParams\n *\n * Represents the parameters to pass to the signing method once the signature request is approved.\n * @property from - Address from which the message is processed\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParams {\n  from: string;\n  origin?: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the signing method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property from - Address from which the message is processed\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParamsMetamask extends AbstractMessageParams {\n  metamaskId?: string;\n}\n\n/**\n * @type MessageManagerState\n *\n * Message Manager state\n * @property unapprovedMessages - A collection of all Messages in the 'unapproved' state\n * @property unapprovedMessagesCount - The count of all Messages in this.unapprovedMessages\n */\nexport interface MessageManagerState<M extends AbstractMessage>\n  extends BaseState {\n  unapprovedMessages: { [key: string]: M };\n  unapprovedMessagesCount: number;\n}\n\n/**\n * A function for verifying a message, whether it is malicious or not\n */\nexport type SecurityProviderRequest = (\n  requestData: AbstractMessage,\n  messageType: string,\n) => Promise<Json>;\n\ntype getCurrentChainId = () => string;\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport abstract class AbstractMessageManager<\n  M extends AbstractMessage,\n  P extends AbstractMessageParams,\n  PM extends AbstractMessageParamsMetamask,\n> extends BaseController<BaseConfig, MessageManagerState<M>> {\n  protected messages: M[];\n\n  protected getCurrentChainId: getCurrentChainId | undefined;\n\n  private securityProviderRequest: SecurityProviderRequest | undefined;\n\n  private additionalFinishStatuses: string[];\n\n  /**\n   * Saves the unapproved messages, and their count to state.\n   *\n   * @param emitUpdateBadge - Whether to emit the updateBadge event.\n   */\n  protected saveMessageList(emitUpdateBadge = true) {\n    const unapprovedMessages = this.getUnapprovedMessages();\n    const unapprovedMessagesCount = this.getUnapprovedMessagesCount();\n    this.update({ unapprovedMessages, unapprovedMessagesCount });\n    if (emitUpdateBadge) {\n      this.hub.emit('updateBadge');\n    }\n  }\n\n  /**\n   * Updates the status of a Message in this.messages.\n   *\n   * @param messageId - The id of the Message to update.\n   * @param status - The new status of the Message.\n   */\n  protected setMessageStatus(messageId: string, status: string) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.status = status;\n    this.updateMessage(message);\n    this.hub.emit(`${messageId}:${status}`, message);\n    if (\n      status === 'rejected' ||\n      status === 'signed' ||\n      status === 'errored' ||\n      this.additionalFinishStatuses.includes(status)\n    ) {\n      this.hub.emit(`${messageId}:finished`, message);\n    }\n  }\n\n  /**\n   * Sets a Message in this.messages to the passed Message if the ids are equal.\n   * Then saves the unapprovedMessage list to storage.\n   *\n   * @param message - A Message that will replace an existing Message (with the id) in this.messages.\n   * @param emitUpdateBadge - Whether to emit the updateBadge event.\n   */\n  protected updateMessage(message: M, emitUpdateBadge = true) {\n    const index = this.messages.findIndex((msg) => message.id === msg.id);\n    /* istanbul ignore next */\n    if (index !== -1) {\n      this.messages[index] = message;\n    }\n    this.saveMessageList(emitUpdateBadge);\n  }\n\n  /**\n   * Verifies a message is malicious or not by checking it against a security provider.\n   *\n   * @param message - The message to verify.\n   * @returns A promise that resolves to a secured message with additional security provider response data.\n   */\n  private async securityCheck(message: M): Promise<M> {\n    if (this.securityProviderRequest) {\n      const securityProviderResponse = await this.securityProviderRequest(\n        message,\n        message.type,\n      );\n      return {\n        ...message,\n        securityProviderResponse,\n      };\n    }\n    return message;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific message events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AbstractMessageManager';\n\n  /**\n   * Creates an AbstractMessageManager instance.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   * @param securityProviderRequest - A function for verifying a message, whether it is malicious or not.\n   * @param additionalFinishStatuses - Optional list of statuses that are accepted to emit a finished event.\n   * @param getCurrentChainId - Optional function to get the current chainId.\n   */\n  constructor(\n    config?: Partial<BaseConfig>,\n    state?: Partial<MessageManagerState<M>>,\n    securityProviderRequest?: SecurityProviderRequest,\n    additionalFinishStatuses?: string[],\n    getCurrentChainId?: getCurrentChainId,\n  ) {\n    super(config, state);\n    this.defaultState = {\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    };\n    this.messages = [];\n    this.securityProviderRequest = securityProviderRequest;\n    this.additionalFinishStatuses = additionalFinishStatuses ?? [];\n    this.getCurrentChainId = getCurrentChainId;\n    this.initialize();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages.\n   *\n   * @returns The number of 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessagesCount() {\n    return Object.keys(this.getUnapprovedMessages()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' Messages in state messages.\n   *\n   * @returns An index of Message ids to Messages, for all 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessages() {\n    return this.messages\n      .filter((message) => message.status === 'unapproved')\n      .reduce((result: { [key: string]: M }, message: M) => {\n        result[message.id] = message;\n        return result;\n      }, {}) as { [key: string]: M };\n  }\n\n  /**\n   * Adds a passed Message to this.messages, and calls this.saveMessageList() to save\n   * the unapproved Messages from that list to this.messages.\n   *\n   * @param message - The Message to add to this.messages.\n   */\n  async addMessage(message: M) {\n    const securedMessage = await this.securityCheck(message);\n    this.messages.push(securedMessage);\n    this.saveMessageList();\n  }\n\n  /**\n   * Returns a specified Message.\n   *\n   * @param messageId - The id of the Message to get.\n   * @returns The Message with the id that matches the passed messageId, or undefined\n   * if no Message has that id.\n   */\n  getMessage(messageId: string) {\n    return this.messages.find((message) => message.id === messageId);\n  }\n\n  /**\n   * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,\n   * and returns a promise with any the message params modified for proper signing.\n   *\n   * @param messageParams - The messageParams to be used when signing method is called,\n   * plus data added by MetaMask.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  approveMessage(messageParams: PM): Promise<P> {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.setMessageStatusApproved(messageParams.metamaskId);\n    return this.prepMessageForSigning(messageParams);\n  }\n\n  /**\n   * Sets a Message status to 'approved' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to approve.\n   */\n  setMessageStatusApproved(messageId: string) {\n    this.setMessageStatus(messageId, 'approved');\n  }\n\n  /**\n   * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates\n   * that Message in this.messages by adding the raw signature data of the signature\n   * request to the Message.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The raw data of the signature request.\n   */\n  setMessageStatusSigned(messageId: string, rawSig: string) {\n    this.setMessageStatusAndResult(messageId, rawSig, 'signed');\n  }\n\n  /**\n   * Sets the message via a call to this.setResult and updates status of the message.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The data to update rawSig in the message.\n   * @param status - The new message status.\n   */\n  setMessageStatusAndResult(messageId: string, rawSig: string, status: string) {\n    this.setResult(messageId, rawSig);\n    this.setMessageStatus(messageId, status);\n  }\n\n  /**\n   * Sets the message result.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param result - The data to update result in the message.\n   */\n  setResult(messageId: string, result: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.rawSig = result;\n    this.updateMessage(message, false);\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams\n   *\n   * @param messageParams - The messageParams to modify\n   * @returns Promise resolving to the messageParams with the metamaskId property removed\n   */\n  abstract prepMessageForSigning(messageParams: PM): Promise<P>;\n\n  /**\n   * Sets a Message status to 'rejected' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to reject.\n   */\n  rejectMessage(messageId: string) {\n    this.setMessageStatus(messageId, 'rejected');\n  }\n}\n\nexport default AbstractMessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"AbstractMessageManager.js","sourceRoot":"","sources":["../src/AbstractMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport type { Hex } from '@metamask/utils';\nimport {\n  BaseController,\n  BaseConfig,\n  BaseState,\n} from '@metamask/base-controller';\nimport { Json } from '@metamask/utils';\n\n/**\n * @type OriginalRequest\n *\n * Represents the original request object for adding a message.\n * @property origin? - Is it is specified, represents the origin\n */\nexport interface OriginalRequest {\n  origin?: string;\n}\n\n/**\n * @type Message\n *\n * Represents and contains data about a signing type signature request.\n * @property id - An id to track and identify the message object\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a signing type\n * @property rawSig - Raw data of the signature request\n * @property securityProviderResponse - Response from a security provider, whether it is malicious or not\n * @property metadata - Additional data for the message, for example external identifiers\n */\nexport interface AbstractMessage {\n  id: string;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n  securityProviderResponse?: Record<string, Json>;\n  metadata?: Json;\n}\n\n/**\n * @type MessageParams\n *\n * Represents the parameters to pass to the signing method once the signature request is approved.\n * @property from - Address from which the message is processed\n * @property origin? - Added for request origin identification\n * @property deferSetAsSigned? - Whether to defer setting the message as signed immediately after the keyring is told to sign it\n */\nexport interface AbstractMessageParams {\n  from: string;\n  origin?: string;\n  deferSetAsSigned?: boolean;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the signing method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property from - Address from which the message is processed\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParamsMetamask extends AbstractMessageParams {\n  metamaskId?: string;\n}\n\n/**\n * @type MessageManagerState\n *\n * Message Manager state\n * @property unapprovedMessages - A collection of all Messages in the 'unapproved' state\n * @property unapprovedMessagesCount - The count of all Messages in this.unapprovedMessages\n */\nexport interface MessageManagerState<M extends AbstractMessage>\n  extends BaseState {\n  unapprovedMessages: { [key: string]: M };\n  unapprovedMessagesCount: number;\n}\n\n/**\n * A function for verifying a message, whether it is malicious or not\n */\nexport type SecurityProviderRequest = (\n  requestData: AbstractMessage,\n  messageType: string,\n) => Promise<Json>;\n\ntype getCurrentChainId = () => Hex;\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport abstract class AbstractMessageManager<\n  M extends AbstractMessage,\n  P extends AbstractMessageParams,\n  PM extends AbstractMessageParamsMetamask,\n> extends BaseController<BaseConfig, MessageManagerState<M>> {\n  protected messages: M[];\n\n  protected getCurrentChainId: getCurrentChainId | undefined;\n\n  private securityProviderRequest: SecurityProviderRequest | undefined;\n\n  private additionalFinishStatuses: string[];\n\n  /**\n   * Saves the unapproved messages, and their count to state.\n   *\n   * @param emitUpdateBadge - Whether to emit the updateBadge event.\n   */\n  protected saveMessageList(emitUpdateBadge = true) {\n    const unapprovedMessages = this.getUnapprovedMessages();\n    const unapprovedMessagesCount = this.getUnapprovedMessagesCount();\n    this.update({ unapprovedMessages, unapprovedMessagesCount });\n    if (emitUpdateBadge) {\n      this.hub.emit('updateBadge');\n    }\n  }\n\n  /**\n   * Updates the status of a Message in this.messages.\n   *\n   * @param messageId - The id of the Message to update.\n   * @param status - The new status of the Message.\n   */\n  protected setMessageStatus(messageId: string, status: string) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.status = status;\n    this.updateMessage(message);\n    this.hub.emit(`${messageId}:${status}`, message);\n    if (\n      status === 'rejected' ||\n      status === 'signed' ||\n      status === 'errored' ||\n      this.additionalFinishStatuses.includes(status)\n    ) {\n      this.hub.emit(`${messageId}:finished`, message);\n    }\n  }\n\n  /**\n   * Sets a Message in this.messages to the passed Message if the ids are equal.\n   * Then saves the unapprovedMessage list to storage.\n   *\n   * @param message - A Message that will replace an existing Message (with the id) in this.messages.\n   * @param emitUpdateBadge - Whether to emit the updateBadge event.\n   */\n  protected updateMessage(message: M, emitUpdateBadge = true) {\n    const index = this.messages.findIndex((msg) => message.id === msg.id);\n    /* istanbul ignore next */\n    if (index !== -1) {\n      this.messages[index] = message;\n    }\n    this.saveMessageList(emitUpdateBadge);\n  }\n\n  /**\n   * Verifies a message is malicious or not by checking it against a security provider.\n   *\n   * @param message - The message to verify.\n   * @returns A promise that resolves to a secured message with additional security provider response data.\n   */\n  private async securityCheck(message: M): Promise<M> {\n    if (this.securityProviderRequest) {\n      const securityProviderResponse = await this.securityProviderRequest(\n        message,\n        message.type,\n      );\n      return {\n        ...message,\n        securityProviderResponse,\n      };\n    }\n    return message;\n  }\n\n  /**\n   * EventEmitter instance used to listen to specific message events\n   */\n  hub = new EventEmitter();\n\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'AbstractMessageManager';\n\n  /**\n   * Creates an AbstractMessageManager instance.\n   *\n   * @param config - Initial options used to configure this controller.\n   * @param state - Initial state to set on this controller.\n   * @param securityProviderRequest - A function for verifying a message, whether it is malicious or not.\n   * @param additionalFinishStatuses - Optional list of statuses that are accepted to emit a finished event.\n   * @param getCurrentChainId - Optional function to get the current chainId.\n   */\n  constructor(\n    config?: Partial<BaseConfig>,\n    state?: Partial<MessageManagerState<M>>,\n    securityProviderRequest?: SecurityProviderRequest,\n    additionalFinishStatuses?: string[],\n    getCurrentChainId?: getCurrentChainId,\n  ) {\n    super(config, state);\n    this.defaultState = {\n      unapprovedMessages: {},\n      unapprovedMessagesCount: 0,\n    };\n    this.messages = [];\n    this.securityProviderRequest = securityProviderRequest;\n    this.additionalFinishStatuses = additionalFinishStatuses ?? [];\n    this.getCurrentChainId = getCurrentChainId;\n    this.initialize();\n  }\n\n  /**\n   * A getter for the number of 'unapproved' Messages in this.messages.\n   *\n   * @returns The number of 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessagesCount() {\n    return Object.keys(this.getUnapprovedMessages()).length;\n  }\n\n  /**\n   * A getter for the 'unapproved' Messages in state messages.\n   *\n   * @returns An index of Message ids to Messages, for all 'unapproved' Messages in this.messages.\n   */\n  getUnapprovedMessages() {\n    return this.messages\n      .filter((message) => message.status === 'unapproved')\n      .reduce((result: { [key: string]: M }, message: M) => {\n        result[message.id] = message;\n        return result;\n      }, {}) as { [key: string]: M };\n  }\n\n  /**\n   * Adds a passed Message to this.messages, and calls this.saveMessageList() to save\n   * the unapproved Messages from that list to this.messages.\n   *\n   * @param message - The Message to add to this.messages.\n   */\n  async addMessage(message: M) {\n    const securedMessage = await this.securityCheck(message);\n    this.messages.push(securedMessage);\n    this.saveMessageList();\n  }\n\n  /**\n   * Returns a specified Message.\n   *\n   * @param messageId - The id of the Message to get.\n   * @returns The Message with the id that matches the passed messageId, or undefined\n   * if no Message has that id.\n   */\n  getMessage(messageId: string) {\n    return this.messages.find((message) => message.id === messageId);\n  }\n\n  /**\n   * Returns all the messages.\n   *\n   * @returns An array of messages.\n   */\n  getAllMessages() {\n    return this.messages;\n  }\n\n  /**\n   * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,\n   * and returns a promise with any the message params modified for proper signing.\n   *\n   * @param messageParams - The messageParams to be used when signing method is called,\n   * plus data added by MetaMask.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  approveMessage(messageParams: PM): Promise<P> {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.setMessageStatusApproved(messageParams.metamaskId);\n    return this.prepMessageForSigning(messageParams);\n  }\n\n  /**\n   * Sets a Message status to 'approved' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to approve.\n   */\n  setMessageStatusApproved(messageId: string) {\n    this.setMessageStatus(messageId, 'approved');\n  }\n\n  /**\n   * Sets message status to inProgress in order to allow users to use extension\n   * while waiting for a custodian signature.\n   *\n   * @param messageId - The id of the message to set to inProgress\n   */\n  setMessageStatusInProgress(messageId: string) {\n    this.setMessageStatus(messageId, 'inProgress');\n  }\n\n  /**\n   * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates\n   * that Message in this.messages by adding the raw signature data of the signature\n   * request to the Message.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The raw data of the signature request.\n   */\n  setMessageStatusSigned(messageId: string, rawSig: string) {\n    this.setMessageStatusAndResult(messageId, rawSig, 'signed');\n  }\n\n  /**\n   * Sets the message via a call to this.setResult and updates status of the message.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param rawSig - The data to update rawSig in the message.\n   * @param status - The new message status.\n   */\n  setMessageStatusAndResult(messageId: string, rawSig: string, status: string) {\n    this.setResult(messageId, rawSig);\n    this.setMessageStatus(messageId, status);\n  }\n\n  /**\n   * Sets the message result.\n   *\n   * @param messageId - The id of the Message to sign.\n   * @param result - The data to update result in the message.\n   */\n  setResult(messageId: string, result: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.rawSig = result;\n    this.updateMessage(message, false);\n  }\n\n  /**\n   * Sets the messsage metadata\n   *\n   * @param messageId - The id of the Message to update\n   * @param metadata - The data with which to replace the metadata property in the message\n   */\n\n  setMetadata(messageId: string, metadata: Json) {\n    const message = this.getMessage(messageId);\n    if (!message) {\n      throw new Error(`${this.name}: Message not found for id: ${messageId}.`);\n    }\n    message.metadata = metadata;\n    this.updateMessage(message, false);\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams\n   *\n   * @param messageParams - The messageParams to modify\n   * @returns Promise resolving to the messageParams with the metamaskId property removed\n   */\n  abstract prepMessageForSigning(messageParams: PM): Promise<P>;\n\n  /**\n   * Sets a Message status to 'rejected' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the Message to reject.\n   */\n  rejectMessage(messageId: string) {\n    this.setMessageStatus(messageId, 'rejected');\n  }\n}\n\nexport default AbstractMessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/MessageManager.d.ts b/dist/MessageManager.d.ts
index 986e163f8e709ba7937523d55bc734a2e8f712bd..3959d86274e85e1f06ecfcbf87dc146c5e8bf366 100644
--- a/dist/MessageManager.d.ts
+++ b/dist/MessageManager.d.ts
@@ -45,15 +45,6 @@ export declare class MessageManager extends AbstractMessageManager<Message, Mess
      * Name of this controller used during composition
      */
     name: string;
-    /**
-     * Creates a new Message with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
-     *
-     * @param messageParams - The params for the eth_sign call to be made after the message is approved.
-     * @param req - The original request object possibly containing the origin.
-     * @returns Promise resolving to the raw data of the signature request.
-     */
-    addUnapprovedMessageAsync(messageParams: MessageParams, req?: OriginalRequest): Promise<string>;
     /**
      * Creates a new Message with an 'unapproved' status using the passed messageParams.
      * this.addMessage is called to add the new Message to this.messages, and to save the
diff --git a/dist/MessageManager.d.ts.map b/dist/MessageManager.d.ts.map
index 124bba5784809c52b4707b114e0c00e651b96e4d..ea3d2d3248c07f2e85d9e6c5914f7076a302b414 100644
--- a/dist/MessageManager.d.ts.map
+++ b/dist/MessageManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"MessageManager.d.ts","sourceRoot":"","sources":["../src/MessageManager.ts"],"names":[],"mappings":"AACA,OAAO,EACL,sBAAsB,EACtB,eAAe,EACf,qBAAqB,EACrB,6BAA6B,EAC7B,eAAe,EAChB,MAAM,0BAA0B,CAAC;AAGlC;;;;;;;;;;GAUG;AACH,MAAM,WAAW,OAAQ,SAAQ,eAAe;IAC9C,aAAa,EAAE,aAAa,CAAC;CAC9B;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,aAAc,SAAQ,qBAAqB;IAC1D,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;;;;;;;;GASG;AACH,MAAM,WAAW,qBAAsB,SAAQ,6BAA6B;IAC1E,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;GAEG;AACH,qBAAa,cAAe,SAAQ,sBAAsB,CACxD,OAAO,EACP,aAAa,EACb,qBAAqB,CACtB;IACC;;OAEG;IACM,IAAI,SAAoB;IAEjC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAAa,EAAE,aAAa,EAC5B,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IA2BlB;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAa,EAAE,aAAa,EAC5B,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IAqBlB;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAa,EAAE,qBAAqB,GACnC,OAAO,CAAC,aAAa,CAAC;CAI1B;AAED,eAAe,cAAc,CAAC"}
\ No newline at end of file
+{"version":3,"file":"MessageManager.d.ts","sourceRoot":"","sources":["../src/MessageManager.ts"],"names":[],"mappings":"AACA,OAAO,EACL,sBAAsB,EACtB,eAAe,EACf,qBAAqB,EACrB,6BAA6B,EAC7B,eAAe,EAChB,MAAM,0BAA0B,CAAC;AAGlC;;;;;;;;;;GAUG;AACH,MAAM,WAAW,OAAQ,SAAQ,eAAe;IAC9C,aAAa,EAAE,aAAa,CAAC;CAC9B;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,aAAc,SAAQ,qBAAqB;IAC1D,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;;;;;;;;GASG;AACH,MAAM,WAAW,qBAAsB,SAAQ,6BAA6B;IAC1E,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;GAEG;AACH,qBAAa,cAAe,SAAQ,sBAAsB,CACxD,OAAO,EACP,aAAa,EACb,qBAAqB,CACtB;IACC;;OAEG;IACM,IAAI,SAAoB;IAEjC;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAa,EAAE,aAAa,EAC5B,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IAsBlB;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAa,EAAE,qBAAqB,GACnC,OAAO,CAAC,aAAa,CAAC;CAI1B;AAED,eAAe,cAAc,CAAC"}
\ No newline at end of file
diff --git a/dist/MessageManager.js b/dist/MessageManager.js
index 5518479a9eb7387dcdeea6572e8c48ba00e283ef..89fcd8f8191192b41e770ccfdcfb47ac4b8ef351 100644
--- a/dist/MessageManager.js
+++ b/dist/MessageManager.js
@@ -24,32 +24,6 @@ class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
          */
         this.name = 'MessageManager';
     }
-    /**
-     * Creates a new Message with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
-     *
-     * @param messageParams - The params for the eth_sign call to be made after the message is approved.
-     * @param req - The original request object possibly containing the origin.
-     * @returns Promise resolving to the raw data of the signature request.
-     */
-    addUnapprovedMessageAsync(messageParams, req) {
-        return __awaiter(this, void 0, void 0, function* () {
-            (0, utils_1.validateSignMessageData)(messageParams);
-            const messageId = yield this.addUnapprovedMessage(messageParams, req);
-            return new Promise((resolve, reject) => {
-                this.hub.once(`${messageId}:finished`, (data) => {
-                    switch (data.status) {
-                        case 'signed':
-                            return resolve(data.rawSig);
-                        case 'rejected':
-                            return reject(new Error('MetaMask Message Signature: User denied message signature.'));
-                        default:
-                            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
-                    }
-                });
-            });
-        });
-    }
     /**
      * Creates a new Message with an 'unapproved' status using the passed messageParams.
      * this.addMessage is called to add the new Message to this.messages, and to save the
@@ -62,6 +36,7 @@ class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
      */
     addUnapprovedMessage(messageParams, req) {
         return __awaiter(this, void 0, void 0, function* () {
+            (0, utils_1.validateSignMessageData)(messageParams);
             if (req) {
                 messageParams.origin = req.origin;
             }
diff --git a/dist/MessageManager.js.map b/dist/MessageManager.js.map
index 688c05a2ee2fd3c21a9d03374ae2f2a9fa5bd15b..e00920476d3eee0d90e875fe54ce89d25977d5e7 100644
--- a/dist/MessageManager.js.map
+++ b/dist/MessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"MessageManager.js","sourceRoot":"","sources":["../src/MessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,qEAMkC;AAClC,mCAAwE;AA2CxE;;GAEG;AACH,MAAa,cAAe,SAAQ,+CAInC;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,gBAAgB,CAAC;IAuFnC,CAAC;IArFC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAA4B,EAC5B,GAAqB;;YAErB,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YACtE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAa,EAAE,EAAE;oBACvD,QAAQ,IAAI,CAAC,MAAM,EAAE;wBACnB,KAAK,QAAQ;4BACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;wBACxC,KAAK,UAAU;4BACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,4DAA4D,CAC7D,CACF,CAAC;wBACJ;4BACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,gDAAgD,IAAI,CAAC,SAAS,CAC5D,aAAa,CACd,EAAE,CACJ,CACF,CAAC;qBACL;gBACH,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAA4B,EAC5B,GAAqB;;YAErB,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAC9D,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAY;gBAC3B,EAAE,EAAE,SAAS;gBACb,aAAa;gBACb,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,UAAU;aACjB,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,aAAa,GACb,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAoC;QAEpC,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA/FD,wCA+FC;AAED,kBAAe,cAAc,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'eth_sign' type signature request.\n * These are created when a signature for an eth_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the eth_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'eth_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface Message extends AbstractMessage {\n  messageParams: MessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParams extends AbstractMessageParams {\n  data: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParamsMetamask extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class MessageManager extends AbstractMessageManager<\n  Message,\n  MessageParams,\n  MessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'MessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: MessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateSignMessageData(messageParams);\n    const messageId = await this.addUnapprovedMessage(messageParams, req);\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: Message) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Message Signature: User denied message signature.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: MessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = random();\n    const messageData: Message = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_sign',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...messageParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: MessageParamsMetamask,\n  ): Promise<MessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default MessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"MessageManager.js","sourceRoot":"","sources":["../src/MessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,qEAMkC;AAClC,mCAAwE;AA2CxE;;GAEG;AACH,MAAa,cAAe,SAAQ,+CAInC;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,gBAAgB,CAAC;IAkDnC,CAAC;IAhDC;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAA4B,EAC5B,GAAqB;;YAErB,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAC9D,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAY;gBAC3B,EAAE,EAAE,SAAS;gBACb,aAAa;gBACb,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,UAAU;aACjB,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,aAAa,GACb,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAoC;QAEpC,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA1DD,wCA0DC;AAED,kBAAe,cAAc,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'eth_sign' type signature request.\n * These are created when a signature for an eth_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the eth_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'eth_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface Message extends AbstractMessage {\n  messageParams: MessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParams extends AbstractMessageParams {\n  data: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface MessageParamsMetamask extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class MessageManager extends AbstractMessageManager<\n  Message,\n  MessageParams,\n  MessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'MessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the eth_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: MessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateSignMessageData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n    const messageId = random();\n    const messageData: Message = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_sign',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...messageParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: MessageParamsMetamask,\n  ): Promise<MessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default MessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/PersonalMessageManager.d.ts b/dist/PersonalMessageManager.d.ts
index 5d25b78c9b47d8dcaf68cf792ebbb5847f5cfb34..078af884f42e2dce2488762a7dc3b779346fc307 100644
--- a/dist/PersonalMessageManager.d.ts
+++ b/dist/PersonalMessageManager.d.ts
@@ -47,15 +47,6 @@ export declare class PersonalMessageManager extends AbstractMessageManager<Perso
      * Name of this controller used during composition
      */
     name: string;
-    /**
-     * Creates a new Message with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
-     *
-     * @param messageParams - The params for the personal_sign call to be made after the message is approved.
-     * @param req - The original request object possibly containing the origin.
-     * @returns Promise resolving to the raw data of the signature request.
-     */
-    addUnapprovedMessageAsync(messageParams: PersonalMessageParams, req?: OriginalRequest): Promise<string>;
     /**
      * Creates a new Message with an 'unapproved' status using the passed messageParams.
      * this.addMessage is called to add the new Message to this.messages, and to save the
diff --git a/dist/PersonalMessageManager.d.ts.map b/dist/PersonalMessageManager.d.ts.map
index 52f9168ad170ae6517b582a0a16ff7abf37dee5f..ab04adca3384ebe5a1b90758f51cdeb4aabac270 100644
--- a/dist/PersonalMessageManager.d.ts.map
+++ b/dist/PersonalMessageManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"PersonalMessageManager.d.ts","sourceRoot":"","sources":["../src/PersonalMessageManager.ts"],"names":[],"mappings":"AACA,OAAO,EAAc,WAAW,EAAE,MAAM,4BAA4B,CAAC;AAErE,OAAO,EACL,sBAAsB,EACtB,eAAe,EACf,qBAAqB,EACrB,6BAA6B,EAC7B,eAAe,EAChB,MAAM,0BAA0B,CAAC;AAElC;;;;;;;;;;GAUG;AACH,MAAM,WAAW,eAAgB,SAAQ,eAAe;IACtD,aAAa,EAAE,qBAAqB,CAAC;CACtC;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,qBAAsB,SAAQ,qBAAqB;IAClE,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,WAAW,CAAC;CACpB;AAED;;;;;;;;;GASG;AACH,MAAM,WAAW,6BACf,SAAQ,6BAA6B;IACrC,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,sBAAsB,CAChE,eAAe,EACf,qBAAqB,EACrB,6BAA6B,CAC9B;IACC;;OAEG;IACM,IAAI,SAA4B;IAEzC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAAa,EAAE,qBAAqB,EACpC,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IA2BlB;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAa,EAAE,qBAAqB,EACpC,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IAyBlB;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAa,EAAE,6BAA6B,GAC3C,OAAO,CAAC,qBAAqB,CAAC;CAIlC;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"PersonalMessageManager.d.ts","sourceRoot":"","sources":["../src/PersonalMessageManager.ts"],"names":[],"mappings":"AACA,OAAO,EAAc,WAAW,EAAE,MAAM,4BAA4B,CAAC;AAErE,OAAO,EACL,sBAAsB,EACtB,eAAe,EACf,qBAAqB,EACrB,6BAA6B,EAC7B,eAAe,EAChB,MAAM,0BAA0B,CAAC;AAElC;;;;;;;;;;GAUG;AACH,MAAM,WAAW,eAAgB,SAAQ,eAAe;IACtD,aAAa,EAAE,qBAAqB,CAAC;CACtC;AAED;;;;;;;GAOG;AACH,MAAM,WAAW,qBAAsB,SAAQ,qBAAqB;IAClE,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,CAAC,EAAE,WAAW,CAAC;CACpB;AAED;;;;;;;;;GASG;AACH,MAAM,WAAW,6BACf,SAAQ,6BAA6B;IACrC,IAAI,EAAE,MAAM,CAAC;CACd;AAED;;GAEG;AACH,qBAAa,sBAAuB,SAAQ,sBAAsB,CAChE,eAAe,EACf,qBAAqB,EACrB,6BAA6B,CAC9B;IACC;;OAEG;IACM,IAAI,SAA4B;IAEzC;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAa,EAAE,qBAAqB,EACpC,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IA0BlB;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAa,EAAE,6BAA6B,GAC3C,OAAO,CAAC,qBAAqB,CAAC;CAIlC;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
diff --git a/dist/PersonalMessageManager.js b/dist/PersonalMessageManager.js
index ecb609b89a234d9f5341552d30a97eb14c66b3de..92e9b3d1465f24c0e309be9c368fff3b65ebf9a1 100644
--- a/dist/PersonalMessageManager.js
+++ b/dist/PersonalMessageManager.js
@@ -25,32 +25,6 @@ class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageMan
          */
         this.name = 'PersonalMessageManager';
     }
-    /**
-     * Creates a new Message with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
-     *
-     * @param messageParams - The params for the personal_sign call to be made after the message is approved.
-     * @param req - The original request object possibly containing the origin.
-     * @returns Promise resolving to the raw data of the signature request.
-     */
-    addUnapprovedMessageAsync(messageParams, req) {
-        return __awaiter(this, void 0, void 0, function* () {
-            (0, utils_1.validateSignMessageData)(messageParams);
-            const messageId = yield this.addUnapprovedMessage(messageParams, req);
-            return new Promise((resolve, reject) => {
-                this.hub.once(`${messageId}:finished`, (data) => {
-                    switch (data.status) {
-                        case 'signed':
-                            return resolve(data.rawSig);
-                        case 'rejected':
-                            return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
-                        default:
-                            return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
-                    }
-                });
-            });
-        });
-    }
     /**
      * Creates a new Message with an 'unapproved' status using the passed messageParams.
      * this.addMessage is called to add the new Message to this.messages, and to save the
@@ -63,6 +37,7 @@ class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageMan
      */
     addUnapprovedMessage(messageParams, req) {
         return __awaiter(this, void 0, void 0, function* () {
+            (0, utils_1.validateSignMessageData)(messageParams);
             if (req) {
                 messageParams.origin = req.origin;
             }
diff --git a/dist/PersonalMessageManager.js.map b/dist/PersonalMessageManager.js.map
index 647f41cd797ef3c61bbf06d9f71f67993e06fbb2..b23be961e065a2324c8fcb0cf69aa78d87c429a1 100644
--- a/dist/PersonalMessageManager.js.map
+++ b/dist/PersonalMessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"PersonalMessageManager.js","sourceRoot":"","sources":["../src/PersonalMessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,iEAAqE;AACrE,mCAAwE;AACxE,qEAMkC;AA6ClC;;GAEG;AACH,MAAa,sBAAuB,SAAQ,+CAI3C;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,wBAAwB,CAAC;IA2F3C,CAAC;IAzFC;;;;;;;OAOG;IACG,yBAAyB,CAC7B,aAAoC,EACpC,GAAqB;;YAErB,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;YACtE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,SAAS,WAAW,EAAE,CAAC,IAAqB,EAAE,EAAE;oBAC/D,QAAQ,IAAI,CAAC,MAAM,EAAE;wBACnB,KAAK,QAAQ;4BACX,OAAO,OAAO,CAAC,IAAI,CAAC,MAAgB,CAAC,CAAC;wBACxC,KAAK,UAAU;4BACb,OAAO,MAAM,CACX,IAAI,KAAK,CACP,qEAAqE,CACtE,CACF,CAAC;wBACJ;4BACE,OAAO,MAAM,CACX,IAAI,KAAK,CACP,yDAAyD,IAAI,CAAC,SAAS,CACrE,aAAa,CACd,EAAE,CACJ,CACF,CAAC;qBACL;gBACH,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;QACL,CAAC;KAAA;IAED;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAoC,EACpC,GAAqB;;YAErB,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAE9D,MAAM,kBAAkB,GAAG,IAAA,6BAAU,EAAC,aAAa,CAAC,CAAC;YACrD,MAAM,cAAc,mCAAQ,aAAa,KAAE,IAAI,EAAE,kBAAkB,GAAE,CAAC;YAEtE,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAoB;gBACnC,EAAE,EAAE,SAAS;gBACb,aAAa,EAAE,cAAc;gBAC7B,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,eAAe;aACtB,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,cAAc,GACd,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAA4C;QAE5C,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AAnGD,wDAmGC;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport { detectSIWE, SIWEMessage } from '@metamask/controller-utils';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'personal_sign' type signature request.\n * These are created when a signature for a personal_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the personal_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'personal_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface PersonalMessage extends AbstractMessage {\n  messageParams: PersonalMessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParams extends AbstractMessageParams {\n  data: string;\n  siwe?: SIWEMessage;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class PersonalMessageManager extends AbstractMessageManager<\n  PersonalMessage,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'PersonalMessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateSignMessageData(messageParams);\n    const messageId = await this.addUnapprovedMessage(messageParams, req);\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: PersonalMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Personal Message Signature: User denied message signature.',\n              ),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n\n    const ethereumSignInData = detectSIWE(messageParams);\n    const finalMsgParams = { ...messageParams, siwe: ethereumSignInData };\n\n    const messageId = random();\n    const messageData: PersonalMessage = {\n      id: messageId,\n      messageParams: finalMsgParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'personal_sign',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...finalMsgParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: PersonalMessageParamsMetamask,\n  ): Promise<PersonalMessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default PersonalMessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"PersonalMessageManager.js","sourceRoot":"","sources":["../src/PersonalMessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,iEAAqE;AACrE,mCAAwE;AACxE,qEAMkC;AA6ClC;;GAEG;AACH,MAAa,sBAAuB,SAAQ,+CAI3C;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,wBAAwB,CAAC;IAsD3C,CAAC;IApDC;;;;;;;;;OASG;IACG,oBAAoB,CACxB,aAAoC,EACpC,GAAqB;;YAErB,IAAA,+BAAuB,EAAC,aAAa,CAAC,CAAC;YACvC,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,aAAa,CAAC,IAAI,GAAG,IAAA,4BAAoB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;YAE9D,MAAM,kBAAkB,GAAG,IAAA,6BAAU,EAAC,aAAa,CAAC,CAAC;YACrD,MAAM,cAAc,mCAAQ,aAAa,KAAE,IAAI,EAAE,kBAAkB,GAAE,CAAC;YAEtE,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,WAAW,GAAoB;gBACnC,EAAE,EAAE,SAAS;gBACb,aAAa,EAAE,cAAc;gBAC7B,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,eAAe;aACtB,CAAC;YACF,MAAM,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,kCAC5B,cAAc,GACd,EAAE,UAAU,EAAE,SAAS,EAAE,EAC5B,CAAC;YACH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAA4C;QAE5C,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AA9DD,wDA8DC;AAED,kBAAe,sBAAsB,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport { detectSIWE, SIWEMessage } from '@metamask/controller-utils';\nimport { normalizeMessageData, validateSignMessageData } from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type Message\n *\n * Represents and contains data about a 'personal_sign' type signature request.\n * These are created when a signature for a personal_sign call is requested.\n * @property id - An id to track and identify the message object\n * @property messageParams - The parameters to pass to the personal_sign method once the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a 'personal_sign' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface PersonalMessage extends AbstractMessage {\n  messageParams: PersonalMessageParams;\n}\n\n/**\n * @type PersonalMessageParams\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParams extends AbstractMessageParams {\n  data: string;\n  siwe?: SIWEMessage;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the personal_sign method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer data of the signature request\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface PersonalMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport class PersonalMessageManager extends AbstractMessageManager<\n  PersonalMessage,\n  PersonalMessageParams,\n  PersonalMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'PersonalMessageManager';\n\n  /**\n   * Creates a new Message with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new Message to this.messages, and to save the\n   * unapproved Messages.\n   *\n   * @param messageParams - The params for the personal_sign call to be made after the message\n   * is approved.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created message.\n   */\n  async addUnapprovedMessage(\n    messageParams: PersonalMessageParams,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    validateSignMessageData(messageParams);\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    messageParams.data = normalizeMessageData(messageParams.data);\n\n    const ethereumSignInData = detectSIWE(messageParams);\n    const finalMsgParams = { ...messageParams, siwe: ethereumSignInData };\n\n    const messageId = random();\n    const messageData: PersonalMessage = {\n      id: messageId,\n      messageParams: finalMsgParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'personal_sign',\n    };\n    await this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, {\n      ...finalMsgParams,\n      ...{ metamaskId: messageId },\n    });\n    return messageId;\n  }\n\n  /**\n   * Removes the metamaskId property from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId property removed.\n   */\n  prepMessageForSigning(\n    messageParams: PersonalMessageParamsMetamask,\n  ): Promise<PersonalMessageParams> {\n    delete messageParams.metamaskId;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default PersonalMessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/TypedMessageManager.d.ts b/dist/TypedMessageManager.d.ts
index ff4c1eb5d1355a90718d779a42c333de266eff0b..faf84898085cb99cc77c7603a5625884d076823e 100644
--- a/dist/TypedMessageManager.d.ts
+++ b/dist/TypedMessageManager.d.ts
@@ -59,16 +59,6 @@ export declare class TypedMessageManager extends AbstractMessageManager<TypedMes
      * Name of this controller used during composition
      */
     name: string;
-    /**
-     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
-     *
-     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.
-     * @param version - Compatibility version EIP712.
-     * @param req - The original request object possibly containing the origin.
-     * @returns Promise resolving to the raw data of the signature request.
-     */
-    addUnapprovedMessageAsync(messageParams: TypedMessageParams, version: string, req?: OriginalRequest): Promise<string>;
     /**
      * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
      * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
diff --git a/dist/TypedMessageManager.d.ts.map b/dist/TypedMessageManager.d.ts.map
index 82a9c71a4f05435c050dc48972ab8d8ae3d4ac91..26ed3feb6b94762523853409d80c0301a3d2110e 100644
--- a/dist/TypedMessageManager.d.ts.map
+++ b/dist/TypedMessageManager.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"TypedMessageManager.d.ts","sourceRoot":"","sources":["../src/TypedMessageManager.ts"],"names":[],"mappings":"AAKA,OAAO,EACL,sBAAsB,EACtB,eAAe,EACf,qBAAqB,EACrB,6BAA6B,EAC7B,eAAe,EAChB,MAAM,0BAA0B,CAAC;AAElC;;;;;;;;;;;;GAYG;AACH,MAAM,WAAW,YAAa,SAAQ,eAAe;IACnD,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,aAAa,EAAE,kBAAkB,CAAC;IAClC,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB;AAED;;;;;;;;GAQG;AACH,MAAM,WAAW,kBAAmB,SAAQ,qBAAqB;IAC/D,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,GAAG,MAAM,CAAC;CAC1C;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,WAAW,0BACf,SAAQ,6BAA6B;IACrC,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,GAAG,MAAM,CAAC;IACzC,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB;AAED;;GAEG;AACH,qBAAa,mBAAoB,SAAQ,sBAAsB,CAC7D,YAAY,EACZ,kBAAkB,EAClB,0BAA0B,CAC3B;IACC;;OAEG;IACM,IAAI,SAAyB;IAEtC;;;;;;;;OAQG;IACG,yBAAyB,CAC7B,aAAa,EAAE,kBAAkB,EACjC,OAAO,EAAE,MAAM,EACf,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IA0ClB;;;;;;;;;;OAUG;IACG,oBAAoB,CACxB,aAAa,EAAE,kBAAkB,EACjC,OAAO,EAAE,MAAM,EACf,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IAsBlB;;;;;OAKG;IACH,uBAAuB,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;IAWxD;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAa,EAAE,0BAA0B,GACxC,OAAO,CAAC,kBAAkB,CAAC;CAK/B;AAED,eAAe,mBAAmB,CAAC"}
\ No newline at end of file
+{"version":3,"file":"TypedMessageManager.d.ts","sourceRoot":"","sources":["../src/TypedMessageManager.ts"],"names":[],"mappings":"AAKA,OAAO,EACL,sBAAsB,EACtB,eAAe,EACf,qBAAqB,EACrB,6BAA6B,EAC7B,eAAe,EAChB,MAAM,0BAA0B,CAAC;AAElC;;;;;;;;;;;;GAYG;AACH,MAAM,WAAW,YAAa,SAAQ,eAAe;IACnD,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,aAAa,EAAE,kBAAkB,CAAC;IAClC,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,EAAE,MAAM,CAAC;IACf,IAAI,EAAE,MAAM,CAAC;IACb,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB;AAED;;;;;;;;GAQG;AACH,MAAM,WAAW,kBAAmB,SAAQ,qBAAqB;IAC/D,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,GAAG,MAAM,CAAC;CAC1C;AAED;;;;;;;;;;;;GAYG;AACH,MAAM,WAAW,0BACf,SAAQ,6BAA6B;IACrC,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,GAAG,MAAM,CAAC;IACzC,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB;AAED;;GAEG;AACH,qBAAa,mBAAoB,SAAQ,sBAAsB,CAC7D,YAAY,EACZ,kBAAkB,EAClB,0BAA0B,CAC3B;IACC;;OAEG;IACM,IAAI,SAAyB;IAEtC;;;;;;;;;;OAUG;IACG,oBAAoB,CACxB,aAAa,EAAE,kBAAkB,EACjC,OAAO,EAAE,MAAM,EACf,GAAG,CAAC,EAAE,eAAe,GACpB,OAAO,CAAC,MAAM,CAAC;IA+BlB;;;;;OAKG;IACH,uBAAuB,CAAC,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM;IAWxD;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAa,EAAE,0BAA0B,GACxC,OAAO,CAAC,kBAAkB,CAAC;CAK/B;AAED,eAAe,mBAAmB,CAAC"}
\ No newline at end of file
diff --git a/dist/TypedMessageManager.js b/dist/TypedMessageManager.js
index 2517e7e0acf7422d47ab960cafd3b7d3393cb403..8e4576c15e8445b297cb72d0f8e0b3644006f249 100644
--- a/dist/TypedMessageManager.js
+++ b/dist/TypedMessageManager.js
@@ -26,14 +26,16 @@ class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManage
     }
     /**
      * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
+     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
+     * unapproved TypedMessages.
      *
-     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.
+     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
+     * is approved.
      * @param version - Compatibility version EIP712.
      * @param req - The original request object possibly containing the origin.
-     * @returns Promise resolving to the raw data of the signature request.
+     * @returns The id of the newly created TypedMessage.
      */
-    addUnapprovedMessageAsync(messageParams, version, req) {
+    addUnapprovedMessage(messageParams, version, req) {
         var _a;
         return __awaiter(this, void 0, void 0, function* () {
             if (version === 'V1') {
@@ -43,36 +45,6 @@ class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManage
                 const currentChainId = (_a = this.getCurrentChainId) === null || _a === void 0 ? void 0 : _a.call(this);
                 (0, utils_1.validateTypedSignMessageDataV3V4)(messageParams, currentChainId);
             }
-            const messageId = yield this.addUnapprovedMessage(messageParams, version, req);
-            return new Promise((resolve, reject) => {
-                this.hub.once(`${messageId}:finished`, (data) => {
-                    switch (data.status) {
-                        case 'signed':
-                            return resolve(data.rawSig);
-                        case 'rejected':
-                            return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
-                        case 'errored':
-                            return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
-                        default:
-                            return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
-                    }
-                });
-            });
-        });
-    }
-    /**
-     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
-     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
-     * unapproved TypedMessages.
-     *
-     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
-     * is approved.
-     * @param version - Compatibility version EIP712.
-     * @param req - The original request object possibly containing the origin.
-     * @returns The id of the newly created TypedMessage.
-     */
-    addUnapprovedMessage(messageParams, version, req) {
-        return __awaiter(this, void 0, void 0, function* () {
             const messageId = (0, uuid_1.v1)();
             const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
             if (req) {
diff --git a/dist/TypedMessageManager.js.map b/dist/TypedMessageManager.js.map
index 95b7cf0fe323c64de38b99e7c468e46b4eef8c9c..2fee30e2c9ff75cf75002f4108ea693fd8918db3 100644
--- a/dist/TypedMessageManager.js.map
+++ b/dist/TypedMessageManager.js.map
@@ -1 +1 @@
-{"version":3,"file":"TypedMessageManager.js","sourceRoot":"","sources":["../src/TypedMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  validateTypedSignMessageDataV1,\n  validateTypedSignMessageDataV3V4,\n} from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type TypedMessage\n *\n * Represents and contains data about an 'eth_signTypedData' type signature request.\n * These are created when a signature for an eth_signTypedData call is requested.\n * @property id - An id to track and identify the message object\n * @property error - Error corresponding to eth_signTypedData error in failure case\n * @property messageParams - The parameters to pass to the eth_signTypedData method once\n * the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'TypedMessage' which always has a 'eth_signTypedData' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface TypedMessage extends AbstractMessage {\n  error?: string;\n  messageParams: TypedMessageParams;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n}\n\n/**\n * @type TypedMessageParams\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface TypedMessageParams extends AbstractMessageParams {\n  data: Record<string, unknown>[] | string;\n}\n\n/**\n * @type TypedMessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property error? - Added for message errored\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n * @property version - Compatibility version EIP712\n */\nexport interface TypedMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: Record<string, unknown>[] | string;\n  metamaskId?: string;\n  error?: string;\n  version?: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.\n */\nexport class TypedMessageManager extends AbstractMessageManager<\n  TypedMessage,\n  TypedMessageParams,\n  TypedMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TypedMessageManager';\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns Promise resolving to the raw data of the signature request.\n   */\n  async addUnapprovedMessageAsync(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (version === 'V1') {\n      validateTypedSignMessageDataV1(messageParams);\n    }\n\n    if (version === 'V3' || version === 'V4') {\n      const currentChainId = this.getCurrentChainId?.();\n      validateTypedSignMessageDataV3V4(messageParams, currentChainId);\n    }\n    const messageId = await this.addUnapprovedMessage(\n      messageParams,\n      version,\n      req,\n    );\n    return new Promise((resolve, reject) => {\n      this.hub.once(`${messageId}:finished`, (data: TypedMessage) => {\n        switch (data.status) {\n          case 'signed':\n            return resolve(data.rawSig as string);\n          case 'rejected':\n            return reject(\n              new Error(\n                'MetaMask Typed Message Signature: User denied message signature.',\n              ),\n            );\n          case 'errored':\n            return reject(\n              new Error(`MetaMask Typed Message Signature: ${data.error}`),\n            );\n          default:\n            return reject(\n              new Error(\n                `MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(\n                  messageParams,\n                )}`,\n              ),\n            );\n        }\n      });\n    });\n  }\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the\n   * unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message\n   * is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created TypedMessage.\n   */\n  async addUnapprovedMessage(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    const messageId = random();\n    const messageParamsMetamask = {\n      ...messageParams,\n      metamaskId: messageId,\n      version,\n    };\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageData: TypedMessage = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_signTypedData',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, messageParamsMetamask);\n    return messageId;\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the TypedMessage to error.\n   * @param error - The error to be included in TypedMessage.\n   */\n  setMessageStatusErrored(messageId: string, error: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.error = error;\n    this.updateMessage(message);\n    this.setMessageStatus(messageId, 'errored');\n  }\n\n  /**\n   * Removes the metamaskId and version properties from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId and version properties removed.\n   */\n  prepMessageForSigning(\n    messageParams: TypedMessageParamsMetamask,\n  ): Promise<TypedMessageParams> {\n    delete messageParams.metamaskId;\n    delete messageParams.version;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default TypedMessageManager;\n"]}
\ No newline at end of file
+{"version":3,"file":"TypedMessageManager.js","sourceRoot":"","sources":["../src/TypedMessageManager.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,+BAAoC;AACpC,mCAGiB;AACjB,qEAMkC;AA0DlC;;GAEG;AACH,MAAa,mBAAoB,SAAQ,+CAIxC;IAJD;;QAKE;;WAEG;QACM,SAAI,GAAG,qBAAqB,CAAC;IA+ExC,CAAC;IA7EC;;;;;;;;;;OAUG;IACG,oBAAoB,CACxB,aAAiC,EACjC,OAAe,EACf,GAAqB;;;YAErB,IAAI,OAAO,KAAK,IAAI,EAAE;gBACpB,IAAA,sCAA8B,EAAC,aAAa,CAAC,CAAC;aAC/C;YAED,IAAI,OAAO,KAAK,IAAI,IAAI,OAAO,KAAK,IAAI,EAAE;gBACxC,MAAM,cAAc,GAAG,MAAA,IAAI,CAAC,iBAAiB,oDAAI,CAAC;gBAClD,IAAA,wCAAgC,EAAC,aAAa,EAAE,cAAc,CAAC,CAAC;aACjE;YAED,MAAM,SAAS,GAAG,IAAA,SAAM,GAAE,CAAC;YAC3B,MAAM,qBAAqB,mCACtB,aAAa,KAChB,UAAU,EAAE,SAAS,EACrB,OAAO,GACR,CAAC;YACF,IAAI,GAAG,EAAE;gBACP,aAAa,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;aACnC;YACD,MAAM,WAAW,GAAiB;gBAChC,EAAE,EAAE,SAAS;gBACb,aAAa;gBACb,MAAM,EAAE,YAAY;gBACpB,IAAI,EAAE,IAAI,CAAC,GAAG,EAAE;gBAChB,IAAI,EAAE,mBAAmB;aAC1B,CAAC;YACF,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;YAC7B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,EAAE,qBAAqB,CAAC,CAAC;YAC1D,OAAO,SAAS,CAAC;;KAClB;IAED;;;;;OAKG;IACH,uBAAuB,CAAC,SAAiB,EAAE,KAAa;QACtD,MAAM,OAAO,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAC3C,wBAAwB;QACxB,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO;SACR;QACD,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;QAC5B,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;IAC9C,CAAC;IAED;;;;;;OAMG;IACH,qBAAqB,CACnB,aAAyC;QAEzC,OAAO,aAAa,CAAC,UAAU,CAAC;QAChC,OAAO,aAAa,CAAC,OAAO,CAAC;QAC7B,OAAO,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;IACxC,CAAC;CACF;AAvFD,kDAuFC;AAED,kBAAe,mBAAmB,CAAC","sourcesContent":["import { v1 as random } from 'uuid';\nimport {\n  validateTypedSignMessageDataV1,\n  validateTypedSignMessageDataV3V4,\n} from './utils';\nimport {\n  AbstractMessageManager,\n  AbstractMessage,\n  AbstractMessageParams,\n  AbstractMessageParamsMetamask,\n  OriginalRequest,\n} from './AbstractMessageManager';\n\n/**\n * @type TypedMessage\n *\n * Represents and contains data about an 'eth_signTypedData' type signature request.\n * These are created when a signature for an eth_signTypedData call is requested.\n * @property id - An id to track and identify the message object\n * @property error - Error corresponding to eth_signTypedData error in failure case\n * @property messageParams - The parameters to pass to the eth_signTypedData method once\n * the signature request is approved\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'TypedMessage' which always has a 'eth_signTypedData' type\n * @property rawSig - Raw data of the signature request\n */\nexport interface TypedMessage extends AbstractMessage {\n  error?: string;\n  messageParams: TypedMessageParams;\n  time: number;\n  status: string;\n  type: string;\n  rawSig?: string;\n}\n\n/**\n * @type TypedMessageParams\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved.\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface TypedMessageParams extends AbstractMessageParams {\n  data: Record<string, unknown>[] | string;\n}\n\n/**\n * @type TypedMessageParamsMetamask\n *\n * Represents the parameters to pass to the eth_signTypedData method once the signature request is approved\n * plus data added by MetaMask.\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property data - A hex string conversion of the raw buffer or an object containing data of the signature\n * request depending on version\n * @property error? - Added for message errored\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n * @property version - Compatibility version EIP712\n */\nexport interface TypedMessageParamsMetamask\n  extends AbstractMessageParamsMetamask {\n  data: Record<string, unknown>[] | string;\n  metamaskId?: string;\n  error?: string;\n  version?: string;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.\n */\nexport class TypedMessageManager extends AbstractMessageManager<\n  TypedMessage,\n  TypedMessageParams,\n  TypedMessageParamsMetamask\n> {\n  /**\n   * Name of this controller used during composition\n   */\n  override name = 'TypedMessageManager';\n\n  /**\n   * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.\n   * this.addMessage is called to add the new TypedMessage to this.messages, and to save the\n   * unapproved TypedMessages.\n   *\n   * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message\n   * is approved.\n   * @param version - Compatibility version EIP712.\n   * @param req - The original request object possibly containing the origin.\n   * @returns The id of the newly created TypedMessage.\n   */\n  async addUnapprovedMessage(\n    messageParams: TypedMessageParams,\n    version: string,\n    req?: OriginalRequest,\n  ): Promise<string> {\n    if (version === 'V1') {\n      validateTypedSignMessageDataV1(messageParams);\n    }\n\n    if (version === 'V3' || version === 'V4') {\n      const currentChainId = this.getCurrentChainId?.();\n      validateTypedSignMessageDataV3V4(messageParams, currentChainId);\n    }\n\n    const messageId = random();\n    const messageParamsMetamask = {\n      ...messageParams,\n      metamaskId: messageId,\n      version,\n    };\n    if (req) {\n      messageParams.origin = req.origin;\n    }\n    const messageData: TypedMessage = {\n      id: messageId,\n      messageParams,\n      status: 'unapproved',\n      time: Date.now(),\n      type: 'eth_signTypedData',\n    };\n    this.addMessage(messageData);\n    this.hub.emit(`unapprovedMessage`, messageParamsMetamask);\n    return messageId;\n  }\n\n  /**\n   * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.\n   *\n   * @param messageId - The id of the TypedMessage to error.\n   * @param error - The error to be included in TypedMessage.\n   */\n  setMessageStatusErrored(messageId: string, error: string) {\n    const message = this.getMessage(messageId);\n    /* istanbul ignore if */\n    if (!message) {\n      return;\n    }\n    message.error = error;\n    this.updateMessage(message);\n    this.setMessageStatus(messageId, 'errored');\n  }\n\n  /**\n   * Removes the metamaskId and version properties from passed messageParams and returns a promise which\n   * resolves the updated messageParams.\n   *\n   * @param messageParams - The messageParams to modify.\n   * @returns Promise resolving to the messageParams with the metamaskId and version properties removed.\n   */\n  prepMessageForSigning(\n    messageParams: TypedMessageParamsMetamask,\n  ): Promise<TypedMessageParams> {\n    delete messageParams.metamaskId;\n    delete messageParams.version;\n    return Promise.resolve(messageParams);\n  }\n}\n\nexport default TypedMessageManager;\n"]}
\ No newline at end of file
diff --git a/dist/utils.d.ts b/dist/utils.d.ts
index b0c1923a56eff35bb5a8bb38c0f6afcb520bbe6f..ec7107d27a450cc67cb2fef46a186717356fcbb2 100644
--- a/dist/utils.d.ts
+++ b/dist/utils.d.ts
@@ -1,3 +1,4 @@
+import type { Hex } from '@metamask/utils';
 import { MessageParams } from './MessageManager';
 import { PersonalMessageParams } from './PersonalMessageManager';
 import { TypedMessageParams } from './TypedMessageManager';
@@ -32,7 +33,7 @@ export declare function validateTypedSignMessageDataV1(messageData: TypedMessage
  * @param messageData - TypedMessageParams object to validate.
  * @param currentChainId - The current chainId.
  */
-export declare function validateTypedSignMessageDataV3V4(messageData: TypedMessageParams, currentChainId: string | undefined): void;
+export declare function validateTypedSignMessageDataV3V4(messageData: TypedMessageParams, currentChainId: Hex | undefined): void;
 /**
  * Validates messageData for the eth_getEncryptionPublicKey message and throws in
  * the event of any validation error.
diff --git a/dist/utils.d.ts.map b/dist/utils.d.ts.map
index 20e596bf877990707741ca631eea06ad60d4bce2..0fda7803daf10ef89f8927d96e662159b3323459 100644
--- a/dist/utils.d.ts.map
+++ b/dist/utils.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AACjD,OAAO,EAAE,qBAAqB,EAAE,MAAM,0BAA0B,CAAC;AACjE,OAAO,EAAE,kBAAkB,EAAE,MAAM,uBAAuB,CAAC;AAC3D,OAAO,EAAE,yBAAyB,EAAE,MAAM,8BAA8B,CAAC;AACzE,OAAO,EAAE,oBAAoB,EAAE,MAAM,yBAAyB,CAAC;AAiB/D;;;;;;GAMG;AACH,wBAAgB,oBAAoB,CAAC,IAAI,EAAE,MAAM,UAUhD;AAED;;;;;GAKG;AACH,wBAAgB,uBAAuB,CACrC,WAAW,EAAE,qBAAqB,GAAG,aAAa,QAQnD;AAED;;;;;GAKG;AACH,wBAAgB,8BAA8B,CAC5C,WAAW,EAAE,kBAAkB,QAgBhC;AAED;;;;;;GAMG;AACH,wBAAgB,gCAAgC,CAC9C,WAAW,EAAE,kBAAkB,EAC/B,cAAc,EAAE,MAAM,GAAG,SAAS,QA6CnC;AAED;;;;;GAKG;AACH,wBAAgB,sCAAsC,CACpD,WAAW,EAAE,yBAAyB,QAIvC;AAED;;;;;GAKG;AACH,wBAAgB,4BAA4B,CAC1C,WAAW,EAAE,oBAAoB,QAIlC"}
\ No newline at end of file
+{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"AAGA,OAAO,KAAK,EAAE,GAAG,EAAE,MAAM,iBAAiB,CAAC;AAE3C,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AACjD,OAAO,EAAE,qBAAqB,EAAE,MAAM,0BAA0B,CAAC;AACjE,OAAO,EAAE,kBAAkB,EAAE,MAAM,uBAAuB,CAAC;AAC3D,OAAO,EAAE,yBAAyB,EAAE,MAAM,8BAA8B,CAAC;AACzE,OAAO,EAAE,oBAAoB,EAAE,MAAM,yBAAyB,CAAC;AAiB/D;;;;;;GAMG;AACH,wBAAgB,oBAAoB,CAAC,IAAI,EAAE,MAAM,UAUhD;AAED;;;;;GAKG;AACH,wBAAgB,uBAAuB,CACrC,WAAW,EAAE,qBAAqB,GAAG,aAAa,QAQnD;AAED;;;;;GAKG;AACH,wBAAgB,8BAA8B,CAC5C,WAAW,EAAE,kBAAkB,QAgBhC;AAED;;;;;;GAMG;AACH,wBAAgB,gCAAgC,CAC9C,WAAW,EAAE,kBAAkB,EAC/B,cAAc,EAAE,GAAG,GAAG,SAAS,QA6ChC;AAED;;;;;GAKG;AACH,wBAAgB,sCAAsC,CACpD,WAAW,EAAE,yBAAyB,QAIvC;AAED;;;;;GAKG;AACH,wBAAgB,4BAA4B,CAC1C,WAAW,EAAE,oBAAoB,QAIlC"}
\ No newline at end of file
diff --git a/dist/utils.js.map b/dist/utils.js.map
index cb64ecd62c8af51e0a529b120e8095a60bc5eef4..6b0c3cc664c7b83b0807fb64647104ef818ed3f7 100644
--- a/dist/utils.js.map
+++ b/dist/utils.js.map
@@ -1 +1 @@
-{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { addHexPrefix, bufferToHex, stripHexPrefix } from 'ethereumjs-util';\nimport { TYPED_MESSAGE_SCHEMA, typedSignatureHash } from 'eth-sig-util';\nimport { validate } from 'jsonschema';\nimport { isValidHexAddress } from '@metamask/controller-utils';\nimport { MessageParams } from './MessageManager';\nimport { PersonalMessageParams } from './PersonalMessageManager';\nimport { TypedMessageParams } from './TypedMessageManager';\nimport { EncryptionPublicKeyParams } from './EncryptionPublicKeyManager';\nimport { DecryptMessageParams } from './DecryptMessageManager';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n/**\n * Validates an address string and throws in the event of any validation error.\n *\n * @param address - The address to validate.\n * @param propertyName - The name of the property source to use in the error message.\n */\nfunction validateAddress(address: string, propertyName: string) {\n  if (!address || typeof address !== 'string' || !isValidHexAddress(address)) {\n    throw new Error(\n      `Invalid \"${propertyName}\" address: ${address} must be a valid string.`,\n    );\n  }\n}\n\n/**\n * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if\n * it is already formatted as a hex.\n *\n * @param data - The buffer data to convert to a hex.\n * @returns A hex string conversion of the buffer data.\n */\nexport function normalizeMessageData(data: string) {\n  try {\n    const stripped = stripHexPrefix(data);\n    if (stripped.match(hexRe)) {\n      return addHexPrefix(stripped);\n    }\n  } catch (e) {\n    /* istanbul ignore next */\n  }\n  return bufferToHex(Buffer.from(data, 'utf8'));\n}\n\n/**\n * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in\n * the event of any validation error.\n *\n * @param messageData - PersonalMessageParams object to validate.\n */\nexport function validateSignMessageData(\n  messageData: PersonalMessageParams | MessageParams,\n) {\n  const { from, data } = messageData;\n  validateAddress(from, 'from');\n\n  if (!data || typeof data !== 'string') {\n    throw new Error(`Invalid message \"data\": ${data} must be a valid string.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V1.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV1(\n  messageData: TypedMessageParams,\n) {\n  validateAddress(messageData.from, 'from');\n\n  if (!messageData.data || !Array.isArray(messageData.data)) {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n\n  try {\n    // typedSignatureHash will throw if the data is invalid.\n    typedSignatureHash(messageData.data as any);\n  } catch (e) {\n    throw new Error(`Expected EIP712 typed data.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V3.\n *\n * @param messageData - TypedMessageParams object to validate.\n * @param currentChainId - The current chainId.\n */\nexport function validateTypedSignMessageDataV3V4(\n  messageData: TypedMessageParams,\n  currentChainId: string | undefined,\n) {\n  validateAddress(messageData.from, 'from');\n\n  if (!messageData.data || typeof messageData.data !== 'string') {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n  let data;\n  try {\n    data = JSON.parse(messageData.data);\n  } catch (e) {\n    throw new Error('Data must be passed as a valid JSON string.');\n  }\n  const validation = validate(data, TYPED_MESSAGE_SCHEMA);\n  if (validation.errors.length > 0) {\n    throw new Error(\n      'Data must conform to EIP-712 schema. See https://git.io/fNtcx.',\n    );\n  }\n\n  if (!currentChainId) {\n    throw new Error('Current chainId cannot be null or undefined.');\n  }\n\n  let { chainId } = data.domain;\n  if (chainId) {\n    if (typeof chainId === 'string') {\n      chainId = parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);\n    }\n\n    const activeChainId = parseInt(currentChainId, 16);\n    if (Number.isNaN(activeChainId)) {\n      throw new Error(\n        `Cannot sign messages for chainId \"${chainId}\", because MetaMask is switching networks.`,\n      );\n    }\n\n    if (chainId !== activeChainId) {\n      throw new Error(\n        `Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`,\n      );\n    }\n  }\n}\n\n/**\n * Validates messageData for the eth_getEncryptionPublicKey message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateEncryptionPublicKeyMessageData(\n  messageData: EncryptionPublicKeyParams,\n) {\n  const { from } = messageData;\n  validateAddress(from, 'from');\n}\n\n/**\n * Validates messageData for the eth_decrypt message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateDecryptedMessageData(\n  messageData: DecryptMessageParams,\n) {\n  const { from } = messageData;\n  validateAddress(from, 'from');\n}\n"]}
\ No newline at end of file
+{"version":3,"file":"utils.js","sourceRoot":"","sources":["../src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { addHexPrefix, bufferToHex, stripHexPrefix } from 'ethereumjs-util';\nimport { TYPED_MESSAGE_SCHEMA, typedSignatureHash } from 'eth-sig-util';\nimport { validate } from 'jsonschema';\nimport type { Hex } from '@metamask/utils';\nimport { isValidHexAddress } from '@metamask/controller-utils';\nimport { MessageParams } from './MessageManager';\nimport { PersonalMessageParams } from './PersonalMessageManager';\nimport { TypedMessageParams } from './TypedMessageManager';\nimport { EncryptionPublicKeyParams } from './EncryptionPublicKeyManager';\nimport { DecryptMessageParams } from './DecryptMessageManager';\n\nconst hexRe = /^[0-9A-Fa-f]+$/gu;\n/**\n * Validates an address string and throws in the event of any validation error.\n *\n * @param address - The address to validate.\n * @param propertyName - The name of the property source to use in the error message.\n */\nfunction validateAddress(address: string, propertyName: string) {\n  if (!address || typeof address !== 'string' || !isValidHexAddress(address)) {\n    throw new Error(\n      `Invalid \"${propertyName}\" address: ${address} must be a valid string.`,\n    );\n  }\n}\n\n/**\n * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if\n * it is already formatted as a hex.\n *\n * @param data - The buffer data to convert to a hex.\n * @returns A hex string conversion of the buffer data.\n */\nexport function normalizeMessageData(data: string) {\n  try {\n    const stripped = stripHexPrefix(data);\n    if (stripped.match(hexRe)) {\n      return addHexPrefix(stripped);\n    }\n  } catch (e) {\n    /* istanbul ignore next */\n  }\n  return bufferToHex(Buffer.from(data, 'utf8'));\n}\n\n/**\n * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in\n * the event of any validation error.\n *\n * @param messageData - PersonalMessageParams object to validate.\n */\nexport function validateSignMessageData(\n  messageData: PersonalMessageParams | MessageParams,\n) {\n  const { from, data } = messageData;\n  validateAddress(from, 'from');\n\n  if (!data || typeof data !== 'string') {\n    throw new Error(`Invalid message \"data\": ${data} must be a valid string.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V1.\n *\n * @param messageData - TypedMessageParams object to validate.\n */\nexport function validateTypedSignMessageDataV1(\n  messageData: TypedMessageParams,\n) {\n  validateAddress(messageData.from, 'from');\n\n  if (!messageData.data || !Array.isArray(messageData.data)) {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n\n  try {\n    // typedSignatureHash will throw if the data is invalid.\n    typedSignatureHash(messageData.data as any);\n  } catch (e) {\n    throw new Error(`Expected EIP712 typed data.`);\n  }\n}\n\n/**\n * Validates a TypedMessageParams object for required properties and throws in\n * the event of any validation error for eth_signTypedMessage_V3.\n *\n * @param messageData - TypedMessageParams object to validate.\n * @param currentChainId - The current chainId.\n */\nexport function validateTypedSignMessageDataV3V4(\n  messageData: TypedMessageParams,\n  currentChainId: Hex | undefined,\n) {\n  validateAddress(messageData.from, 'from');\n\n  if (!messageData.data || typeof messageData.data !== 'string') {\n    throw new Error(\n      `Invalid message \"data\": ${messageData.data} must be a valid array.`,\n    );\n  }\n  let data;\n  try {\n    data = JSON.parse(messageData.data);\n  } catch (e) {\n    throw new Error('Data must be passed as a valid JSON string.');\n  }\n  const validation = validate(data, TYPED_MESSAGE_SCHEMA);\n  if (validation.errors.length > 0) {\n    throw new Error(\n      'Data must conform to EIP-712 schema. See https://git.io/fNtcx.',\n    );\n  }\n\n  if (!currentChainId) {\n    throw new Error('Current chainId cannot be null or undefined.');\n  }\n\n  let { chainId } = data.domain;\n  if (chainId) {\n    if (typeof chainId === 'string') {\n      chainId = parseInt(chainId, chainId.startsWith('0x') ? 16 : 10);\n    }\n\n    const activeChainId = parseInt(currentChainId, 16);\n    if (Number.isNaN(activeChainId)) {\n      throw new Error(\n        `Cannot sign messages for chainId \"${chainId}\", because MetaMask is switching networks.`,\n      );\n    }\n\n    if (chainId !== activeChainId) {\n      throw new Error(\n        `Provided chainId \"${chainId}\" must match the active chainId \"${activeChainId}\"`,\n      );\n    }\n  }\n}\n\n/**\n * Validates messageData for the eth_getEncryptionPublicKey message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateEncryptionPublicKeyMessageData(\n  messageData: EncryptionPublicKeyParams,\n) {\n  const { from } = messageData;\n  validateAddress(from, 'from');\n}\n\n/**\n * Validates messageData for the eth_decrypt message and throws in\n * the event of any validation error.\n *\n * @param messageData - address string to validate.\n */\nexport function validateDecryptedMessageData(\n  messageData: DecryptMessageParams,\n) {\n  const { from } = messageData;\n  validateAddress(from, 'from');\n}\n"]}
\ No newline at end of file
