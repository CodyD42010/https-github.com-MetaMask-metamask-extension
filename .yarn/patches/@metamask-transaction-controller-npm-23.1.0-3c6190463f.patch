diff --git a/dist/TransactionController.d.ts b/dist/TransactionController.d.ts
index 9a10745d7c5adaec8798a00a3f8c9949fb976f20..24ee94eead19450109b26f11dd6e8c76a0fecfc3 100644
--- a/dist/TransactionController.d.ts
+++ b/dist/TransactionController.d.ts
@@ -100,6 +100,7 @@ export declare type PendingTransactionOptions = {
  * @property getSavedGasFees - Gets the saved gas fee config.
  * @property getSelectedAddress - Gets the address of the currently selected account.
  * @property incomingTransactions - Configuration options for incoming transaction support.
+ * @property isSimulationEnabled - Whether new transactions will be automatically simulated.
  * @property messenger - The controller messenger.
  * @property onNetworkStateChange - Allows subscribing to network controller state changes.
  * @property pendingTransactions - Configuration options for pending transaction support.
@@ -127,6 +128,7 @@ export declare type TransactionControllerOptions = {
     getSavedGasFees?: (chainId: Hex) => SavedGasFees | undefined;
     getSelectedAddress: () => string;
     incomingTransactions?: IncomingTransactionOptions;
+    isSimulationEnabled?: () => boolean;
     messenger: TransactionControllerMessenger;
     onNetworkStateChange: (listener: (state: NetworkState) => void) => void;
     pendingTransactions?: PendingTransactionOptions;
@@ -188,6 +190,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly securityProviderRequest?;
     private readonly pendingTransactionTracker;
     private readonly signAbortCallbacks;
+    private readonly isSimulationEnabled;
     private readonly afterSign;
     private readonly beforeApproveOnInit;
     private readonly beforeCheckPendingTransaction;
@@ -208,7 +211,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
      * Method used to sign transactions
      */
     sign?: (transaction: TypedTransaction, from: string, transactionMeta?: TransactionMeta) => Promise<TypedTransaction>;
-    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions, messenger, onNetworkStateChange, pendingTransactions, provider, securityProviderRequest, getNetworkClientRegistry, isMultichainEnabled, hooks, }: TransactionControllerOptions, config?: Partial<TransactionConfig>, state?: Partial<TransactionState>);
+    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions, isSimulationEnabled, messenger, onNetworkStateChange, pendingTransactions, provider, securityProviderRequest, getNetworkClientRegistry, isMultichainEnabled, hooks, }: TransactionControllerOptions, config?: Partial<TransactionConfig>, state?: Partial<TransactionState>);
     /**
      * Stops polling and removes listeners to prepare the controller for garbage collection.
      */
diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 870c8395b36b7baf1cb73def4580aeddb850c039..01220b2e3c95adcf650ea3e8b6afbaaa19d008be 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -22,7 +22,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _TransactionController_instances, _TransactionController_incomingTransactionOptions, _TransactionController_pendingTransactionOptions, _TransactionController_multichainTrackingHelper, _TransactionController_createNonceTracker, _TransactionController_createIncomingTransactionHelper, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_removeIncomingTransactionHelperListeners, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_getGasFeeFlows, _TransactionController_updateTransactionInternal;
+var _TransactionController_instances, _TransactionController_incomingTransactionOptions, _TransactionController_pendingTransactionOptions, _TransactionController_multichainTrackingHelper, _TransactionController_createNonceTracker, _TransactionController_createIncomingTransactionHelper, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_removeIncomingTransactionHelperListeners, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_getGasFeeFlows, _TransactionController_updateTransactionInternal, _TransactionController_simulateTransaction;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.HARDFORK = void 0;
 const common_1 = require("@ethereumjs/common");
@@ -54,6 +54,7 @@ const gas_1 = require("./utils/gas");
 const gas_fees_1 = require("./utils/gas-fees");
 const history_1 = require("./utils/history");
 const nonce_1 = require("./utils/nonce");
+const simulation_1 = require("./utils/simulation");
 const swaps_1 = require("./utils/swaps");
 const transaction_type_1 = require("./utils/transaction-type");
 const utils_2 = require("./utils/utils");
@@ -75,7 +76,7 @@ const controllerName = 'TransactionController';
  * Controller responsible for submitting and managing transactions.
  */
 class TransactionController extends base_controller_1.BaseControllerV1 {
-    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions = {}, messenger, onNetworkStateChange, pendingTransactions = {}, provider, securityProviderRequest, getNetworkClientRegistry, isMultichainEnabled = false, hooks, }, config, state) {
+    constructor({ blockTracker, disableHistory, disableSendFlowHistory, disableSwaps, getCurrentAccountEIP1559Compatibility, getCurrentNetworkEIP1559Compatibility, getExternalPendingTransactions, getGasFeeEstimates, getNetworkState, getPermittedAccounts, getSavedGasFees, getSelectedAddress, incomingTransactions = {}, isSimulationEnabled, messenger, onNetworkStateChange, pendingTransactions = {}, provider, securityProviderRequest, getNetworkClientRegistry, isMultichainEnabled = false, hooks, }, config, state) {
         var _a, _b, _c, _d, _e, _f;
         super(config, state);
         _TransactionController_instances.add(this);
@@ -112,6 +113,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
         this.isSendFlowHistoryDisabled = disableSendFlowHistory !== null && disableSendFlowHistory !== void 0 ? disableSendFlowHistory : false;
         this.isHistoryDisabled = disableHistory !== null && disableHistory !== void 0 ? disableHistory : false;
         this.isSwapsDisabled = disableSwaps !== null && disableSwaps !== void 0 ? disableSwaps : false;
+        this.isSimulationEnabled = isSimulationEnabled !== null && isSimulationEnabled !== void 0 ? isSimulationEnabled : (() => true);
         // @ts-expect-error the type in eth-method-registry is inappropriate and should be changed
         this.registry = new eth_method_registry_1.MethodRegistry({ provider });
         this.getSavedGasFees = getSavedGasFees !== null && getSavedGasFees !== void 0 ? getSavedGasFees : ((_chainId) => undefined);
@@ -277,7 +279,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
     addTransaction(txParams, { actionId, deviceConfirmedOn, method, origin, requireApproval, securityAlertResponse, sendFlowHistory, swaps = {}, type, networkClientId, } = {}) {
         return __awaiter(this, void 0, void 0, function* () {
             (0, logger_1.projectLogger)('Adding transaction', txParams);
-            txParams = (0, utils_2.normalizeTxParams)(txParams);
+            txParams = (0, utils_2.normalizeTransactionParams)(txParams);
             if (networkClientId &&
                 !__classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").has(networkClientId)) {
                 throw new Error('The networkClientId for this transaction could not be found');
@@ -313,7 +315,10 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                 type: transactionType,
                 networkClientId,
             };
-            yield this.updateGasProperties(transactionMeta);
+            yield Promise.all([
+                this.updateGasProperties(transactionMeta),
+                __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_simulateTransaction).call(this, transactionMeta),
+            ]);
             // Checks if a transaction already exists with a given actionId
             if (!existingTransactionMeta) {
                 // Set security provider response
@@ -1072,7 +1077,7 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             if (!this.sign) {
                 throw new Error('No sign method defined.');
             }
-            const normalizedTransactionParams = (0, utils_2.normalizeTxParams)(transactionParams);
+            const normalizedTransactionParams = (0, utils_2.normalizeTransactionParams)(transactionParams);
             const type = (0, utils_2.isEIP1559Transaction)(normalizedTransactionParams)
                 ? types_1.TransactionEnvelopeType.feeMarket
                 : types_1.TransactionEnvelopeType.legacy;
@@ -1805,7 +1810,7 @@ _TransactionController_incomingTransactionOptions = new WeakMap(), _TransactionC
     return [new LineaGasFeeFlow_1.LineaGasFeeFlow(), new DefaultGasFeeFlow_1.DefaultGasFeeFlow()];
 }, _TransactionController_updateTransactionInternal = function _TransactionController_updateTransactionInternal(transactionMeta, { note, skipHistory }) {
     const { transactions } = this.state;
-    transactionMeta.txParams = (0, utils_2.normalizeTxParams)(transactionMeta.txParams);
+    transactionMeta.txParams = (0, utils_2.normalizeTransactionParams)(transactionMeta.txParams);
     (0, validation_1.validateTxParams)(transactionMeta.txParams);
     if (skipHistory !== true) {
         (0, history_1.updateTransactionHistory)(transactionMeta, note !== null && note !== void 0 ? note : 'Transaction updated');
@@ -1813,5 +1818,22 @@ _TransactionController_incomingTransactionOptions = new WeakMap(), _TransactionC
     const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
     transactions[index] = transactionMeta;
     this.update({ transactions: this.trimTransactionsForState(transactions) });
+}, _TransactionController_simulateTransaction = function _TransactionController_simulateTransaction(transactionMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        if (!this.isSimulationEnabled()) {
+            (0, logger_1.projectLogger)('Skipping simulation as disabled');
+            return;
+        }
+        const { chainId, txParams } = transactionMeta;
+        const { from, to, value, data } = txParams;
+        transactionMeta.simulationData = yield (0, simulation_1.getSimulationData)({
+            chainId,
+            from: from,
+            to: to,
+            value: value,
+            data: data,
+        });
+        (0, logger_1.projectLogger)('Retrieved simulation data', transactionMeta.simulationData);
+    });
 };
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/constants.d.ts b/dist/constants.d.ts
index 06bf9f0e6dcea286fdee08087534884c7c07ec32..cb0ebaaa8e2b0d08c7d9c132c4e8d3598992e1fa 100644
--- a/dist/constants.d.ts
+++ b/dist/constants.d.ts
@@ -4,7 +4,7 @@ export declare const CHAIN_IDS: {
     readonly BSC: "0x38";
     readonly BSC_TESTNET: "0x61";
     readonly OPTIMISM: "0xa";
-    readonly OPTIMISM_TESTNET: "0x1a4";
+    readonly OPTIMISM_SEPOLIA: "0xaa37dc";
     readonly POLYGON: "0x89";
     readonly POLYGON_TESTNET: "0x13881";
     readonly AVALANCHE: "0xa86a";
@@ -56,7 +56,7 @@ export declare const ETHERSCAN_SUPPORTED_NETWORKS: {
         domain: string;
         subdomain: string;
     };
-    "0x1a4": {
+    "0xaa37dc": {
         domain: string;
         subdomain: string;
     };
@@ -103,6 +103,6 @@ export declare const ETHERSCAN_SUPPORTED_NETWORKS: {
 };
 export declare const GAS_BUFFER_CHAIN_OVERRIDES: {
     "0xa": number;
-    "0x1a4": number;
+    "0xaa37dc": number;
 };
 //# sourceMappingURL=constants.d.ts.map
\ No newline at end of file
diff --git a/dist/constants.js b/dist/constants.js
index 362a0f6fe00fa4c5982542bd21a2cd354cd17c7c..bf10f835916bc003aef38f0648b6a366f2a94bec 100644
--- a/dist/constants.js
+++ b/dist/constants.js
@@ -7,7 +7,7 @@ exports.CHAIN_IDS = {
     BSC: '0x38',
     BSC_TESTNET: '0x61',
     OPTIMISM: '0xa',
-    OPTIMISM_TESTNET: '0x1a4',
+    OPTIMISM_SEPOLIA: '0xaa37dc',
     POLYGON: '0x89',
     POLYGON_TESTNET: '0x13881',
     AVALANCHE: '0xa86a',
@@ -59,9 +59,9 @@ exports.ETHERSCAN_SUPPORTED_NETWORKS = {
         domain: exports.DEFAULT_ETHERSCAN_DOMAIN,
         subdomain: `${exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-optimistic`,
     },
-    [exports.CHAIN_IDS.OPTIMISM_TESTNET]: {
+    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: {
         domain: exports.DEFAULT_ETHERSCAN_DOMAIN,
-        subdomain: `${exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-goerli-optimistic`,
+        subdomain: `${exports.DEFAULT_ETHERSCAN_SUBDOMAIN_PREFIX}-sepolia-optimistic`,
     },
     [exports.CHAIN_IDS.POLYGON]: {
         domain: 'polygonscan.com',
@@ -106,6 +106,6 @@ exports.ETHERSCAN_SUPPORTED_NETWORKS = {
 };
 exports.GAS_BUFFER_CHAIN_OVERRIDES = {
     [exports.CHAIN_IDS.OPTIMISM]: 1,
-    [exports.CHAIN_IDS.OPTIMISM_TESTNET]: 1,
+    [exports.CHAIN_IDS.OPTIMISM_SEPOLIA]: 1,
 };
 //# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index b1319a340c03e201f8f19715d591988b538bc794..f88cd0bbed5464d00acd0d56600ef6be089dd3de 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1,6 +1,6 @@
 export * from './TransactionController';
 export type { EtherscanTransactionMeta } from './utils/etherscan';
-export { isEIP1559Transaction } from './utils/utils';
+export { isEIP1559Transaction, normalizeTransactionParams, } from './utils/utils';
 export * from './types';
 export { determineTransactionType } from './utils/transaction-type';
 export { mergeGasFeeEstimates } from './utils/gas-flow';
diff --git a/dist/index.js b/dist/index.js
index b48c4bbdad703206b9d5ce3df1bc2d7d174cdf6f..4923cf0171172b03b6c9cac7d9de00ce0e0c4b54 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -14,10 +14,11 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.mergeGasFeeEstimates = exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
+exports.mergeGasFeeEstimates = exports.determineTransactionType = exports.normalizeTransactionParams = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils/utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
+Object.defineProperty(exports, "normalizeTransactionParams", { enumerable: true, get: function () { return utils_1.normalizeTransactionParams; } });
 __exportStar(require("./types"), exports);
 var transaction_type_1 = require("./utils/transaction-type");
 Object.defineProperty(exports, "determineTransactionType", { enumerable: true, get: function () { return transaction_type_1.determineTransactionType; } });
diff --git a/dist/types.d.ts b/dist/types.d.ts
index d407bd8553dc95e82025277d39413e2c7f14a203..d0be9f03cb1bd4bfd4de8dfb9cdced305b850f98 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -281,6 +281,10 @@ declare type TransactionMetaBase = {
      * This is purely attached to state logs for troubleshooting and support.
      */
     sendFlowHistory?: SendFlowHistoryEntry[];
+    /**
+     * Simulation data for the transaction used to predict its outcome.
+     */
+    simulationData?: SimulationData;
     /**
      * If the gas estimation fails, an object containing error and block information.
      */
@@ -861,5 +865,40 @@ export declare type GasFeeFlow = {
      */
     getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
 };
+/** Simulation data concerning an update to a native or token balance. */
+export declare type SimulationBalanceChange = {
+    /** The balance before the transaction. */
+    previousBalance: Hex;
+    /** The balance after the transaction. */
+    newBalance: Hex;
+    /** The difference in balance. */
+    difference: Hex;
+    /** Whether the balance is increasing or decreasing. */
+    isDecrease: boolean;
+};
+/** Token standards supported by simulation. */
+export declare enum SimulationTokenStandard {
+    erc20 = "erc20",
+    erc721 = "erc721",
+    erc1155 = "erc1155"
+}
+/** Simulation data concerning an updated token. */
+export declare type SimulationToken = {
+    /** The token's contract address. */
+    address: Hex;
+    /** The standard of the token. */
+    standard: SimulationTokenStandard;
+    /** The ID of the token if supported by the standard. */
+    id?: Hex;
+};
+/** Simulation data concerning a change to the a token balance. */
+export declare type SimulationTokenBalanceChange = SimulationToken & SimulationBalanceChange;
+/** Simulation data for a transaction. */
+export declare type SimulationData = {
+    /** Data concerning a change to the user's native balance. */
+    nativeBalanceChange?: SimulationBalanceChange;
+    /** Data concerning a change to the user's token balances. */
+    tokenBalanceChanges: SimulationTokenBalanceChange[];
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/types.js b/dist/types.js
index 0cb707952150f6db340491b03209c66234ecb8ef..09fd44ed67a140b13829bfd0dac6d4d434071a68 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.GasFeeEstimateLevel = exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.SimulationTokenStandard = exports.GasFeeEstimateLevel = exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
  * in the wallet. Some of these correspond with the state of the transaction on the network, but
@@ -168,4 +168,11 @@ var GasFeeEstimateLevel;
     GasFeeEstimateLevel["medium"] = "medium";
     GasFeeEstimateLevel["high"] = "high";
 })(GasFeeEstimateLevel = exports.GasFeeEstimateLevel || (exports.GasFeeEstimateLevel = {}));
+/** Token standards supported by simulation. */
+var SimulationTokenStandard;
+(function (SimulationTokenStandard) {
+    SimulationTokenStandard["erc20"] = "erc20";
+    SimulationTokenStandard["erc721"] = "erc721";
+    SimulationTokenStandard["erc1155"] = "erc1155";
+})(SimulationTokenStandard = exports.SimulationTokenStandard || (exports.SimulationTokenStandard = {}));
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.d.ts b/dist/utils/simulation-api.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8389fcda31b6a36c7d04047f6ee197b45fde2f77
--- /dev/null
+++ b/dist/utils/simulation-api.d.ts
@@ -0,0 +1,66 @@
+import { type Hex } from '@metamask/utils';
+/** Single transaction to simulate in a simulation API request.  */
+export declare type SimulationRequestTransaction = {
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+/** Request to the simulation API to simulate transactions. */
+export declare type SimulationRequest = {
+    transactions: SimulationRequestTransaction[];
+    overrides?: {
+        [address: Hex]: {
+            stateDiff: {
+                [slot: Hex]: Hex;
+            };
+        };
+    };
+    withCallTrace?: boolean;
+    withLogs?: boolean;
+};
+/** Raw event log emitted by a simulated transaction. */
+export declare type SimulationLog = {
+    address: Hex;
+    data: Hex;
+    topics: Hex[];
+};
+/** Call trace of a single simulated transaction. */
+export declare type SimulationResponseCallTrace = {
+    calls: SimulationResponseCallTrace[];
+    logs: SimulationLog[];
+};
+/** Response from the simulation API. */
+export declare type SimulationResponse = {
+    transactions: {
+        return: Hex;
+        callTrace: SimulationResponseCallTrace;
+        stateDiff: {
+            pre: {
+                [address: Hex]: {
+                    balance?: Hex;
+                    nonce?: Hex;
+                    storage?: {
+                        [slot: Hex]: Hex;
+                    };
+                };
+            };
+            post: {
+                [address: Hex]: {
+                    balance?: Hex;
+                    nonce?: Hex;
+                    storage?: {
+                        [slot: Hex]: Hex;
+                    };
+                };
+            };
+        };
+    }[];
+};
+/**
+ * Simulate transactions using the transaction simulation API.
+ * @param chainId - The chain ID to simulate transactions on.
+ * @param request - The request to simulate transactions.
+ */
+export declare function simulateTransactions(chainId: Hex, request: SimulationRequest): Promise<SimulationResponse>;
+//# sourceMappingURL=simulation-api.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.js b/dist/utils/simulation-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..e6f0c1947c7d92a03db5a7acba89e79b4bf6059b
--- /dev/null
+++ b/dist/utils/simulation-api.js
@@ -0,0 +1,62 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.simulateTransactions = void 0;
+const providers_1 = require("@ethersproject/providers");
+const utils_1 = require("@metamask/utils");
+const constants_1 = require("../constants");
+const logger_1 = require("../logger");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation-api');
+const RPC_METHOD = 'infura_simulateTransactions';
+const BASE_URL = 'https://tx-sentinel-{0}.api.cx.metamask.io/';
+const SUBDOMAIN_BY_CHAIN_ID = {
+    [constants_1.CHAIN_IDS.MAINNET]: 'ethereum-mainnet',
+    [constants_1.CHAIN_IDS.GOERLI]: 'ethereum-goerli',
+    [constants_1.CHAIN_IDS.SEPOLIA]: 'ethereum-sepolia',
+    [constants_1.CHAIN_IDS.LINEA_MAINNET]: 'linea-mainnet',
+    [constants_1.CHAIN_IDS.LINEA_GOERLI]: 'linea-goerli',
+    [constants_1.CHAIN_IDS.ARBITRUM]: 'arbitrum-mainnet',
+    [constants_1.CHAIN_IDS.AVALANCHE]: 'avalanche-mainnet',
+    [constants_1.CHAIN_IDS.OPTIMISM]: 'optimism-mainnet',
+    [constants_1.CHAIN_IDS.POLYGON]: 'polygon-mainnet',
+    [constants_1.CHAIN_IDS.BSC]: 'bsc-mainnet',
+    '0x539': 'local-e2e-mock',
+};
+/**
+ * Simulate transactions using the transaction simulation API.
+ * @param chainId - The chain ID to simulate transactions on.
+ * @param request - The request to simulate transactions.
+ */
+function simulateTransactions(chainId, request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const url = getUrl(chainId);
+        log('Sending request', url, request);
+        const jsonRpc = new providers_1.JsonRpcProvider(url);
+        const response = yield jsonRpc.send(RPC_METHOD, [request]);
+        log('Received response', response);
+        return response;
+    });
+}
+exports.simulateTransactions = simulateTransactions;
+/**
+ * Get the URL for the transaction simulation API.
+ * @param chainId - The chain ID to get the URL for.
+ * @returns The URL for the transaction simulation API.
+ */
+function getUrl(chainId) {
+    const subdomain = SUBDOMAIN_BY_CHAIN_ID[chainId];
+    if (!subdomain) {
+        log('Chain is not supported', chainId);
+        throw new Error(`Chain is not supported: ${chainId}`);
+    }
+    return BASE_URL.replace('{0}', subdomain);
+}
+//# sourceMappingURL=simulation-api.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.d.ts b/dist/utils/simulation.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62f760ef2cfb9d88ced279e82527a04ef1c487ce
--- /dev/null
+++ b/dist/utils/simulation.d.ts
@@ -0,0 +1,21 @@
+import { type Hex } from '@metamask/utils';
+import type { SimulationData } from '../types';
+export declare type GetSimulationDataRequest = {
+    chainId: Hex;
+    from: Hex;
+    to?: Hex;
+    value?: Hex;
+    data?: Hex;
+};
+/**
+ * Generate simulation data for a transaction.
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+export declare function getSimulationData(request: GetSimulationDataRequest): Promise<SimulationData | undefined>;
+//# sourceMappingURL=simulation.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
new file mode 100644
index 0000000000000000000000000000000000000000..6e71e294956033dfc613ac51988be6f8b5b23f26
--- /dev/null
+++ b/dist/utils/simulation.js
@@ -0,0 +1,307 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getSimulationData = void 0;
+const abi_1 = require("@ethersproject/abi");
+const controller_utils_1 = require("@metamask/controller-utils");
+const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const simulation_api_1 = require("./simulation-api");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'simulation');
+/**
+ * Generate simulation data for a transaction.
+ * @param request - The transaction to simulate.
+ * @param request.chainId - The chain ID of the transaction.
+ * @param request.from - The sender of the transaction.
+ * @param request.to - The recipient of the transaction.
+ * @param request.value - The value of the transaction.
+ * @param request.data - The data of the transaction.
+ * @returns The simulation data.
+ */
+function getSimulationData(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, from, to, value, data } = request;
+        log('Getting simulation data', request);
+        try {
+            const response = yield (0, simulation_api_1.simulateTransactions)(chainId, {
+                transactions: [{ from, to, value, data }],
+                withCallTrace: true,
+                withLogs: true,
+            });
+            const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+            const events = getEvents(response);
+            log('Parsed events', events);
+            const tokenBalanceChanges = events.length
+                ? yield getTokenBalanceChanges(request, events)
+                : [];
+            return {
+                nativeBalanceChange,
+                tokenBalanceChanges,
+            };
+        }
+        catch (error) {
+            log('Failed to get simulation data', error, request);
+            return undefined;
+        }
+    });
+}
+exports.getSimulationData = getSimulationData;
+/**
+ * Extract the native balance change from a simulation response.
+ * @param userAddress - The user's account address.
+ * @param response - The simulation response.
+ * @returns The native balance change or undefined if unchanged.
+ */
+function getNativeBalanceChange(userAddress, response) {
+    var _a, _b, _c;
+    /* istanbul ignore next */
+    const { stateDiff } = (_a = response.transactions[0]) !== null && _a !== void 0 ? _a : {
+        stateDiff: { pre: {}, post: {} },
+    };
+    const previousBalance = (_b = stateDiff.pre[userAddress]) === null || _b === void 0 ? void 0 : _b.balance;
+    const newBalance = (_c = stateDiff.post[userAddress]) === null || _c === void 0 ? void 0 : _c.balance;
+    if (!previousBalance || !newBalance) {
+        return undefined;
+    }
+    return getSimulationBalanceChange(previousBalance, newBalance);
+}
+/**
+ * Extract events from a simulation response.
+ * @param response - The simulation response.
+ * @returns The parsed events.
+ */
+function getEvents(response) {
+    var _a, _b;
+    /* istanbul ignore next */
+    const logs = getLogs((_b = (_a = response.transactions[0]) === null || _a === void 0 ? void 0 : _a.callTrace) !== null && _b !== void 0 ? _b : {});
+    log('Extracted logs', logs);
+    const erc20Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC20);
+    const erc721Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC721);
+    const erc1155Interface = new abi_1.Interface(metamask_eth_abis_1.abiERC1155);
+    return logs
+        .map((currentLog) => {
+        var _a;
+        const event = parseLog(currentLog, erc20Interface, erc721Interface, erc1155Interface);
+        if (!event) {
+            log('Failed to parse log', currentLog);
+            return undefined;
+        }
+        /* istanbul ignore next */
+        const inputs = (_a = event.abi.find((e) => e.name === event.name)) === null || _a === void 0 ? void 0 : _a.inputs;
+        /* istanbul ignore if */
+        if (!inputs) {
+            log('Failed to find inputs for event', event);
+            return undefined;
+        }
+        const args = parseEventArgs(event.args, inputs);
+        return {
+            contractAddress: currentLog.address,
+            tokenStandard: event.standard,
+            name: event.name,
+            data: args,
+            abi: event.abi,
+        };
+    })
+        .filter((e) => e !== undefined);
+}
+/**
+ * Parse event arguments using ABI input definitions.
+ * @param args - The raw event arguments.
+ * @param abiInputs - The ABI input definitions.
+ * @returns The parsed event arguments.
+ */
+function parseEventArgs(args, abiInputs) {
+    return args.reduce((result, arg, index) => {
+        const name = abiInputs[index].name.replace('_', '');
+        const value = parseEventArgValue(arg);
+        result[name] = value;
+        return result;
+    }, {});
+}
+/**
+ * Parse an event argument value.
+ * @param value - The event argument value.
+ * @returns The parsed event argument value.
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+function parseEventArgValue(value) {
+    if (Array.isArray(value)) {
+        return value.map(parseEventArgValue);
+    }
+    let parsedValue = value;
+    if (parsedValue.toHexString) {
+        parsedValue = value.toHexString();
+    }
+    return parsedValue.toLowerCase();
+}
+/**
+ * Generate token balance changes from parsed events.
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns An array of token balance changes.
+ */
+function getTokenBalanceChanges(request, events) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const balanceTransactionsByToken = getTokenBalanceTransactions(request, events);
+        const balanceTransactions = [...balanceTransactionsByToken.values()];
+        log('Generated balance transactions', balanceTransactions);
+        if (!balanceTransactions.length) {
+            return [];
+        }
+        const response = yield (0, simulation_api_1.simulateTransactions)(request.chainId, {
+            transactions: [...balanceTransactions, request, ...balanceTransactions],
+        });
+        if (response.transactions.length !== balanceTransactions.length * 2 + 1) {
+            throw new Error('Invalid response from simulation API');
+        }
+        log('Balance simulation response', response);
+        return [...balanceTransactionsByToken.keys()]
+            .map((token, index) => {
+            const previousBalance = response.transactions[index].return;
+            const newBalance = response.transactions[index + balanceTransactions.length + 1].return;
+            const balanceChange = getSimulationBalanceChange(previousBalance, newBalance);
+            if (!balanceChange) {
+                return undefined;
+            }
+            return Object.assign(Object.assign({}, token), balanceChange);
+        })
+            .filter((change) => change !== undefined);
+    });
+}
+/**
+ * Generate transactions to check token balances.
+ * @param request - The transaction that was simulated.
+ * @param events - The parsed events.
+ * @returns A map of token balance transactions keyed by token.
+ */
+function getTokenBalanceTransactions(request, events) {
+    const tokenKeys = new Set();
+    return events.reduce((result, event) => {
+        if (!['Transfer', 'TransferSingle', 'TransferBatch'].includes(event.name) ||
+            ![event.data.from, event.data.to].includes(request.from)) {
+            log('Ignoring event', event);
+            return result;
+        }
+        let tokenIds = [undefined];
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc721) {
+            tokenIds = [event.data.tokenId];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferSingle') {
+            tokenIds = [event.data.id];
+        }
+        if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155 &&
+            event.name === 'TransferBatch') {
+            tokenIds = event.data.ids;
+        }
+        log('Extracted token ids', tokenIds);
+        for (const tokenId of tokenIds) {
+            const simulationToken = {
+                address: event.contractAddress,
+                standard: event.tokenStandard,
+                id: tokenId,
+            };
+            const tokenKey = JSON.stringify(simulationToken);
+            if (tokenKeys.has(tokenKey)) {
+                log('Ignoring additional event with same contract and token ID', simulationToken);
+                continue;
+            }
+            tokenKeys.add(tokenKey);
+            const parameters = [request.from];
+            if (event.tokenStandard === types_1.SimulationTokenStandard.erc1155) {
+                parameters.push(tokenId);
+            }
+            result.set(simulationToken, {
+                from: request.from,
+                to: event.contractAddress,
+                data: new abi_1.Interface(event.abi).encodeFunctionData('balanceOf', parameters),
+            });
+        }
+        return result;
+    }, new Map());
+}
+/**
+ * Parse a raw event log using known ABIs.
+ * @param eventLog - The raw event log.
+ * @param erc20 - The ERC-20 ABI interface.
+ * @param erc721 - The ERC-721 ABI interface.
+ * @param erc1155 - The ERC-1155 ABI interface.
+ * @returns The parsed event log or undefined if it could not be parsed.
+ */
+function parseLog(eventLog, erc20, erc721, erc1155) {
+    const abisByStandard = [
+        {
+            abi: metamask_eth_abis_1.abiERC20,
+            contractInterface: erc20,
+            standard: types_1.SimulationTokenStandard.erc20,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC721,
+            contractInterface: erc721,
+            standard: types_1.SimulationTokenStandard.erc721,
+        },
+        {
+            abi: metamask_eth_abis_1.abiERC1155,
+            contractInterface: erc1155,
+            standard: types_1.SimulationTokenStandard.erc1155,
+        },
+    ];
+    for (const { abi, contractInterface, standard } of abisByStandard) {
+        try {
+            return Object.assign(Object.assign({}, contractInterface.parseLog(eventLog)), { abi,
+                standard });
+        }
+        catch (e) {
+            // Intentionally empty
+        }
+    }
+    return undefined;
+}
+/**
+ * Extract all logs from a call trace tree.
+ * @param call - The root call trace.
+ * @returns An array of logs.
+ */
+function getLogs(call) {
+    var _a, _b;
+    /* istanbul ignore next */
+    const logs = (_a = call.logs) !== null && _a !== void 0 ? _a : [];
+    /* istanbul ignore next */
+    const nestedCalls = (_b = call.calls) !== null && _b !== void 0 ? _b : [];
+    return [
+        ...logs,
+        ...nestedCalls.map((nestedCall) => getLogs(nestedCall)).flat(),
+    ];
+}
+/**
+ * Generate balance change data from previous and new balances.
+ * @param previousBalance - The previous balance.
+ * @param newBalance - The new balance.
+ * @returns The balance change data or undefined if unchanged.
+ */
+function getSimulationBalanceChange(previousBalance, newBalance) {
+    const differenceBN = (0, controller_utils_1.hexToBN)(newBalance).sub((0, controller_utils_1.hexToBN)(previousBalance));
+    const isDecrease = differenceBN.isNeg();
+    const difference = (0, controller_utils_1.toHex)(differenceBN.abs());
+    if (differenceBN.isZero()) {
+        log('Balance change is zero');
+        return undefined;
+    }
+    return {
+        previousBalance,
+        newBalance,
+        difference,
+        isDecrease,
+    };
+}
+//# sourceMappingURL=simulation.js.map
\ No newline at end of file
diff --git a/dist/utils/utils.d.ts b/dist/utils/utils.d.ts
index b2ab10434f29503a544d784b75b0809c80efa4f9..38f2f6d17f8c00858a69dedd952ee4a9a3cbec53 100644
--- a/dist/utils/utils.d.ts
+++ b/dist/utils/utils.d.ts
@@ -7,7 +7,7 @@ export declare const ESTIMATE_GAS_ERROR = "eth_estimateGas rpc method error";
  * @param txParams - The transaction params to normalize.
  * @returns Normalized transaction params.
  */
-export declare function normalizeTxParams(txParams: TransactionParams): TransactionParams;
+export declare function normalizeTransactionParams(txParams: TransactionParams): TransactionParams;
 /**
  * Checks if a transaction is EIP-1559 by checking for the existence of
  * maxFeePerGas and maxPriorityFeePerGas within its parameters.
@@ -55,4 +55,12 @@ export declare function normalizeTxError(error: Error & {
  * @returns An object containing normalized gas fee values.
  */
 export declare function normalizeGasFeeValues(gasFeeValues: GasPriceValue | FeeMarketEIP1559Values): GasPriceValue | FeeMarketEIP1559Values;
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+export declare function padHexToEvenLength(hex: string): string;
 //# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/utils.js b/dist/utils/utils.js
index 0d0cb63a30f1ec07f926adebecee8d7c1639ff03..00e717c5aadca944fa3ace1c795bfef720c05de2 100644
--- a/dist/utils/utils.js
+++ b/dist/utils/utils.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.normalizeGasFeeValues = exports.normalizeTxError = exports.validateIfTransactionUnapproved = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.normalizeTxParams = exports.ESTIMATE_GAS_ERROR = void 0;
+exports.padHexToEvenLength = exports.normalizeGasFeeValues = exports.normalizeTxError = exports.validateIfTransactionUnapproved = exports.validateMinimumIncrease = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.isEIP1559Transaction = exports.normalizeTransactionParams = exports.ESTIMATE_GAS_ERROR = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
 const utils_1 = require("@metamask/utils");
 const types_1 = require("../types");
@@ -8,7 +8,7 @@ exports.ESTIMATE_GAS_ERROR = 'eth_estimateGas rpc method error';
 // TODO: Replace `any` with type
 // eslint-disable-next-line @typescript-eslint/no-explicit-any
 const NORMALIZERS = {
-    data: (data) => (0, utils_1.add0x)(data),
+    data: (data) => (0, utils_1.add0x)(padHexToEvenLength(data)),
     from: (from) => (0, utils_1.add0x)(from).toLowerCase(),
     gas: (gas) => (0, utils_1.add0x)(gas),
     gasLimit: (gas) => (0, utils_1.add0x)(gas),
@@ -27,7 +27,7 @@ const NORMALIZERS = {
  * @param txParams - The transaction params to normalize.
  * @returns Normalized transaction params.
  */
-function normalizeTxParams(txParams) {
+function normalizeTransactionParams(txParams) {
     const normalizedTxParams = { from: '' };
     for (const key of (0, utils_1.getKnownPropertyNames)(NORMALIZERS)) {
         if (txParams[key]) {
@@ -39,7 +39,7 @@ function normalizeTxParams(txParams) {
     }
     return normalizedTxParams;
 }
-exports.normalizeTxParams = normalizeTxParams;
+exports.normalizeTransactionParams = normalizeTransactionParams;
 /**
  * Checks if a transaction is EIP-1559 by checking for the existence of
  * maxFeePerGas and maxPriorityFeePerGas within its parameters.
@@ -144,4 +144,18 @@ function normalizeGasFeeValues(gasFeeValues) {
     };
 }
 exports.normalizeGasFeeValues = normalizeGasFeeValues;
+/**
+ * Ensure a hex string is of even length by adding a leading 0 if necessary.
+ * Any existing `0x` prefix is preserved but is not added if missing.
+ *
+ * @param hex - The hex string to ensure is even.
+ * @returns The hex string with an even length.
+ */
+function padHexToEvenLength(hex) {
+    const prefix = hex.toLowerCase().startsWith('0x') ? hex.slice(0, 2) : '';
+    const data = prefix ? hex.slice(2) : hex;
+    const evenData = data.length % 2 === 0 ? data : `0${data}`;
+    return prefix + evenData;
+}
+exports.padHexToEvenLength = padHexToEvenLength;
 //# sourceMappingURL=utils.js.map
\ No newline at end of file
