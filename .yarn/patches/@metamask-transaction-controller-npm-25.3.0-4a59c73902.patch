diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index cd6ce657492a2775e9bd186d7cacc158acfb2540..160681f9774145c4167950dcb4c6bfa8a3e5e6e8 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -4,31 +4,32 @@
 
 
 
-var _chunk7QOACSQUjs = require('./chunk-7QOACSQU.js');
-require('./chunk-VH47Q6TS.js');
-require('./chunk-RQKICZYP.js');
-require('./chunk-QP75SWIQ.js');
-require('./chunk-ZNZEJDOE.js');
-require('./chunk-GC77BSQZ.js');
-require('./chunk-GE57YNGX.js');
-require('./chunk-SD6CWFDF.js');
-require('./chunk-7YLATOE4.js');
-require('./chunk-R7NJVDWN.js');
+var _chunkIXIBW7YOjs = require('./chunk-IXIBW7YO.js');
 require('./chunk-DTDTOMTB.js');
 require('./chunk-NRWEI43Q.js');
 require('./chunk-5XBULBP2.js');
-require('./chunk-7LXE4KHV.js');
-require('./chunk-CWJBSWH3.js');
-require('./chunk-US7NQPYE.js');
-require('./chunk-SSYRMQ63.js');
+require('./chunk-SD6CWFDF.js');
+require('./chunk-VH47Q6TS.js');
+require('./chunk-UCY5PFZI.js');
+require('./chunk-2AYEGKAN.js');
+require('./chunk-F3CMU2DM.js');
+require('./chunk-5ZAGN3YF.js');
+require('./chunk-2JERLB6M.js');
 require('./chunk-5OQ373JS.js');
 require('./chunk-UGFBA4GV.js');
-require('./chunk-GQYELPS3.js');
-require('./chunk-F3CMU2DM.js');
+require('./chunk-L4S5SEV3.js');
+require('./chunk-RQKICZYP.js');
+require('./chunk-QP75SWIQ.js');
+require('./chunk-R7NJVDWN.js');
+require('./chunk-ZNZEJDOE.js');
+require('./chunk-V5X6MZHN.js');
+require('./chunk-KT6UAKBB.js');
+require('./chunk-HMOSP33F.js');
 require('./chunk-CXXGL43K.js');
 require('./chunk-ITDY6AIZ.js');
 require('./chunk-S6VGOPUY.js');
-require('./chunk-MXQLW52B.js');
+require('./chunk-7LXE4KHV.js');
+require('./chunk-HBNQEJEM.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -36,5 +37,5 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.ApprovalState = _chunk7QOACSQUjs.ApprovalState; exports.CANCEL_RATE = _chunk7QOACSQUjs.CANCEL_RATE; exports.HARDFORK = _chunk7QOACSQUjs.HARDFORK; exports.SPEED_UP_RATE = _chunk7QOACSQUjs.SPEED_UP_RATE; exports.TransactionController = _chunk7QOACSQUjs.TransactionController;
+exports.ApprovalState = _chunkIXIBW7YOjs.ApprovalState; exports.CANCEL_RATE = _chunkIXIBW7YOjs.CANCEL_RATE; exports.HARDFORK = _chunkIXIBW7YOjs.HARDFORK; exports.SPEED_UP_RATE = _chunkIXIBW7YOjs.SPEED_UP_RATE; exports.TransactionController = _chunkIXIBW7YOjs.TransactionController;
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/chunk-2AYEGKAN.js b/dist/chunk-2AYEGKAN.js
new file mode 100644
index 0000000000000000000000000000000000000000..a42a1de317ae0e95995e0333b49f7de746feb04b
--- /dev/null
+++ b/dist/chunk-2AYEGKAN.js
@@ -0,0 +1,90 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunk2JERLB6Mjs = require('./chunk-2JERLB6M.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunkHBNQEJEMjs = require('./chunk-HBNQEJEM.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/DefaultGasFeeFlow.ts
+var _gasfeecontroller = require('@metamask/gas-fee-controller');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "default-gas-fee-flow");
+var _getEstimateLevel, getEstimateLevel_fn, _getFeeMarketLevel, getFeeMarketLevel_fn, _getLegacyLevel, getLegacyLevel_fn;
+var DefaultGasFeeFlow = class {
+  constructor() {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getEstimateLevel);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getFeeMarketLevel);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLegacyLevel);
+  }
+  matchesTransaction(_transactionMeta) {
+    return true;
+  }
+  async getGasFees(request) {
+    const { getGasFeeControllerEstimates, transactionMeta } = request;
+    const { networkClientId } = transactionMeta;
+    const { gasEstimateType, gasFeeEstimates } = await getGasFeeControllerEstimates({ networkClientId });
+    if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+      log("Using fee market estimates", gasFeeEstimates);
+    } else if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.LEGACY) {
+      log("Using legacy estimates", gasFeeEstimates);
+    } else {
+      throw new Error(`'No gas fee estimates available`);
+    }
+    const estimates = Object.values(_chunkHBNQEJEMjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getEstimateLevel, getEstimateLevel_fn).call(this, {
+          gasEstimateType,
+          gasFeeEstimates,
+          level
+        })
+      }),
+      {}
+    );
+    return { estimates };
+  }
+};
+_getEstimateLevel = new WeakSet();
+getEstimateLevel_fn = function({
+  gasEstimateType,
+  gasFeeEstimates,
+  level
+}) {
+  if (gasEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+    return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getFeeMarketLevel, getFeeMarketLevel_fn).call(this, gasFeeEstimates, level);
+  }
+  return _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLegacyLevel, getLegacyLevel_fn).call(this, gasFeeEstimates, level);
+};
+_getFeeMarketLevel = new WeakSet();
+getFeeMarketLevel_fn = function(gasFeeEstimates, level) {
+  const maxFeePerGas = _chunk2JERLB6Mjs.gweiDecimalToWeiHex.call(void 0, 
+    gasFeeEstimates[level].suggestedMaxFeePerGas
+  );
+  const maxPriorityFeePerGas = _chunk2JERLB6Mjs.gweiDecimalToWeiHex.call(void 0, 
+    gasFeeEstimates[level].suggestedMaxPriorityFeePerGas
+  );
+  return {
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  };
+};
+_getLegacyLevel = new WeakSet();
+getLegacyLevel_fn = function(gasFeeEstimates, level) {
+  const gasPrice = _chunk2JERLB6Mjs.gweiDecimalToWeiHex.call(void 0, gasFeeEstimates[level]);
+  return {
+    maxFeePerGas: gasPrice,
+    maxPriorityFeePerGas: gasPrice
+  };
+};
+
+
+
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+//# sourceMappingURL=chunk-2AYEGKAN.js.map
\ No newline at end of file
diff --git a/dist/chunk-2JERLB6M.js b/dist/chunk-2JERLB6M.js
new file mode 100644
index 0000000000000000000000000000000000000000..ca1692a385cff9919cb43863071733dc2d83bafa
--- /dev/null
+++ b/dist/chunk-2JERLB6M.js
@@ -0,0 +1,208 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunk5OQ373JSjs = require('./chunk-5OQ373JS.js');
+
+
+var _chunkL4S5SEV3js = require('./chunk-L4S5SEV3.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/gas-fees.ts
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "gas-fees");
+async function updateGasFees(request) {
+  const { txMeta } = request;
+  const initialParams = { ...txMeta.txParams };
+  const isSwap = _chunk5OQ373JSjs.SWAP_TRANSACTION_TYPES.includes(
+    txMeta.type
+  );
+  const savedGasFees = isSwap ? void 0 : request.getSavedGasFees(txMeta.chainId);
+  const suggestedGasFees = await getSuggestedGasFees(request);
+  log("Suggested gas fees", suggestedGasFees);
+  const getGasFeeRequest = {
+    ...request,
+    initialParams,
+    savedGasFees,
+    suggestedGasFees
+  };
+  txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
+  txMeta.txParams.maxPriorityFeePerGas = getMaxPriorityFeePerGas(getGasFeeRequest);
+  txMeta.txParams.gasPrice = getGasPrice(getGasFeeRequest);
+  txMeta.userFeeLevel = getUserFeeLevel(getGasFeeRequest);
+  log("Updated gas fee properties", {
+    maxFeePerGas: txMeta.txParams.maxFeePerGas,
+    maxPriorityFeePerGas: txMeta.txParams.maxPriorityFeePerGas,
+    gasPrice: txMeta.txParams.gasPrice
+  });
+  if (txMeta.txParams.maxFeePerGas || txMeta.txParams.maxPriorityFeePerGas) {
+    delete txMeta.txParams.gasPrice;
+  }
+  if (txMeta.txParams.gasPrice) {
+    delete txMeta.txParams.maxFeePerGas;
+    delete txMeta.txParams.maxPriorityFeePerGas;
+  }
+  updateDefaultGasEstimates(txMeta);
+}
+function gweiDecimalToWeiHex(value) {
+  return _controllerutils.toHex.call(void 0, _controllerutils.gweiDecToWEIBN.call(void 0, value));
+}
+function getMaxFeePerGas(request) {
+  const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    const maxFeePerGas = gweiDecimalToWeiHex(savedGasFees.maxBaseFee);
+    log("Using maxFeePerGas from savedGasFees", maxFeePerGas);
+    return maxFeePerGas;
+  }
+  if (initialParams.maxFeePerGas) {
+    log("Using maxFeePerGas from request", initialParams.maxFeePerGas);
+    return initialParams.maxFeePerGas;
+  }
+  if (initialParams.gasPrice && !initialParams.maxPriorityFeePerGas) {
+    log(
+      "Setting maxFeePerGas to gasPrice from request",
+      initialParams.gasPrice
+    );
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxFeePerGas) {
+    log("Using suggested maxFeePerGas", suggestedGasFees.maxFeePerGas);
+    return suggestedGasFees.maxFeePerGas;
+  }
+  if (suggestedGasFees.gasPrice) {
+    log(
+      "Setting maxFeePerGas to suggested gasPrice",
+      suggestedGasFees.gasPrice
+    );
+    return suggestedGasFees.gasPrice;
+  }
+  log("maxFeePerGas not set");
+  return void 0;
+}
+function getMaxPriorityFeePerGas(request) {
+  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    const maxPriorityFeePerGas = gweiDecimalToWeiHex(savedGasFees.priorityFee);
+    log(
+      "Using maxPriorityFeePerGas from savedGasFees.priorityFee",
+      maxPriorityFeePerGas
+    );
+    return maxPriorityFeePerGas;
+  }
+  if (initialParams.maxPriorityFeePerGas) {
+    log(
+      "Using maxPriorityFeePerGas from request",
+      initialParams.maxPriorityFeePerGas
+    );
+    return initialParams.maxPriorityFeePerGas;
+  }
+  if (initialParams.gasPrice && !initialParams.maxFeePerGas) {
+    log(
+      "Setting maxPriorityFeePerGas to gasPrice from request",
+      initialParams.gasPrice
+    );
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxPriorityFeePerGas) {
+    log(
+      "Using suggested maxPriorityFeePerGas",
+      suggestedGasFees.maxPriorityFeePerGas
+    );
+    return suggestedGasFees.maxPriorityFeePerGas;
+  }
+  if (txMeta.txParams.maxFeePerGas) {
+    log(
+      "Setting maxPriorityFeePerGas to maxFeePerGas",
+      txMeta.txParams.maxFeePerGas
+    );
+    return txMeta.txParams.maxFeePerGas;
+  }
+  log("maxPriorityFeePerGas not set");
+  return void 0;
+}
+function getGasPrice(request) {
+  const { eip1559, initialParams, suggestedGasFees } = request;
+  if (eip1559) {
+    return void 0;
+  }
+  if (initialParams.gasPrice) {
+    log("Using gasPrice from request", initialParams.gasPrice);
+    return initialParams.gasPrice;
+  }
+  if (suggestedGasFees.maxFeePerGas) {
+    log("Using suggested maxFeePerGas", suggestedGasFees.maxFeePerGas);
+    return suggestedGasFees.maxFeePerGas;
+  }
+  if (suggestedGasFees.gasPrice) {
+    log("Using suggested gasPrice", suggestedGasFees.gasPrice);
+    return suggestedGasFees.gasPrice;
+  }
+  log("gasPrice not set");
+  return void 0;
+}
+function getUserFeeLevel(request) {
+  const { eip1559, initialParams, savedGasFees, suggestedGasFees, txMeta } = request;
+  if (!eip1559) {
+    return void 0;
+  }
+  if (savedGasFees) {
+    return "custom" /* CUSTOM */;
+  }
+  if (!initialParams.maxFeePerGas && !initialParams.maxPriorityFeePerGas && initialParams.gasPrice) {
+    return txMeta.origin === _controllerutils.ORIGIN_METAMASK ? "custom" /* CUSTOM */ : "dappSuggested" /* DAPP_SUGGESTED */;
+  }
+  if (!initialParams.maxFeePerGas && !initialParams.maxPriorityFeePerGas && suggestedGasFees.maxFeePerGas && suggestedGasFees.maxPriorityFeePerGas) {
+    return "medium" /* MEDIUM */;
+  }
+  if (txMeta.origin === _controllerutils.ORIGIN_METAMASK) {
+    return "medium" /* MEDIUM */;
+  }
+  return "dappSuggested" /* DAPP_SUGGESTED */;
+}
+function updateDefaultGasEstimates(txMeta) {
+  if (!txMeta.defaultGasEstimates) {
+    txMeta.defaultGasEstimates = {};
+  }
+  txMeta.defaultGasEstimates.maxFeePerGas = txMeta.txParams.maxFeePerGas;
+  txMeta.defaultGasEstimates.maxPriorityFeePerGas = txMeta.txParams.maxPriorityFeePerGas;
+  txMeta.defaultGasEstimates.gasPrice = txMeta.txParams.gasPrice;
+  txMeta.defaultGasEstimates.estimateType = txMeta.userFeeLevel;
+}
+async function getSuggestedGasFees(request) {
+  const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
+  if (!eip1559 && txMeta.txParams.gasPrice || eip1559 && txMeta.txParams.maxFeePerGas && txMeta.txParams.maxPriorityFeePerGas) {
+    return {};
+  }
+  const gasFeeFlow = _chunkL4S5SEV3js.getGasFeeFlow.call(void 0, txMeta, gasFeeFlows);
+  try {
+    const response = await gasFeeFlow.getGasFees({
+      ethQuery,
+      getGasFeeControllerEstimates: getGasFeeEstimates,
+      transactionMeta: txMeta
+    });
+    return response.estimates.medium;
+  } catch (error) {
+    log("Failed to get suggested gas fees", error);
+  }
+  const gasPriceDecimal = await _controllerutils.query.call(void 0, ethQuery, "gasPrice");
+  const gasPrice = gasPriceDecimal ? _utils.add0x.call(void 0, gasPriceDecimal.toString(16)) : void 0;
+  return { gasPrice };
+}
+
+
+
+
+exports.updateGasFees = updateGasFees; exports.gweiDecimalToWeiHex = gweiDecimalToWeiHex;
+//# sourceMappingURL=chunk-2JERLB6M.js.map
\ No newline at end of file
diff --git a/dist/chunk-5ZAGN3YF.js b/dist/chunk-5ZAGN3YF.js
new file mode 100644
index 0000000000000000000000000000000000000000..8fa75bc499ceb820707bbeeb8bf72fa1f342725d
--- /dev/null
+++ b/dist/chunk-5ZAGN3YF.js
@@ -0,0 +1,182 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkL4S5SEV3js = require('./chunk-L4S5SEV3.js');
+
+
+var _chunkR7NJVDWNjs = require('./chunk-R7NJVDWN.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/helpers/GasFeePoller.ts
+var _utils = require('@metamask/utils');
+var _events = require('events'); var _events2 = _interopRequireDefault(_events);
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "gas-fee-poller");
+var INTERVAL_MILLISECONDS = 1e4;
+var _gasFeeFlows, _getEthQuery, _getGasFeeControllerEstimates, _getTransactions, _layer1GasFeeFlows, _timeout, _running, _start, start_fn, _stop, stop_fn, _onTimeout, onTimeout_fn, _updateTransactionGasFeeEstimates, updateTransactionGasFeeEstimates_fn, _updateTransactionSuggestedFees, updateTransactionSuggestedFees_fn, _updateTransactionLayer1GasFee, updateTransactionLayer1GasFee_fn, _getUnapprovedTransactions, getUnapprovedTransactions_fn;
+var GasFeePoller = class {
+  /**
+   * Constructs a new instance of the GasFeePoller.
+   * @param options - The options for this instance.
+   * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+   * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+   * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+   * @param options.getTransactions - Callback to obtain the transaction data.
+   * @param options.layer1GasFeeFlows - The layer 1 gas fee flows to use to obtain suitable layer 1 gas fees.
+   * @param options.onStateChange - Callback to register a listener for controller state changes.
+   */
+  constructor({
+    gasFeeFlows,
+    getEthQuery,
+    getGasFeeControllerEstimates,
+    getTransactions,
+    layer1GasFeeFlows,
+    onStateChange
+  }) {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _start);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stop);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onTimeout);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionGasFeeEstimates);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionSuggestedFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionLayer1GasFee);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getUnapprovedTransactions);
+    this.hub = new (0, _events2.default)();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _gasFeeFlows, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getEthQuery, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getGasFeeControllerEstimates, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getTransactions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _layer1GasFeeFlows, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _timeout, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _running, false);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _gasFeeFlows, gasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _layer1GasFeeFlows, layer1GasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getEthQuery, getEthQuery);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getGasFeeControllerEstimates, getGasFeeControllerEstimates);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _getTransactions, getTransactions);
+    onStateChange(() => {
+      const unapprovedTransactions = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getUnapprovedTransactions, getUnapprovedTransactions_fn).call(this);
+      if (unapprovedTransactions.length) {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _start, start_fn).call(this);
+      } else {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stop, stop_fn).call(this);
+      }
+    });
+  }
+};
+_gasFeeFlows = new WeakMap();
+_getEthQuery = new WeakMap();
+_getGasFeeControllerEstimates = new WeakMap();
+_getTransactions = new WeakMap();
+_layer1GasFeeFlows = new WeakMap();
+_timeout = new WeakMap();
+_running = new WeakMap();
+_start = new WeakSet();
+start_fn = function() {
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _running)) {
+    return;
+  }
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTimeout, onTimeout_fn).call(this);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _running, true);
+  log("Started polling");
+};
+_stop = new WeakSet();
+stop_fn = function() {
+  if (!_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _running)) {
+    return;
+  }
+  clearTimeout(_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _timeout));
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _timeout, void 0);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _running, false);
+  log("Stopped polling");
+};
+_onTimeout = new WeakSet();
+onTimeout_fn = async function() {
+  await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionGasFeeEstimates, updateTransactionGasFeeEstimates_fn).call(this);
+  _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _timeout, setTimeout(() => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTimeout, onTimeout_fn).call(this), INTERVAL_MILLISECONDS));
+};
+_updateTransactionGasFeeEstimates = new WeakSet();
+updateTransactionGasFeeEstimates_fn = async function() {
+  const unapprovedTransactions = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getUnapprovedTransactions, getUnapprovedTransactions_fn).call(this);
+  log("Found unapproved transactions", {
+    count: unapprovedTransactions.length
+  });
+  await Promise.all(
+    unapprovedTransactions.flatMap((tx) => [
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionSuggestedFees, updateTransactionSuggestedFees_fn).call(this, tx),
+      _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionLayer1GasFee, updateTransactionLayer1GasFee_fn).call(this, tx)
+    ])
+  );
+};
+_updateTransactionSuggestedFees = new WeakSet();
+updateTransactionSuggestedFees_fn = async function(transactionMeta) {
+  const { chainId, networkClientId } = transactionMeta;
+  const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getEthQuery).call(this, chainId, networkClientId);
+  const gasFeeFlow = _chunkL4S5SEV3js.getGasFeeFlow.call(void 0, transactionMeta, _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _gasFeeFlows));
+  if (!gasFeeFlow) {
+    log("No gas fee flow found", transactionMeta.id);
+  } else {
+    log(
+      "Found gas fee flow",
+      gasFeeFlow.constructor.name,
+      transactionMeta.id
+    );
+  }
+  const request = {
+    ethQuery,
+    getGasFeeControllerEstimates: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getGasFeeControllerEstimates),
+    transactionMeta
+  };
+  let gasFeeEstimates;
+  if (gasFeeFlow) {
+    try {
+      const response = await gasFeeFlow.getGasFees(request);
+      gasFeeEstimates = response.estimates;
+    } catch (error) {
+      log("Failed to get suggested gas fees", transactionMeta.id, error);
+    }
+  }
+  if (!gasFeeEstimates && transactionMeta.gasFeeEstimatesLoaded) {
+    return;
+  }
+  const updatedTransactionMeta = {
+    ...transactionMeta,
+    gasFeeEstimates,
+    gasFeeEstimatesLoaded: true
+  };
+  this.hub.emit("transaction-updated", updatedTransactionMeta);
+  log("Updated suggested gas fees", {
+    gasFeeEstimates: updatedTransactionMeta.gasFeeEstimates,
+    transaction: updatedTransactionMeta.id
+  });
+};
+_updateTransactionLayer1GasFee = new WeakSet();
+updateTransactionLayer1GasFee_fn = async function(transactionMeta) {
+  const { chainId, networkClientId } = transactionMeta;
+  const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getEthQuery).call(this, chainId, networkClientId);
+  await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+    ethQuery,
+    layer1GasFeeFlows: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _layer1GasFeeFlows),
+    transactionMeta
+  });
+  if (transactionMeta.layer1GasFee === void 0) {
+    return;
+  }
+  this.hub.emit("transaction-updated", transactionMeta);
+};
+_getUnapprovedTransactions = new WeakSet();
+getUnapprovedTransactions_fn = function() {
+  return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _getTransactions).call(this).filter(
+    (tx) => tx.status === "unapproved" /* unapproved */
+  );
+};
+
+
+
+exports.GasFeePoller = GasFeePoller;
+//# sourceMappingURL=chunk-5ZAGN3YF.js.map
\ No newline at end of file
diff --git a/dist/chunk-HBNQEJEM.js b/dist/chunk-HBNQEJEM.js
new file mode 100644
index 0000000000000000000000000000000000000000..37d6b99fd5649f6578946d6800fd53099ea12bce
--- /dev/null
+++ b/dist/chunk-HBNQEJEM.js
@@ -0,0 +1,85 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/types.ts
+var TransactionStatus = /* @__PURE__ */ ((TransactionStatus2) => {
+  TransactionStatus2["approved"] = "approved";
+  TransactionStatus2["cancelled"] = "cancelled";
+  TransactionStatus2["confirmed"] = "confirmed";
+  TransactionStatus2["dropped"] = "dropped";
+  TransactionStatus2["failed"] = "failed";
+  TransactionStatus2["rejected"] = "rejected";
+  TransactionStatus2["signed"] = "signed";
+  TransactionStatus2["submitted"] = "submitted";
+  TransactionStatus2["unapproved"] = "unapproved";
+  return TransactionStatus2;
+})(TransactionStatus || {});
+var WalletDevice = /* @__PURE__ */ ((WalletDevice2) => {
+  WalletDevice2["MM_MOBILE"] = "metamask_mobile";
+  WalletDevice2["MM_EXTENSION"] = "metamask_extension";
+  WalletDevice2["OTHER"] = "other_device";
+  return WalletDevice2;
+})(WalletDevice || {});
+var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
+  TransactionType2["cancel"] = "cancel";
+  TransactionType2["contractInteraction"] = "contractInteraction";
+  TransactionType2["deployContract"] = "contractDeployment";
+  TransactionType2["ethDecrypt"] = "eth_decrypt";
+  TransactionType2["ethGetEncryptionPublicKey"] = "eth_getEncryptionPublicKey";
+  TransactionType2["incoming"] = "incoming";
+  TransactionType2["personalSign"] = "personal_sign";
+  TransactionType2["retry"] = "retry";
+  TransactionType2["simpleSend"] = "simpleSend";
+  TransactionType2["sign"] = "eth_sign";
+  TransactionType2["signTypedData"] = "eth_signTypedData";
+  TransactionType2["smart"] = "smart";
+  TransactionType2["swap"] = "swap";
+  TransactionType2["swapApproval"] = "swapApproval";
+  TransactionType2["tokenMethodApprove"] = "approve";
+  TransactionType2["tokenMethodSafeTransferFrom"] = "safetransferfrom";
+  TransactionType2["tokenMethodTransfer"] = "transfer";
+  TransactionType2["tokenMethodTransferFrom"] = "transferfrom";
+  TransactionType2["tokenMethodSetApprovalForAll"] = "setapprovalforall";
+  TransactionType2["tokenMethodIncreaseAllowance"] = "increaseAllowance";
+  return TransactionType2;
+})(TransactionType || {});
+var TransactionEnvelopeType = /* @__PURE__ */ ((TransactionEnvelopeType2) => {
+  TransactionEnvelopeType2["legacy"] = "0x0";
+  TransactionEnvelopeType2["accessList"] = "0x1";
+  TransactionEnvelopeType2["feeMarket"] = "0x2";
+  return TransactionEnvelopeType2;
+})(TransactionEnvelopeType || {});
+var UserFeeLevel = /* @__PURE__ */ ((UserFeeLevel2) => {
+  UserFeeLevel2["CUSTOM"] = "custom";
+  UserFeeLevel2["DAPP_SUGGESTED"] = "dappSuggested";
+  UserFeeLevel2["MEDIUM"] = "medium";
+  return UserFeeLevel2;
+})(UserFeeLevel || {});
+var GasFeeEstimateLevel = /* @__PURE__ */ ((GasFeeEstimateLevel2) => {
+  GasFeeEstimateLevel2["low"] = "low";
+  GasFeeEstimateLevel2["medium"] = "medium";
+  GasFeeEstimateLevel2["high"] = "high";
+  return GasFeeEstimateLevel2;
+})(GasFeeEstimateLevel || {});
+var SimulationTokenStandard = /* @__PURE__ */ ((SimulationTokenStandard2) => {
+  SimulationTokenStandard2["erc20"] = "erc20";
+  SimulationTokenStandard2["erc721"] = "erc721";
+  SimulationTokenStandard2["erc1155"] = "erc1155";
+  return SimulationTokenStandard2;
+})(SimulationTokenStandard || {});
+var SimulationErrorCode = /* @__PURE__ */ ((SimulationErrorCode2) => {
+  SimulationErrorCode2["ChainNotSupported"] = "chain-not-supported";
+  SimulationErrorCode2["Disabled"] = "disabled";
+  SimulationErrorCode2["InvalidResponse"] = "invalid-response";
+  SimulationErrorCode2["Reverted"] = "reverted";
+  return SimulationErrorCode2;
+})(SimulationErrorCode || {});
+
+
+
+
+
+
+
+
+
+
+exports.TransactionStatus = TransactionStatus; exports.WalletDevice = WalletDevice; exports.TransactionType = TransactionType; exports.TransactionEnvelopeType = TransactionEnvelopeType; exports.UserFeeLevel = UserFeeLevel; exports.GasFeeEstimateLevel = GasFeeEstimateLevel; exports.SimulationTokenStandard = SimulationTokenStandard; exports.SimulationErrorCode = SimulationErrorCode;
+//# sourceMappingURL=chunk-HBNQEJEM.js.map
\ No newline at end of file
diff --git a/dist/chunk-HMOSP33F.js b/dist/chunk-HMOSP33F.js
new file mode 100644
index 0000000000000000000000000000000000000000..a6bca3e5a249954cc2136ef444e2d61d470dc7ae
--- /dev/null
+++ b/dist/chunk-HMOSP33F.js
@@ -0,0 +1,36 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/errors.ts
+var SimulationError = class extends Error {
+  constructor(message, code) {
+    super(message ?? "Simulation failed");
+    this.code = code;
+  }
+};
+var SimulationChainNotSupportedError = class extends SimulationError {
+  constructor(chainId) {
+    super(
+      `Chain is not supported: ${chainId}`,
+      "chain-not-supported" /* ChainNotSupported */
+    );
+  }
+};
+var SimulationInvalidResponseError = class extends SimulationError {
+  constructor() {
+    super(
+      "Invalid response from simulation API",
+      "invalid-response" /* InvalidResponse */
+    );
+  }
+};
+var SimulationRevertedError = class extends SimulationError {
+  constructor() {
+    super("Transaction was reverted", "reverted" /* Reverted */);
+  }
+};
+
+
+
+
+
+
+exports.SimulationError = SimulationError; exports.SimulationChainNotSupportedError = SimulationChainNotSupportedError; exports.SimulationInvalidResponseError = SimulationInvalidResponseError; exports.SimulationRevertedError = SimulationRevertedError;
+//# sourceMappingURL=chunk-HMOSP33F.js.map
\ No newline at end of file
diff --git a/dist/chunk-IXIBW7YO.js b/dist/chunk-IXIBW7YO.js
new file mode 100644
index 0000000000000000000000000000000000000000..ce7ef194a280df0d20079a551080d78ff5cc13a2
--- /dev/null
+++ b/dist/chunk-IXIBW7YO.js
@@ -0,0 +1,2392 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+var _chunkDTDTOMTBjs = require('./chunk-DTDTOMTB.js');
+
+
+var _chunkNRWEI43Qjs = require('./chunk-NRWEI43Q.js');
+
+
+var _chunk5XBULBP2js = require('./chunk-5XBULBP2.js');
+
+
+var _chunkSD6CWFDFjs = require('./chunk-SD6CWFDF.js');
+
+
+
+var _chunkVH47Q6TSjs = require('./chunk-VH47Q6TS.js');
+
+
+var _chunkUCY5PFZIjs = require('./chunk-UCY5PFZI.js');
+
+
+var _chunk2AYEGKANjs = require('./chunk-2AYEGKAN.js');
+
+
+var _chunkF3CMU2DMjs = require('./chunk-F3CMU2DM.js');
+
+
+var _chunk5ZAGN3YFjs = require('./chunk-5ZAGN3YF.js');
+
+
+var _chunk2JERLB6Mjs = require('./chunk-2JERLB6M.js');
+
+
+
+var _chunk5OQ373JSjs = require('./chunk-5OQ373JS.js');
+
+
+
+
+
+
+
+
+
+
+
+var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
+
+
+
+
+var _chunkRQKICZYPjs = require('./chunk-RQKICZYP.js');
+
+
+
+var _chunkQP75SWIQjs = require('./chunk-QP75SWIQ.js');
+
+
+var _chunkR7NJVDWNjs = require('./chunk-R7NJVDWN.js');
+
+
+
+var _chunkZNZEJDOEjs = require('./chunk-ZNZEJDOE.js');
+
+
+var _chunkV5X6MZHNjs = require('./chunk-V5X6MZHN.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunk7LXE4KHVjs = require('./chunk-7LXE4KHV.js');
+
+
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/TransactionController.ts
+var _common = require('@ethereumjs/common');
+var _tx = require('@ethereumjs/tx');
+var _util = require('@ethereumjs/util');
+var _basecontroller = require('@metamask/base-controller');
+
+
+
+
+
+
+var _controllerutils = require('@metamask/controller-utils');
+var _ethquery = require('@metamask/eth-query'); var _ethquery2 = _interopRequireDefault(_ethquery);
+var _networkcontroller = require('@metamask/network-controller');
+var _rpcerrors = require('@metamask/rpc-errors');
+var _utils = require('@metamask/utils');
+var _asyncmutex = require('async-mutex');
+var _ethmethodregistry = require('eth-method-registry');
+var _events = require('events');
+var _lodash = require('lodash');
+var _noncetracker = require('nonce-tracker');
+var _uuid = require('uuid');
+var metadata = {
+  transactions: {
+    persist: true,
+    anonymous: false
+  },
+  methodData: {
+    persist: true,
+    anonymous: false
+  },
+  lastFetchedBlockNumbers: {
+    persist: true,
+    anonymous: false
+  }
+};
+var HARDFORK = _common.Hardfork.London;
+var CANCEL_RATE = 1.1;
+var SPEED_UP_RATE = 1.1;
+var controllerName = "TransactionController";
+var ApprovalState = /* @__PURE__ */ ((ApprovalState2) => {
+  ApprovalState2["Approved"] = "approved";
+  ApprovalState2["NotApproved"] = "not-approved";
+  ApprovalState2["SkippedViaBeforePublishHook"] = "skipped-via-before-publish-hook";
+  return ApprovalState2;
+})(ApprovalState || {});
+function getDefaultTransactionControllerState() {
+  return {
+    methodData: {},
+    transactions: [],
+    lastFetchedBlockNumbers: {}
+  };
+}
+var _internalEvents, _incomingTransactionOptions, _pendingTransactionOptions, _transactionHistoryLimit, _isSimulationEnabled, _multichainTrackingHelper, _createNonceTracker, createNonceTracker_fn, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn, _createPendingTransactionTracker, createPendingTransactionTracker_fn, _checkForPendingTransactionAndStartPolling, _stopAllTracking, stopAllTracking_fn, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn, _getGasFeeFlows, getGasFeeFlows_fn, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn, _updateTransactionInternal, updateTransactionInternal_fn, _checkIfTransactionParamsUpdated, checkIfTransactionParamsUpdated_fn, _onTransactionParamsUpdated, onTransactionParamsUpdated_fn, _updateSimulationData, updateSimulationData_fn;
+var TransactionController = class extends _basecontroller.BaseController {
+  /**
+   * Constructs a TransactionController.
+   *
+   * @param options - The controller options.
+   * @param options.blockTracker - The block tracker used to poll for new blocks data.
+   * @param options.disableHistory - Whether to disable storing history in transaction metadata.
+   * @param options.disableSendFlowHistory - Explicitly disable transaction metadata history.
+   * @param options.disableSwaps - Whether to disable additional processing on swaps transactions.
+   * @param options.getCurrentAccountEIP1559Compatibility - Whether or not the account supports EIP-1559.
+   * @param options.getCurrentNetworkEIP1559Compatibility - Whether or not the network supports EIP-1559.
+   * @param options.getExternalPendingTransactions - Callback to retrieve pending transactions from external sources.
+   * @param options.getGasFeeEstimates - Callback to retrieve gas fee estimates.
+   * @param options.getNetworkClientRegistry - Gets the network client registry.
+   * @param options.getNetworkState - Gets the state of the network controller.
+   * @param options.getPermittedAccounts - Get accounts that a given origin has permissions for.
+   * @param options.getSavedGasFees - Gets the saved gas fee config.
+   * @param options.getSelectedAddress - Gets the address of the currently selected account.
+   * @param options.incomingTransactions - Configuration options for incoming transaction support.
+   * @param options.isMultichainEnabled - Enable multichain support.
+   * @param options.isSimulationEnabled - Whether new transactions will be automatically simulated.
+   * @param options.messenger - The controller messenger.
+   * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
+   * @param options.pendingTransactions - Configuration options for pending transaction support.
+   * @param options.provider - The provider used to create the underlying EthQuery instance.
+   * @param options.securityProviderRequest - A function for verifying a transaction, whether it is malicious or not.
+   * @param options.sign - Function used to sign transactions.
+   * @param options.state - Initial state to set on this controller.
+   * @param options.transactionHistoryLimit - Transaction history limit.
+   * @param options.hooks - The controller hooks.
+   */
+  constructor({
+    blockTracker,
+    disableHistory,
+    disableSendFlowHistory,
+    disableSwaps,
+    getCurrentAccountEIP1559Compatibility,
+    getCurrentNetworkEIP1559Compatibility,
+    getExternalPendingTransactions,
+    getGasFeeEstimates,
+    getNetworkClientRegistry,
+    getNetworkState,
+    getPermittedAccounts,
+    getSavedGasFees,
+    getSelectedAddress,
+    incomingTransactions = {},
+    isMultichainEnabled = false,
+    isSimulationEnabled,
+    messenger,
+    onNetworkStateChange,
+    pendingTransactions = {},
+    provider,
+    securityProviderRequest,
+    sign,
+    state,
+    transactionHistoryLimit = 40,
+    hooks
+  }) {
+    super({
+      name: controllerName,
+      metadata,
+      messenger,
+      state: {
+        ...getDefaultTransactionControllerState(),
+        ...state
+      }
+    });
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createNonceTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createIncomingTransactionHelper);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _createPendingTransactionTracker);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _stopAllTracking);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removeIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addIncomingTransactionHelperListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _removePendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _addPendingTransactionTrackerListeners);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getNonceTrackerPendingTransactions);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getGasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLayer1GasFeeFlows);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateTransactionInternal);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkIfTransactionParamsUpdated);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _onTransactionParamsUpdated);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _updateSimulationData);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _internalEvents, new (0, _events.EventEmitter)());
+    this.inProcessOfSigning = /* @__PURE__ */ new Set();
+    this.mutex = new (0, _asyncmutex.Mutex)();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _incomingTransactionOptions, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _pendingTransactionOptions, void 0);
+    this.signAbortCallbacks = /* @__PURE__ */ new Map();
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _transactionHistoryLimit, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _isSimulationEnabled, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _multichainTrackingHelper, void 0);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _checkForPendingTransactionAndStartPolling, () => {
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).checkForPendingTransactionAndStartPolling();
+    });
+    this.messagingSystem = messenger;
+    this.getNetworkState = getNetworkState;
+    this.isSendFlowHistoryDisabled = disableSendFlowHistory ?? false;
+    this.isHistoryDisabled = disableHistory ?? false;
+    this.isSwapsDisabled = disableSwaps ?? false;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _isSimulationEnabled, isSimulationEnabled ?? (() => true));
+    this.registry = new (0, _ethmethodregistry.MethodRegistry)({ provider });
+    this.getSavedGasFees = getSavedGasFees ?? ((_chainId) => void 0);
+    this.getCurrentAccountEIP1559Compatibility = getCurrentAccountEIP1559Compatibility ?? (() => Promise.resolve(true));
+    this.getCurrentNetworkEIP1559Compatibility = getCurrentNetworkEIP1559Compatibility;
+    this.getGasFeeEstimates = getGasFeeEstimates || (() => Promise.resolve({}));
+    this.getPermittedAccounts = getPermittedAccounts;
+    this.getSelectedAddress = getSelectedAddress;
+    this.getExternalPendingTransactions = getExternalPendingTransactions ?? (() => []);
+    this.securityProviderRequest = securityProviderRequest;
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _incomingTransactionOptions, incomingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _pendingTransactionOptions, pendingTransactions);
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _transactionHistoryLimit, transactionHistoryLimit);
+    this.sign = sign;
+    this.afterSign = hooks?.afterSign ?? (() => true);
+    this.beforeApproveOnInit = hooks?.beforeApproveOnInit ?? (() => true);
+    this.beforeCheckPendingTransaction = hooks?.beforeCheckPendingTransaction ?? /* istanbul ignore next */
+    (() => true);
+    this.beforePublish = hooks?.beforePublish ?? (() => true);
+    this.getAdditionalSignArguments = hooks?.getAdditionalSignArguments ?? (() => []);
+    this.publish = hooks?.publish ?? (() => Promise.resolve({ transactionHash: void 0 }));
+    this.nonceTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    _chunkZ4BLTVTBjs.__privateSet.call(void 0, this, _multichainTrackingHelper, new (0, _chunkNRWEI43Qjs.MultichainTrackingHelper)({
+      isMultichainEnabled,
+      provider,
+      nonceTracker: this.nonceTracker,
+      incomingTransactionOptions: incomingTransactions,
+      findNetworkClientIdByChainId: (chainId) => {
+        return this.messagingSystem.call(
+          `NetworkController:findNetworkClientIdByChainId`,
+          chainId
+        );
+      },
+      getNetworkClientById: (networkClientId) => {
+        return this.messagingSystem.call(
+          `NetworkController:getNetworkClientById`,
+          networkClientId
+        );
+      },
+      getNetworkClientRegistry,
+      removeIncomingTransactionHelperListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).bind(this),
+      removePendingTransactionTrackerListeners: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).bind(this),
+      createNonceTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createNonceTracker, createNonceTracker_fn).bind(this),
+      createIncomingTransactionHelper: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).bind(this),
+      createPendingTransactionTracker: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).bind(this),
+      onNetworkStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "NetworkController:stateChange",
+          listener
+        );
+      }
+    }));
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).initialize();
+    const etherscanRemoteTransactionSource = new (0, _chunkF3CMU2DMjs.EtherscanRemoteTransactionSource)({
+      includeTokenTransfers: incomingTransactions.includeTokenTransfers
+    });
+    this.incomingTransactionHelper = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createIncomingTransactionHelper, createIncomingTransactionHelper_fn).call(this, {
+      blockTracker,
+      etherscanRemoteTransactionSource
+    });
+    this.pendingTransactionTracker = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _createPendingTransactionTracker, createPendingTransactionTracker_fn).call(this, {
+      provider,
+      blockTracker
+    });
+    this.gasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getGasFeeFlows, getGasFeeFlows_fn).call(this);
+    this.layer1GasFeeFlows = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLayer1GasFeeFlows, getLayer1GasFeeFlows_fn).call(this);
+    const gasFeePoller = new (0, _chunk5ZAGN3YFjs.GasFeePoller)({
+      // Default gas fee polling is not yet supported by the clients
+      gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+      getEthQuery: (chainId, networkClientId) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId,
+        chainId
+      }),
+      getGasFeeControllerEstimates: this.getGasFeeEstimates,
+      getTransactions: () => this.state.transactions,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      onStateChange: (listener) => {
+        this.messagingSystem.subscribe(
+          "TransactionController:stateChange",
+          listener
+        );
+      }
+    });
+    gasFeePoller.hub.on(
+      "transaction-updated",
+      (transactionMeta) => _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, transactionMeta, { skipHistory: true })
+    );
+    this.messagingSystem.subscribe(
+      "TransactionController:stateChange",
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _checkForPendingTransactionAndStartPolling)
+    );
+    onNetworkStateChange(() => {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Detected network change", this.getChainId());
+      this.pendingTransactionTracker.startIfPendingTransactions();
+      this.onBootCleanup();
+    });
+    this.onBootCleanup();
+  }
+  failTransaction(transactionMeta, error, actionId) {
+    const newTransactionMeta = _lodash.merge.call(void 0, {}, transactionMeta, {
+      error: _chunkUGFBA4GVjs.normalizeTxError.call(void 0, error),
+      status: "failed" /* failed */
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionFailed`, {
+      actionId,
+      error: error.message,
+      transactionMeta: newTransactionMeta
+    });
+    this.updateTransaction(
+      newTransactionMeta,
+      "TransactionController#failTransaction - Add error message and set status to failed"
+    );
+    this.onTransactionStatusChange(newTransactionMeta);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      newTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      newTransactionMeta
+    );
+  }
+  async registryLookup(fourBytePrefix) {
+    const registryMethod = await this.registry.lookup(fourBytePrefix);
+    if (!registryMethod) {
+      return {
+        registryMethod: "",
+        parsedRegistryMethod: { name: void 0, args: void 0 }
+      };
+    }
+    const parsedRegistryMethod = this.registry.parse(registryMethod);
+    return { registryMethod, parsedRegistryMethod };
+  }
+  /**
+   * Stops polling and removes listeners to prepare the controller for garbage collection.
+   */
+  destroy() {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _stopAllTracking, stopAllTracking_fn).call(this);
+  }
+  /**
+   * Handle new method data request.
+   *
+   * @param fourBytePrefix - The method prefix.
+   * @returns The method data object corresponding to the given signature prefix.
+   */
+  async handleMethodData(fourBytePrefix) {
+    const releaseLock = await this.mutex.acquire();
+    try {
+      const { methodData } = this.state;
+      const knownMethod = Object.keys(methodData).find(
+        (knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix
+      );
+      if (knownMethod) {
+        return methodData[fourBytePrefix];
+      }
+      const registry = await this.registryLookup(fourBytePrefix);
+      this.update((state) => {
+        state.methodData[fourBytePrefix] = registry;
+      });
+      return registry;
+    } finally {
+      releaseLock();
+    }
+  }
+  /**
+   * Add a new unapproved transaction to state. Parameters will be validated, a
+   * unique transaction id will be generated, and gas and gasPrice will be calculated
+   * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
+   *
+   * @param txParams - Standard parameters for an Ethereum transaction.
+   * @param opts - Additional options to control how the transaction is added.
+   * @param opts.actionId - Unique ID to prevent duplicate requests.
+   * @param opts.deviceConfirmedOn - An enum to indicate what device confirmed the transaction.
+   * @param opts.method - RPC method that requested the transaction.
+   * @param opts.origin - The origin of the transaction request, such as a dApp hostname.
+   * @param opts.requireApproval - Whether the transaction requires approval by the user, defaults to true unless explicitly disabled.
+   * @param opts.securityAlertResponse - Response from security validator.
+   * @param opts.sendFlowHistory - The sendFlowHistory entries to add.
+   * @param opts.type - Type of transaction to add, such as 'cancel' or 'swap'.
+   * @param opts.swaps - Options for swaps transactions.
+   * @param opts.swaps.hasApproveTx - Whether the transaction has an approval transaction.
+   * @param opts.swaps.meta - Metadata for swap transaction.
+   * @param opts.networkClientId - The id of the network client for this transaction.
+   * @returns Object containing a promise resolving to the transaction hash if approved.
+   */
+  async addTransaction(txParams, {
+    actionId,
+    deviceConfirmedOn,
+    method,
+    origin,
+    requireApproval,
+    securityAlertResponse,
+    sendFlowHistory,
+    swaps = {},
+    type,
+    networkClientId
+  } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Adding transaction", txParams);
+    txParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, txParams);
+    if (networkClientId && !_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).has(networkClientId)) {
+      throw new Error(
+        "The networkClientId for this transaction could not be found"
+      );
+    }
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(
+      networkClientId
+    );
+    _chunkVH47Q6TSjs.validateTxParams.call(void 0, txParams, isEIP1559Compatible);
+    if (origin) {
+      await _chunkVH47Q6TSjs.validateTransactionOrigin.call(void 0, 
+        await this.getPermittedAccounts(origin),
+        this.getSelectedAddress(),
+        txParams.from,
+        origin
+      );
+    }
+    const dappSuggestedGasFees = this.generateDappSuggestedGasFees(
+      txParams,
+      origin
+    );
+    const chainId = this.getChainId(networkClientId);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    const transactionType = type ?? (await _chunkSD6CWFDFjs.determineTransactionType.call(void 0, txParams, ethQuery)).type;
+    const existingTransactionMeta = this.getTransactionWithActionId(actionId);
+    let addedTransactionMeta = existingTransactionMeta ? _lodash.cloneDeep.call(void 0, existingTransactionMeta) : {
+      // Add actionId to txMeta to check if same actionId is seen again
+      actionId,
+      chainId,
+      dappSuggestedGasFees,
+      deviceConfirmedOn,
+      id: _uuid.v1.call(void 0, ),
+      origin,
+      securityAlertResponse,
+      status: "unapproved" /* unapproved */,
+      time: Date.now(),
+      txParams,
+      userEditedGasLimit: false,
+      verifiedOnBlockchain: false,
+      type: transactionType,
+      networkClientId
+    };
+    await this.updateGasProperties(addedTransactionMeta);
+    if (!existingTransactionMeta) {
+      if (method && this.securityProviderRequest) {
+        const securityProviderResponse = await this.securityProviderRequest(
+          addedTransactionMeta,
+          method
+        );
+        addedTransactionMeta.securityProviderResponse = securityProviderResponse;
+      }
+      if (!this.isSendFlowHistoryDisabled) {
+        addedTransactionMeta.sendFlowHistory = sendFlowHistory ?? [];
+      }
+      if (!this.isHistoryDisabled) {
+        addedTransactionMeta = _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, addedTransactionMeta);
+      }
+      addedTransactionMeta = _chunk5OQ373JSjs.updateSwapsTransaction.call(void 0, 
+        addedTransactionMeta,
+        transactionType,
+        swaps,
+        {
+          isSwapsDisabled: this.isSwapsDisabled,
+          cancelTransaction: this.cancelTransaction.bind(this),
+          messenger: this.messagingSystem
+        }
+      );
+      this.addMetadata(addedTransactionMeta);
+      if (requireApproval !== false) {
+        _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateSimulationData, updateSimulationData_fn).call(this, addedTransactionMeta);
+      } else {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping simulation as approval not required");
+      }
+      this.messagingSystem.publish(
+        `${controllerName}:unapprovedTransactionAdded`,
+        addedTransactionMeta
+      );
+    }
+    return {
+      result: this.processApproval(addedTransactionMeta, {
+        isExisting: Boolean(existingTransactionMeta),
+        requireApproval,
+        actionId
+      }),
+      transactionMeta: addedTransactionMeta
+    };
+  }
+  startIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.start();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).startIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopIncomingTransactionPolling(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      this.incomingTransactionHelper.stop();
+      return;
+    }
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopIncomingTransactionPolling(
+      networkClientIds
+    );
+  }
+  stopAllIncomingTransactionPolling() {
+    this.incomingTransactionHelper.stop();
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllIncomingTransactionPolling();
+  }
+  async updateIncomingTransactions(networkClientIds = []) {
+    if (networkClientIds.length === 0) {
+      await this.incomingTransactionHelper.update();
+      return;
+    }
+    await _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).updateIncomingTransactions(
+      networkClientIds
+    );
+  }
+  /**
+   * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param gasValues - The gas values to use for the cancellation transaction.
+   * @param options - The options for the cancellation transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests.
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async stopTransaction(transactionId, gasValues, {
+    estimatedBaseFee,
+    actionId
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating cancel transaction", transactionId, gasValues);
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      CANCEL_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      CANCEL_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      CANCEL_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const newTxParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    } : {
+      from: transactionMeta.txParams.from,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice,
+      nonce: transactionMeta.txParams.nonce,
+      to: transactionMeta.txParams.from,
+      value: "0x0"
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      newTxParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = newTxParams.maxFeePerGas ?? newTxParams.gasPrice;
+    const oldFee = newTxParams.maxFeePerGas ? transactionMeta.txParams.maxFeePerGas : transactionMeta.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting cancel transaction", {
+      oldFee,
+      newFee,
+      txParams: newTxParams
+    });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const cancelTransactionMeta = {
+      actionId,
+      chainId: transactionMeta.chainId,
+      networkClientId: transactionMeta.networkClientId,
+      estimatedBaseFee,
+      hash,
+      id: _uuid.v1.call(void 0, ),
+      originalGasEstimate: transactionMeta.txParams.gas,
+      status: "submitted" /* submitted */,
+      time: Date.now(),
+      type: "cancel" /* cancel */,
+      txParams: newTxParams
+    };
+    this.addMetadata(cancelTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: cancelTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      cancelTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      cancelTransactionMeta
+    );
+  }
+  /**
+   * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.
+   *
+   * @param transactionId - The ID of the transaction to speed up.
+   * @param gasValues - The gas values to use for the speed up transaction.
+   * @param options - The options for the speed up transaction.
+   * @param options.actionId - Unique ID to prevent duplicate requests
+   * @param options.estimatedBaseFee - The estimated base fee of the transaction.
+   */
+  async speedUpTransaction(transactionId, gasValues, {
+    actionId,
+    estimatedBaseFee
+  } = {}) {
+    if (this.getTransactionWithActionId(actionId)) {
+      return;
+    }
+    if (gasValues) {
+      gasValues = _chunkUGFBA4GVjs.normalizeGasFeeValues.call(void 0, gasValues);
+      _chunkUGFBA4GVjs.validateGasValues.call(void 0, gasValues);
+    }
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Creating speed up transaction", transactionId, gasValues);
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const minGasPrice = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      transactionMeta.txParams.gasPrice,
+      SPEED_UP_RATE
+    );
+    const gasPriceFromValues = _chunkUGFBA4GVjs.isGasPriceValue.call(void 0, gasValues) && gasValues.gasPrice;
+    const newGasPrice = gasPriceFromValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, gasPriceFromValues, minGasPrice) || minGasPrice;
+    const existingMaxFeePerGas = transactionMeta.txParams?.maxFeePerGas;
+    const minMaxFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxFeePerGas;
+    const newMaxFeePerGas = maxFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, maxFeePerGasValues, minMaxFeePerGas) || existingMaxFeePerGas && minMaxFeePerGas;
+    const existingMaxPriorityFeePerGas = transactionMeta.txParams?.maxPriorityFeePerGas;
+    const minMaxPriorityFeePerGas = _chunkUGFBA4GVjs.getIncreasedPriceFromExisting.call(void 0, 
+      existingMaxPriorityFeePerGas,
+      SPEED_UP_RATE
+    );
+    const maxPriorityFeePerGasValues = _chunkUGFBA4GVjs.isFeeMarketEIP1559Values.call(void 0, gasValues) && gasValues.maxPriorityFeePerGas;
+    const newMaxPriorityFeePerGas = maxPriorityFeePerGasValues && _chunkUGFBA4GVjs.validateMinimumIncrease.call(void 0, 
+      maxPriorityFeePerGasValues,
+      minMaxPriorityFeePerGas
+    ) || existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas;
+    const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      maxFeePerGas: newMaxFeePerGas,
+      maxPriorityFeePerGas: newMaxPriorityFeePerGas,
+      type: "0x2" /* feeMarket */
+    } : {
+      ...transactionMeta.txParams,
+      gasLimit: transactionMeta.txParams.gas,
+      gasPrice: newGasPrice
+    };
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    const signedTx = await this.sign(
+      unsignedEthTx,
+      transactionMeta.txParams.from
+    );
+    const transactionMetaWithRsv = await this.updateTransactionMetaRSV(
+      transactionMeta,
+      signedTx
+    );
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const newFee = txParams.maxFeePerGas ?? txParams.gasPrice;
+    const oldFee = txParams.maxFeePerGas ? transactionMetaWithRsv.txParams.maxFeePerGas : transactionMetaWithRsv.txParams.gasPrice;
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Submitting speed up transaction", { oldFee, newFee, txParams });
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const hash = await this.publishTransactionForRetry(
+      ethQuery,
+      rawTx,
+      transactionMeta
+    );
+    const baseTransactionMeta = {
+      ...transactionMetaWithRsv,
+      estimatedBaseFee,
+      id: _uuid.v1.call(void 0, ),
+      time: Date.now(),
+      hash,
+      actionId,
+      originalGasEstimate: transactionMeta.txParams.gas,
+      type: "retry" /* retry */,
+      originalType: transactionMeta.type
+    };
+    const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas ? {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        maxFeePerGas: newMaxFeePerGas,
+        maxPriorityFeePerGas: newMaxPriorityFeePerGas
+      }
+    } : {
+      ...baseTransactionMeta,
+      txParams: {
+        ...transactionMeta.txParams,
+        gasPrice: newGasPrice
+      }
+    };
+    this.addMetadata(newTransactionMeta);
+    this.messagingSystem.publish(`${controllerName}:transactionApproved`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+      transactionMeta: newTransactionMeta,
+      actionId
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:speedupTransactionAdded`,
+      newTransactionMeta
+    );
+  }
+  /**
+   * Estimates required gas for a given transaction.
+   *
+   * @param transaction - The transaction to estimate gas for.
+   * @param networkClientId - The network client id to use for the estimate.
+   * @returns The gas and gas price.
+   */
+  async estimateGas(transaction, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { estimatedGas, simulationFails } = await _chunkRQKICZYPjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    return { gas: estimatedGas, simulationFails };
+  }
+  /**
+   * Estimates required gas for a given transaction and add additional gas buffer with the given multiplier.
+   *
+   * @param transaction - The transaction params to estimate gas for.
+   * @param multiplier - The multiplier to use for the gas buffer.
+   * @param networkClientId - The network client id to use for the estimate.
+   */
+  async estimateGasBuffered(transaction, multiplier, networkClientId) {
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId
+    });
+    const { blockGasLimit, estimatedGas, simulationFails } = await _chunkRQKICZYPjs.estimateGas.call(void 0, 
+      transaction,
+      ethQuery
+    );
+    const gas = _chunkRQKICZYPjs.addGasBuffer.call(void 0, estimatedGas, blockGasLimit, multiplier);
+    return {
+      gas,
+      simulationFails
+    };
+  }
+  /**
+   * Updates an existing transaction in state.
+   *
+   * @param transactionMeta - The new transaction to store in state.
+   * @param note - A note or update reason to include in the transaction history.
+   */
+  updateTransaction(transactionMeta, note) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, transactionMeta, {
+      note,
+      skipHistory: this.isHistoryDisabled
+    });
+  }
+  /**
+   * Update the security alert response for a transaction.
+   *
+   * @param transactionId - ID of the transaction.
+   * @param securityAlertResponse - The new security alert response for the transaction.
+   */
+  updateSecurityAlertResponse(transactionId, securityAlertResponse) {
+    if (!securityAlertResponse) {
+      throw new Error(
+        "updateSecurityAlertResponse: securityAlertResponse should not be null"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update security alert response as no transaction metadata found`
+      );
+    }
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      securityAlertResponse
+    };
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updatesecurityAlertResponse - securityAlertResponse updated`
+    );
+  }
+  /**
+   * Removes all transactions from state, optionally based on the current network.
+   *
+   * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the
+   * current network. If `true`, all transactions are wiped.
+   * @param address - If specified, only transactions originating from this address will be
+   * wiped on current network.
+   */
+  wipeTransactions(ignoreNetwork, address) {
+    if (ignoreNetwork && !address) {
+      this.update((state) => {
+        state.transactions = [];
+      });
+      return;
+    }
+    const currentChainId = this.getChainId();
+    const newTransactions = this.state.transactions.filter(
+      ({ chainId, txParams }) => {
+        const isMatchingNetwork = ignoreNetwork || chainId === currentChainId;
+        if (!isMatchingNetwork) {
+          return true;
+        }
+        const isMatchingAddress = !address || txParams.from?.toLowerCase() === address.toLowerCase();
+        return !isMatchingAddress;
+      }
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(newTransactions);
+    });
+  }
+  /**
+   * Adds external provided transaction to state as confirmed transaction.
+   *
+   * @param transactionMeta - TransactionMeta to add transactions.
+   * @param transactionReceipt - TransactionReceipt of the external transaction.
+   * @param baseFeePerGas - Base fee per gas of the external transaction.
+   */
+  async confirmExternalTransaction(transactionMeta, transactionReceipt, baseFeePerGas) {
+    const newTransactionMeta = this.addExternalTransaction(transactionMeta);
+    try {
+      const transactionId = newTransactionMeta.id;
+      const updatedTransactionMeta = {
+        ...newTransactionMeta,
+        status: "confirmed" /* confirmed */,
+        txReceipt: transactionReceipt
+      };
+      if (baseFeePerGas) {
+        updatedTransactionMeta.baseFeePerGas = baseFeePerGas;
+      }
+      this.markNonceDuplicatesDropped(transactionId);
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:confirmExternalTransaction - Add external transaction`
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      this.updatePostBalance(updatedTransactionMeta);
+      this.messagingSystem.publish(
+        `${controllerName}:transactionConfirmed`,
+        updatedTransactionMeta
+      );
+    } catch (error) {
+      console.error("Failed to confirm external transaction", error);
+    }
+  }
+  /**
+   * Append new send flow history to a transaction.
+   *
+   * @param transactionID - The ID of the transaction to update.
+   * @param currentSendFlowHistoryLength - The length of the current sendFlowHistory array.
+   * @param sendFlowHistoryToAdd - The sendFlowHistory entries to add.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionSendFlowHistory(transactionID, currentSendFlowHistoryLength, sendFlowHistoryToAdd) {
+    if (this.isSendFlowHistoryDisabled) {
+      throw new Error(
+        "Send flow history is disabled for the current transaction controller"
+      );
+    }
+    const transactionMeta = this.getTransaction(transactionID);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update send flow history as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionSendFlowHistory"
+    );
+    const sendFlowHistory = transactionMeta.sendFlowHistory ?? [];
+    if (currentSendFlowHistoryLength === sendFlowHistory.length) {
+      const updatedTransactionMeta = {
+        ...transactionMeta,
+        sendFlowHistory: [...sendFlowHistory, ...sendFlowHistoryToAdd]
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        `${controllerName}:updateTransactionSendFlowHistory - sendFlowHistory updated`
+      );
+    }
+    return this.getTransaction(transactionID);
+  }
+  /**
+   * Update the gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param gasValues - Gas values to update.
+   * @param gasValues.gas - Same as transaction.gasLimit.
+   * @param gasValues.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param gasValues.gasPrice - Price per gas for legacy transactions.
+   * @param gasValues.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @param gasValues.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param gasValues.estimateUsed - Which estimate level was used.
+   * @param gasValues.estimateSuggested - Which estimate level that the API suggested.
+   * @param gasValues.defaultGasEstimates - The default estimate for gas.
+   * @param gasValues.originalGasEstimate - Original estimate for gas.
+   * @param gasValues.userEditedGasLimit - The gas limit supplied by user.
+   * @param gasValues.userFeeLevel - Estimate level user selected.
+   * @returns The updated transactionMeta.
+   */
+  updateTransactionGasFees(transactionId, {
+    defaultGasEstimates,
+    estimateUsed,
+    estimateSuggested,
+    gas,
+    gasLimit,
+    gasPrice,
+    maxPriorityFeePerGas,
+    maxFeePerGas,
+    originalGasEstimate,
+    userEditedGasLimit,
+    userFeeLevel
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, 
+      transactionMeta,
+      "updateTransactionGasFees"
+    );
+    let transactionGasFees = {
+      txParams: {
+        gas,
+        gasLimit,
+        gasPrice,
+        maxPriorityFeePerGas,
+        maxFeePerGas
+      },
+      defaultGasEstimates,
+      estimateUsed,
+      estimateSuggested,
+      originalGasEstimate,
+      userEditedGasLimit,
+      userFeeLevel
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionGasFees.txParams = _lodash.pickBy.call(void 0, transactionGasFees.txParams);
+    transactionGasFees = _lodash.pickBy.call(void 0, transactionGasFees);
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionGasFees);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updateTransactionGasFees - gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  /**
+   * Update the previous gas values of a transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param previousGas - Previous gas values to update.
+   * @param previousGas.gasLimit - Maxmimum number of units of gas to use for this transaction.
+   * @param previousGas.maxFeePerGas - Maximum amount per gas to pay for the transaction, including the priority fee.
+   * @param previousGas.maxPriorityFeePerGas - Maximum amount per gas to give to validator as incentive.
+   * @returns The updated transactionMeta.
+   */
+  updatePreviousGasParams(transactionId, {
+    gasLimit,
+    maxFeePerGas,
+    maxPriorityFeePerGas
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update transaction as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updatePreviousGasParams");
+    const transactionPreviousGas = {
+      previousGas: {
+        gasLimit,
+        maxFeePerGas,
+        maxPriorityFeePerGas
+      }
+      // TODO: Replace `any` with type
+      // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    };
+    transactionPreviousGas.previousGas = _lodash.pickBy.call(void 0, 
+      transactionPreviousGas.previousGas
+    );
+    const updatedMeta = _lodash.merge.call(void 0, {}, transactionMeta, transactionPreviousGas);
+    this.updateTransaction(
+      updatedMeta,
+      `${controllerName}:updatePreviousGasParams - Previous gas values updated`
+    );
+    return this.getTransaction(transactionId);
+  }
+  async getNonceLock(address, networkClientId) {
+    return _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(
+      address,
+      networkClientId
+    );
+  }
+  /**
+   * Updates the editable parameters of a transaction.
+   *
+   * @param txId - The ID of the transaction to update.
+   * @param params - The editable parameters to update.
+   * @param params.data - Data to pass with the transaction.
+   * @param params.gas - Maximum number of units of gas to use for the transaction.
+   * @param params.gasPrice - Price per gas for legacy transactions.
+   * @param params.from - Address to send the transaction from.
+   * @param params.to - Address to send the transaction to.
+   * @param params.value - Value associated with the transaction.
+   * @returns The updated transaction metadata.
+   */
+  async updateEditableParams(txId, {
+    data,
+    gas,
+    gasPrice,
+    from,
+    to,
+    value
+  }) {
+    const transactionMeta = this.getTransaction(txId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update editable params as no transaction metadata found`
+      );
+    }
+    _chunkUGFBA4GVjs.validateIfTransactionUnapproved.call(void 0, transactionMeta, "updateEditableParams");
+    const editableParams = {
+      txParams: {
+        data,
+        from,
+        to,
+        value,
+        gas,
+        gasPrice
+      }
+    };
+    editableParams.txParams = _lodash.pickBy.call(void 0, 
+      editableParams.txParams
+    );
+    const updatedTransaction = _lodash.merge.call(void 0, {}, transactionMeta, editableParams);
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId: transactionMeta.networkClientId,
+      chainId: transactionMeta.chainId
+    });
+    const { type } = await _chunkSD6CWFDFjs.determineTransactionType.call(void 0, 
+      updatedTransaction.txParams,
+      ethQuery
+    );
+    updatedTransaction.type = type;
+    await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+      ethQuery,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      transactionMeta: updatedTransaction
+    });
+    this.updateTransaction(
+      updatedTransaction,
+      `Update Editable Params for ${txId}`
+    );
+    return this.getTransaction(txId);
+  }
+  /**
+   * Signs and returns the raw transaction data for provided transaction params list.
+   *
+   * @param listOfTxParams - The list of transaction params to approve.
+   * @param opts - Options bag.
+   * @param opts.hasNonce - Whether the transactions already have a nonce.
+   * @returns The raw transactions.
+   */
+  async approveTransactionsWithSameNonce(listOfTxParams = [], { hasNonce } = {}) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Approving transactions with same nonce", {
+      transactions: listOfTxParams
+    });
+    if (listOfTxParams.length === 0) {
+      return "";
+    }
+    const initialTx = listOfTxParams[0];
+    const common = this.getCommonConfiguration(initialTx.chainId);
+    let networkClientId;
+    try {
+      networkClientId = this.messagingSystem.call(
+        `NetworkController:findNetworkClientIdByChainId`,
+        initialTx.chainId
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "failed to find networkClientId from chainId", err);
+    }
+    const initialTxAsEthTx = _tx.TransactionFactory.fromTxData(initialTx, {
+      common
+    });
+    const initialTxAsSerializedHex = _util.bufferToHex.call(void 0, initialTxAsEthTx.serialize());
+    if (this.inProcessOfSigning.has(initialTxAsSerializedHex)) {
+      return "";
+    }
+    this.inProcessOfSigning.add(initialTxAsSerializedHex);
+    let rawTransactions, nonceLock;
+    try {
+      const fromAddress = initialTx.from;
+      const requiresNonce = hasNonce !== true;
+      nonceLock = requiresNonce ? await this.getNonceLock(fromAddress, networkClientId) : void 0;
+      const nonce = nonceLock ? _utils.add0x.call(void 0, nonceLock.nextNonce.toString(16)) : initialTx.nonce;
+      if (nonceLock) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Using nonce from nonce tracker", nonce, nonceLock.nonceDetails);
+      }
+      rawTransactions = await Promise.all(
+        listOfTxParams.map((txParams) => {
+          txParams.nonce = nonce;
+          return this.signExternalTransaction(txParams.chainId, txParams);
+        })
+      );
+    } catch (err) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while signing transactions with same nonce", err);
+      throw err;
+    } finally {
+      nonceLock?.releaseLock();
+      this.inProcessOfSigning.delete(initialTxAsSerializedHex);
+    }
+    return rawTransactions;
+  }
+  /**
+   * Update a custodial transaction.
+   *
+   * @param transactionId - The ID of the transaction to update.
+   * @param options - The custodial transaction options to update.
+   * @param options.errorMessage - The error message to be assigned in case transaction status update to failed.
+   * @param options.hash - The new hash value to be assigned.
+   * @param options.status - The new status value to be assigned.
+   */
+  updateCustodialTransaction(transactionId, {
+    errorMessage,
+    hash,
+    status
+  }) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(
+        `Cannot update custodial transaction as no transaction metadata found`
+      );
+    }
+    if (!transactionMeta.custodyId) {
+      throw new Error("Transaction must be a custodian transaction");
+    }
+    if (status && ![
+      "submitted" /* submitted */,
+      "signed" /* signed */,
+      "failed" /* failed */
+    ].includes(status)) {
+      throw new Error(
+        `Cannot update custodial transaction with status: ${status}`
+      );
+    }
+    const updatedTransactionMeta = _lodash.merge.call(void 0, 
+      {},
+      transactionMeta,
+      _lodash.pickBy.call(void 0, { hash, status })
+    );
+    if (status === "submitted" /* submitted */) {
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+    }
+    if (status === "failed" /* failed */) {
+      updatedTransactionMeta.error = _chunkUGFBA4GVjs.normalizeTxError.call(void 0, new Error(errorMessage));
+    }
+    this.updateTransaction(
+      updatedTransactionMeta,
+      `${controllerName}:updateCustodialTransaction - Custodial transaction updated`
+    );
+    if (["submitted" /* submitted */, "failed" /* failed */].includes(
+      status
+    )) {
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+    }
+  }
+  /**
+   * Creates approvals for all unapproved transactions persisted.
+   */
+  initApprovals() {
+    const chainId = this.getChainId();
+    const unapprovedTxs = this.state.transactions.filter(
+      (transaction) => transaction.status === "unapproved" /* unapproved */ && transaction.chainId === chainId && !transaction.isUserOperation
+    );
+    for (const txMeta of unapprovedTxs) {
+      this.processApproval(txMeta, {
+        shouldShowRequest: false
+      }).catch((error) => {
+        if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+          return;
+        }
+        console.error("Error during persisted transaction approval", error);
+      });
+    }
+  }
+  /**
+   * Search transaction metadata for matching entries.
+   *
+   * @param opts - Options bag.
+   * @param opts.searchCriteria - An object containing values or functions for transaction properties to filter transactions with.
+   * @param opts.initialList - The transactions to search. Defaults to the current state.
+   * @param opts.filterToCurrentNetwork - Whether to filter the results to the current network. Defaults to true.
+   * @param opts.limit - The maximum number of transactions to return. No limit by default.
+   * @returns An array of transactions matching the provided options.
+   */
+  getTransactions({
+    searchCriteria = {},
+    initialList,
+    filterToCurrentNetwork = true,
+    limit
+  } = {}) {
+    const chainId = this.getChainId();
+    const predicateMethods = _lodash.mapValues.call(void 0, searchCriteria, (predicate) => {
+      return typeof predicate === "function" ? predicate : (
+        // TODO: Replace `any` with type
+        // eslint-disable-next-line @typescript-eslint/no-explicit-any
+        (v) => v === predicate
+      );
+    });
+    const transactionsToFilter = initialList ?? this.state.transactions;
+    const filteredTransactions = _lodash.sortBy.call(void 0, 
+      _lodash.pickBy.call(void 0, transactionsToFilter, (transaction) => {
+        if (filterToCurrentNetwork && transaction.chainId !== chainId) {
+          return false;
+        }
+        for (const [key, predicate] of Object.entries(predicateMethods)) {
+          if (key in transaction.txParams) {
+            if (predicate(transaction.txParams[key]) === false) {
+              return false;
+            }
+          } else if (predicate(transaction[key]) === false) {
+            return false;
+          }
+        }
+        return true;
+      }),
+      "time"
+    );
+    if (limit !== void 0) {
+      const nonces = /* @__PURE__ */ new Set();
+      const txs = [];
+      for (let i = filteredTransactions.length - 1; i > -1; i--) {
+        const txMeta = filteredTransactions[i];
+        const { nonce } = txMeta.txParams;
+        if (!nonces.has(nonce)) {
+          if (nonces.size < limit) {
+            nonces.add(nonce);
+          } else {
+            continue;
+          }
+        }
+        txs.unshift(txMeta);
+      }
+      return txs;
+    }
+    return filteredTransactions;
+  }
+  async signExternalTransaction(chainId, transactionParams) {
+    if (!this.sign) {
+      throw new Error("No sign method defined.");
+    }
+    const normalizedTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionParams);
+    const type = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, normalizedTransactionParams) ? "0x2" /* feeMarket */ : "0x0" /* legacy */;
+    const updatedTransactionParams = {
+      ...normalizedTransactionParams,
+      type,
+      gasLimit: normalizedTransactionParams.gas,
+      chainId
+    };
+    const { from } = updatedTransactionParams;
+    const common = this.getCommonConfiguration(chainId);
+    const unsignedTransaction = _tx.TransactionFactory.fromTxData(
+      updatedTransactionParams,
+      { common }
+    );
+    const signedTransaction = await this.sign(unsignedTransaction, from);
+    const rawTransaction = _util.bufferToHex.call(void 0, signedTransaction.serialize());
+    return rawTransaction;
+  }
+  /**
+   * Removes unapproved transactions from state.
+   */
+  clearUnapprovedTransactions() {
+    const transactions = this.state.transactions.filter(
+      ({ status }) => status !== "unapproved" /* unapproved */
+    );
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+  }
+  /**
+   * Stop the signing process for a specific transaction.
+   * Throws an error causing the transaction status to be set to failed.
+   * @param transactionId - The ID of the transaction to stop signing.
+   */
+  abortTransactionSigning(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      throw new Error(`Cannot abort signing as no transaction metadata found`);
+    }
+    const abortCallback = this.signAbortCallbacks.get(transactionId);
+    if (!abortCallback) {
+      throw new Error(
+        `Cannot abort signing as transaction is not waiting for signing`
+      );
+    }
+    abortCallback();
+    this.signAbortCallbacks.delete(transactionId);
+  }
+  addMetadata(transactionMeta) {
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        transactionMeta
+      ]);
+    });
+  }
+  async updateGasProperties(transactionMeta) {
+    const isEIP1559Compatible = await this.getEIP1559Compatibility(transactionMeta.networkClientId) && transactionMeta.txParams.type !== "0x0" /* legacy */;
+    const { networkClientId, chainId } = transactionMeta;
+    const isCustomNetwork = networkClientId ? this.messagingSystem.call(
+      `NetworkController:getNetworkClientById`,
+      networkClientId
+    ).configuration.type === _networkcontroller.NetworkClientType.Custom : this.getNetworkState().providerConfig.type === _controllerutils.NetworkType.rpc;
+    const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+      networkClientId,
+      chainId
+    });
+    await _chunkRQKICZYPjs.updateGas.call(void 0, {
+      ethQuery,
+      chainId,
+      isCustomNetwork,
+      txMeta: transactionMeta
+    });
+    await _chunk2JERLB6Mjs.updateGasFees.call(void 0, {
+      eip1559: isEIP1559Compatible,
+      ethQuery,
+      gasFeeFlows: this.gasFeeFlows,
+      getGasFeeEstimates: this.getGasFeeEstimates,
+      getSavedGasFees: this.getSavedGasFees.bind(this),
+      txMeta: transactionMeta
+    });
+    await _chunkR7NJVDWNjs.updateTransactionLayer1GasFee.call(void 0, {
+      ethQuery,
+      layer1GasFeeFlows: this.layer1GasFeeFlows,
+      transactionMeta
+    });
+  }
+  onBootCleanup() {
+    this.submitApprovedTransactions();
+  }
+  /**
+   * Force submit approved transactions for all chains.
+   */
+  submitApprovedTransactions() {
+    const approvedTransactions = this.state.transactions.filter(
+      (transaction) => transaction.status === "approved" /* approved */
+    );
+    for (const transactionMeta of approvedTransactions) {
+      if (this.beforeApproveOnInit(transactionMeta)) {
+        this.approveTransaction(transactionMeta.id).catch((error) => {
+          console.error("Error while submitting persisted transaction", error);
+        });
+      }
+    }
+  }
+  async processApproval(transactionMeta, {
+    isExisting = false,
+    requireApproval,
+    shouldShowRequest = true,
+    actionId
+  }) {
+    const transactionId = transactionMeta.id;
+    let resultCallbacks;
+    const { meta, isCompleted } = this.isTransactionCompleted(transactionId);
+    const finishedPromise = isCompleted ? Promise.resolve(meta) : this.waitForTransactionFinished(transactionId);
+    if (meta && !isExisting && !isCompleted) {
+      try {
+        if (requireApproval !== false) {
+          const acceptResult = await this.requestApproval(transactionMeta, {
+            shouldShowRequest
+          });
+          resultCallbacks = acceptResult.resultCallbacks;
+          const approvalValue = acceptResult.value;
+          const updatedTransaction = approvalValue?.txMeta;
+          if (updatedTransaction) {
+            _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating transaction with approval data", {
+              customNonce: updatedTransaction.customNonceValue,
+              params: updatedTransaction.txParams
+            });
+            this.updateTransaction(
+              updatedTransaction,
+              "TransactionController#processApproval - Updated with approval data"
+            );
+          }
+        }
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          const approvalResult = await this.approveTransaction(transactionId);
+          if (approvalResult === "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */ && resultCallbacks) {
+            resultCallbacks.success();
+          }
+          const updatedTransactionMeta = this.getTransaction(
+            transactionId
+          );
+          this.messagingSystem.publish(
+            `${controllerName}:transactionApproved`,
+            {
+              transactionMeta: updatedTransactionMeta,
+              actionId
+            }
+          );
+        }
+      } catch (error) {
+        const { isCompleted: isTxCompleted } = this.isTransactionCompleted(transactionId);
+        if (!isTxCompleted) {
+          if (error?.code === _rpcerrors.errorCodes.provider.userRejectedRequest) {
+            this.cancelTransaction(transactionId, actionId);
+            throw _rpcerrors.providerErrors.userRejectedRequest(
+              "MetaMask Tx Signature: User denied transaction signature."
+            );
+          } else {
+            this.failTransaction(meta, error, actionId);
+          }
+        }
+      }
+    }
+    const finalMeta = await finishedPromise;
+    switch (finalMeta?.status) {
+      case "failed" /* failed */:
+        resultCallbacks?.error(finalMeta.error);
+        throw _rpcerrors.rpcErrors.internal(finalMeta.error.message);
+      case "submitted" /* submitted */:
+        resultCallbacks?.success();
+        return finalMeta.hash;
+      default:
+        const internalError = _rpcerrors.rpcErrors.internal(
+          `MetaMask Tx Signature: Unknown problem: ${JSON.stringify(
+            finalMeta || transactionId
+          )}`
+        );
+        resultCallbacks?.error(internalError);
+        throw internalError;
+    }
+  }
+  /**
+   * Approves a transaction and updates it's status in state. If this is not a
+   * retry transaction, a nonce will be generated. The transaction is signed
+   * using the sign configuration property, then published to the blockchain.
+   * A `<tx.id>:finished` hub event is fired after success or failure.
+   *
+   * @param transactionId - The ID of the transaction to approve.
+   */
+  async approveTransaction(transactionId) {
+    const { transactions } = this.state;
+    const releaseLock = await this.mutex.acquire();
+    const index = transactions.findIndex(({ id }) => transactionId === id);
+    const transactionMeta = transactions[index];
+    const updatedTransactionMeta = _lodash.cloneDeep.call(void 0, transactionMeta);
+    const {
+      txParams: { from },
+      networkClientId
+    } = transactionMeta;
+    let releaseNonceLock;
+    try {
+      if (!this.sign) {
+        releaseLock();
+        this.failTransaction(
+          transactionMeta,
+          new Error("No sign method defined.")
+        );
+        return "not-approved" /* NotApproved */;
+      } else if (!transactionMeta.chainId) {
+        releaseLock();
+        this.failTransaction(transactionMeta, new Error("No chainId defined."));
+        return "not-approved" /* NotApproved */;
+      }
+      if (this.inProcessOfSigning.has(transactionId)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping approval as signing in progress", transactionId);
+        return "not-approved" /* NotApproved */;
+      }
+      const [nonce, releaseNonce] = await _chunkZNZEJDOEjs.getNextNonce.call(void 0, 
+        transactionMeta,
+        (address) => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getNonceLock(address, networkClientId)
+      );
+      releaseNonceLock = releaseNonce;
+      updatedTransactionMeta.status = "approved" /* approved */;
+      updatedTransactionMeta.txParams = {
+        ...updatedTransactionMeta.txParams,
+        nonce,
+        chainId: transactionMeta.chainId
+      };
+      const baseTxParams = {
+        ...updatedTransactionMeta.txParams,
+        gasLimit: updatedTransactionMeta.txParams.gas
+      };
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction approved"
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      const isEIP1559 = _chunkUGFBA4GVjs.isEIP1559Transaction.call(void 0, updatedTransactionMeta.txParams);
+      const txParams = isEIP1559 ? {
+        ...baseTxParams,
+        estimatedBaseFee: updatedTransactionMeta.txParams.estimatedBaseFee,
+        type: "0x2" /* feeMarket */
+      } : baseTxParams;
+      const rawTx = await this.signTransaction(
+        updatedTransactionMeta,
+        txParams
+      );
+      if (!this.beforePublish(updatedTransactionMeta)) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping publishing transaction based on hook");
+        this.messagingSystem.publish(
+          `${controllerName}:transactionPublishingSkipped`,
+          updatedTransactionMeta
+        );
+        return "skipped-via-before-publish-hook" /* SkippedViaBeforePublishHook */;
+      }
+      if (!rawTx) {
+        return "not-approved" /* NotApproved */;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      if (transactionMeta.type === "swap" /* swap */) {
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, "Determining pre-transaction balance");
+        const preTxBalance = await _controllerutils.query.call(void 0, ethQuery, "getBalance", [from]);
+        updatedTransactionMeta.preTxBalance = preTxBalance;
+        _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+          "Updated pre-transaction balance",
+          updatedTransactionMeta.preTxBalance
+        );
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publishing transaction", txParams);
+      let { transactionHash: hash } = await this.publish(
+        updatedTransactionMeta,
+        rawTx
+      );
+      if (hash === void 0) {
+        hash = await this.publishTransaction(ethQuery, rawTx);
+      }
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Publish successful", hash);
+      updatedTransactionMeta.hash = hash;
+      updatedTransactionMeta.status = "submitted" /* submitted */;
+      updatedTransactionMeta.submittedTime = (/* @__PURE__ */ new Date()).getTime();
+      this.updateTransaction(
+        updatedTransactionMeta,
+        "TransactionController#approveTransaction - Transaction submitted"
+      );
+      this.messagingSystem.publish(`${controllerName}:transactionSubmitted`, {
+        transactionMeta: updatedTransactionMeta
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:transactionFinished`,
+        updatedTransactionMeta
+      );
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+        `${updatedTransactionMeta.id}:finished`,
+        updatedTransactionMeta
+      );
+      this.onTransactionStatusChange(updatedTransactionMeta);
+      return "approved" /* Approved */;
+    } catch (error) {
+      this.failTransaction(transactionMeta, error);
+      return "not-approved" /* NotApproved */;
+    } finally {
+      this.inProcessOfSigning.delete(transactionId);
+      releaseNonceLock?.();
+      releaseLock();
+    }
+  }
+  async publishTransaction(ethQuery, rawTransaction) {
+    return await _controllerutils.query.call(void 0, ethQuery, "sendRawTransaction", [rawTransaction]);
+  }
+  /**
+   * Cancels a transaction based on its ID by setting its status to "rejected"
+   * and emitting a `<tx.id>:finished` hub event.
+   *
+   * @param transactionId - The ID of the transaction to cancel.
+   * @param actionId - The actionId passed from UI
+   */
+  cancelTransaction(transactionId, actionId) {
+    const transactionMeta = this.state.transactions.find(
+      ({ id }) => id === transactionId
+    );
+    if (!transactionMeta) {
+      return;
+    }
+    this.update((state) => {
+      const transactions = state.transactions.filter(
+        ({ id }) => id !== transactionId
+      );
+      state.transactions = this.trimTransactionsForState(transactions);
+    });
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "rejected" /* rejected */
+    };
+    this.messagingSystem.publish(
+      `${controllerName}:transactionFinished`,
+      updatedTransactionMeta
+    );
+    _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).emit(
+      `${transactionMeta.id}:finished`,
+      updatedTransactionMeta
+    );
+    this.messagingSystem.publish(`${controllerName}:transactionRejected`, {
+      transactionMeta: updatedTransactionMeta,
+      actionId
+    });
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Trim the amount of transactions that are set on the state. Checks
+   * if the length of the tx history is longer then desired persistence
+   * limit and then if it is removes the oldest confirmed or rejected tx.
+   * Pending or unapproved transactions will not be removed by this
+   * operation. For safety of presenting a fully functional transaction UI
+   * representation, this function will not break apart transactions with the
+   * same nonce, created on the same day, per network. Not accounting for
+   * transactions of the same nonce, same day and network combo can result in
+   * confusing or broken experiences in the UI.
+   *
+   * @param transactions - The transactions to be applied to the state.
+   * @returns The trimmed list of transactions.
+   */
+  trimTransactionsForState(transactions) {
+    const nonceNetworkSet = /* @__PURE__ */ new Set();
+    const txsToKeep = [...transactions].sort((a, b) => a.time > b.time ? -1 : 1).filter((tx) => {
+      const { chainId, status, txParams, time } = tx;
+      if (txParams) {
+        const key = `${String(txParams.nonce)}-${_controllerutils.convertHexToDecimal.call(void 0, 
+          chainId
+        )}-${new Date(time).toDateString()}`;
+        if (nonceNetworkSet.has(key)) {
+          return true;
+        } else if (nonceNetworkSet.size < _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit) || !this.isFinalState(status)) {
+          nonceNetworkSet.add(key);
+          return true;
+        }
+      }
+      return false;
+    });
+    txsToKeep.reverse();
+    return txsToKeep;
+  }
+  /**
+   * Determines if the transaction is in a final state.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isFinalState(status) {
+    return status === "rejected" /* rejected */ || status === "confirmed" /* confirmed */ || status === "failed" /* failed */;
+  }
+  /**
+   * Whether the transaction has at least completed all local processing.
+   *
+   * @param status - The transaction status.
+   * @returns Whether the transaction is in a final state.
+   */
+  isLocalFinalState(status) {
+    return [
+      "confirmed" /* confirmed */,
+      "failed" /* failed */,
+      "rejected" /* rejected */,
+      "submitted" /* submitted */
+    ].includes(status);
+  }
+  async requestApproval(txMeta, { shouldShowRequest }) {
+    const id = this.getApprovalId(txMeta);
+    const { origin } = txMeta;
+    const type = _controllerutils.ApprovalType.Transaction;
+    const requestData = { txId: txMeta.id };
+    return await this.messagingSystem.call(
+      "ApprovalController:addRequest",
+      {
+        id,
+        origin: origin || _controllerutils.ORIGIN_METAMASK,
+        type,
+        requestData,
+        expectsResult: true
+      },
+      shouldShowRequest
+    );
+  }
+  getTransaction(transactionId) {
+    const { transactions } = this.state;
+    return transactions.find(({ id }) => id === transactionId);
+  }
+  getApprovalId(txMeta) {
+    return String(txMeta.id);
+  }
+  isTransactionCompleted(transactionId) {
+    const transaction = this.getTransaction(transactionId);
+    if (!transaction) {
+      return { meta: void 0, isCompleted: false };
+    }
+    const isCompleted = this.isLocalFinalState(transaction.status);
+    return { meta: transaction, isCompleted };
+  }
+  getChainId(networkClientId) {
+    if (networkClientId) {
+      return this.messagingSystem.call(
+        `NetworkController:getNetworkClientById`,
+        networkClientId
+      ).configuration.chainId;
+    }
+    const { providerConfig } = this.getNetworkState();
+    return providerConfig.chainId;
+  }
+  prepareUnsignedEthTx(chainId, txParams) {
+    return _tx.TransactionFactory.fromTxData(txParams, {
+      freeze: false,
+      common: this.getCommonConfiguration(chainId)
+    });
+  }
+  /**
+   * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
+   * specifying which chain, network, hardfork and EIPs to support for
+   * a transaction. By referencing this configuration, and analyzing the fields
+   * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
+   * transaction type to use.
+   *
+   * @param chainId - The chainId to use for the configuration.
+   * @returns common configuration object
+   */
+  getCommonConfiguration(chainId) {
+    const customChainParams = {
+      chainId: parseInt(chainId, 16),
+      defaultHardfork: HARDFORK
+    };
+    return _common.Common.custom(customChainParams);
+  }
+  onIncomingTransactions({
+    added,
+    updated
+  }) {
+    this.update((state) => {
+      const { transactions: currentTransactions } = state;
+      const updatedTransactions = [
+        ...added,
+        ...currentTransactions.map((originalTransaction) => {
+          const updatedTransaction = updated.find(
+            ({ hash }) => hash === originalTransaction.hash
+          );
+          return updatedTransaction ?? originalTransaction;
+        })
+      ];
+      state.transactions = this.trimTransactionsForState(updatedTransactions);
+    });
+  }
+  onUpdatedLastFetchedBlockNumbers({
+    lastFetchedBlockNumbers,
+    blockNumber
+  }) {
+    this.update((state) => {
+      state.lastFetchedBlockNumbers = lastFetchedBlockNumbers;
+    });
+    this.messagingSystem.publish(
+      `${controllerName}:incomingTransactionBlockReceived`,
+      blockNumber
+    );
+  }
+  generateDappSuggestedGasFees(txParams, origin) {
+    if (!origin || origin === _controllerutils.ORIGIN_METAMASK) {
+      return void 0;
+    }
+    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas, gas } = txParams;
+    if (gasPrice === void 0 && maxFeePerGas === void 0 && maxPriorityFeePerGas === void 0 && gas === void 0) {
+      return void 0;
+    }
+    const dappSuggestedGasFees = {};
+    if (gasPrice !== void 0) {
+      dappSuggestedGasFees.gasPrice = gasPrice;
+    } else if (maxFeePerGas !== void 0 || maxPriorityFeePerGas !== void 0) {
+      dappSuggestedGasFees.maxFeePerGas = maxFeePerGas;
+      dappSuggestedGasFees.maxPriorityFeePerGas = maxPriorityFeePerGas;
+    }
+    if (gas !== void 0) {
+      dappSuggestedGasFees.gas = gas;
+    }
+    return dappSuggestedGasFees;
+  }
+  /**
+   * Validates and adds external provided transaction to state.
+   *
+   * @param transactionMeta - Nominated external transaction to be added to state.
+   * @returns The new transaction.
+   */
+  addExternalTransaction(transactionMeta) {
+    const { chainId } = transactionMeta;
+    const { transactions } = this.state;
+    const fromAddress = transactionMeta?.txParams?.from;
+    const sameFromAndNetworkTransactions = transactions.filter(
+      (transaction) => transaction.txParams.from === fromAddress && transaction.chainId === chainId
+    );
+    const confirmedTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "confirmed" /* confirmed */
+    );
+    const pendingTxs = sameFromAndNetworkTransactions.filter(
+      (transaction) => transaction.status === "submitted" /* submitted */
+    );
+    _chunk7LXE4KHVjs.validateConfirmedExternalTransaction.call(void 0, 
+      transactionMeta,
+      confirmedTxs,
+      pendingTxs
+    );
+    const newTransactionMeta = (transactionMeta.history ?? []).length === 0 && !this.isHistoryDisabled ? _chunkQP75SWIQjs.addInitialHistorySnapshot.call(void 0, transactionMeta) : transactionMeta;
+    this.update((state) => {
+      state.transactions = this.trimTransactionsForState([
+        ...state.transactions,
+        newTransactionMeta
+      ]);
+    });
+    return newTransactionMeta;
+  }
+  /**
+   * Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
+   * in the transactions have the same nonce.
+   *
+   * @param transactionId - Used to identify original transaction.
+   */
+  markNonceDuplicatesDropped(transactionId) {
+    const transactionMeta = this.getTransaction(transactionId);
+    if (!transactionMeta) {
+      return;
+    }
+    const nonce = transactionMeta.txParams?.nonce;
+    const from = transactionMeta.txParams?.from;
+    const { chainId } = transactionMeta;
+    const sameNonceTransactions = this.state.transactions.filter(
+      (transaction) => transaction.id !== transactionId && transaction.txParams.from === from && transaction.txParams.nonce === nonce && transaction.chainId === chainId && transaction.type !== "incoming" /* incoming */
+    );
+    const sameNonceTransactionIds = sameNonceTransactions.map(
+      (transaction) => transaction.id
+    );
+    if (sameNonceTransactions.length === 0) {
+      return;
+    }
+    this.update((state) => {
+      for (const transaction of state.transactions) {
+        if (sameNonceTransactionIds.includes(transaction.id)) {
+          transaction.replacedBy = transactionMeta?.hash;
+          transaction.replacedById = transactionMeta?.id;
+        }
+      }
+    });
+    for (const transaction of this.state.transactions) {
+      if (sameNonceTransactionIds.includes(transaction.id) && transaction.status !== "failed" /* failed */) {
+        this.setTransactionStatusDropped(transaction);
+      }
+    }
+  }
+  /**
+   * Method to set transaction status to dropped.
+   *
+   * @param transactionMeta - TransactionMeta of transaction to be marked as dropped.
+   */
+  setTransactionStatusDropped(transactionMeta) {
+    const updatedTransactionMeta = {
+      ...transactionMeta,
+      status: "dropped" /* dropped */
+    };
+    this.messagingSystem.publish(`${controllerName}:transactionDropped`, {
+      transactionMeta: updatedTransactionMeta
+    });
+    this.updateTransaction(
+      updatedTransactionMeta,
+      "TransactionController#setTransactionStatusDropped - Transaction dropped"
+    );
+    this.onTransactionStatusChange(updatedTransactionMeta);
+  }
+  /**
+   * Get transaction with provided actionId.
+   *
+   * @param actionId - Unique ID to prevent duplicate requests
+   * @returns the filtered transaction
+   */
+  getTransactionWithActionId(actionId) {
+    return this.state.transactions.find(
+      (transaction) => actionId && transaction.actionId === actionId
+    );
+  }
+  async waitForTransactionFinished(transactionId) {
+    return new Promise((resolve) => {
+      _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _internalEvents).once(`${transactionId}:finished`, (txMeta) => {
+        resolve(txMeta);
+      });
+    });
+  }
+  /**
+   * Updates the r, s, and v properties of a TransactionMeta object
+   * with values from a signed transaction.
+   *
+   * @param transactionMeta - The TransactionMeta object to update.
+   * @param signedTx - The encompassing type for all transaction types containing r, s, and v values.
+   */
+  async updateTransactionMetaRSV(transactionMeta, signedTx) {
+    const transactionMetaWithRsv = _lodash.cloneDeep.call(void 0, transactionMeta);
+    for (const key of ["r", "s", "v"]) {
+      const value = signedTx[key];
+      if (value === void 0 || value === null) {
+        continue;
+      }
+      transactionMetaWithRsv[key] = _utils.add0x.call(void 0, value.toString(16));
+    }
+    return transactionMetaWithRsv;
+  }
+  async getEIP1559Compatibility(networkClientId) {
+    const currentNetworkIsEIP1559Compatible = await this.getCurrentNetworkEIP1559Compatibility(networkClientId);
+    const currentAccountIsEIP1559Compatible = await this.getCurrentAccountEIP1559Compatibility();
+    return currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible;
+  }
+  async signTransaction(transactionMeta, txParams) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Signing transaction", txParams);
+    const unsignedEthTx = this.prepareUnsignedEthTx(
+      transactionMeta.chainId,
+      txParams
+    );
+    this.inProcessOfSigning.add(transactionMeta.id);
+    const signedTx = await new Promise((resolve, reject) => {
+      this.sign?.(
+        unsignedEthTx,
+        txParams.from,
+        ...this.getAdditionalSignArguments(transactionMeta)
+      ).then(resolve, reject);
+      this.signAbortCallbacks.set(
+        transactionMeta.id,
+        () => reject(new Error("Signing aborted by user"))
+      );
+    });
+    this.signAbortCallbacks.delete(transactionMeta.id);
+    if (!signedTx) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status as no signed transaction");
+      return void 0;
+    }
+    if (!this.afterSign(transactionMeta, signedTx)) {
+      this.updateTransaction(
+        transactionMeta,
+        "TransactionController#signTransaction - Update after sign"
+      );
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Skipping signed status based on hook");
+      return void 0;
+    }
+    const transactionMetaWithRsv = {
+      ...await this.updateTransactionMetaRSV(transactionMeta, signedTx),
+      status: "signed" /* signed */
+    };
+    this.updateTransaction(
+      transactionMetaWithRsv,
+      "TransactionController#approveTransaction - Transaction signed"
+    );
+    this.onTransactionStatusChange(transactionMetaWithRsv);
+    const rawTx = _util.bufferToHex.call(void 0, signedTx.serialize());
+    const transactionMetaWithRawTx = _lodash.merge.call(void 0, {}, transactionMetaWithRsv, {
+      rawTx
+    });
+    this.updateTransaction(
+      transactionMetaWithRawTx,
+      "TransactionController#approveTransaction - RawTransaction added"
+    );
+    return rawTx;
+  }
+  onTransactionStatusChange(transactionMeta) {
+    this.messagingSystem.publish(`${controllerName}:transactionStatusUpdated`, {
+      transactionMeta
+    });
+  }
+  getNonceTrackerTransactions(status, address, chainId = this.getChainId()) {
+    return _chunkZNZEJDOEjs.getAndFormatTransactionsForNonceTracker.call(void 0, 
+      chainId,
+      address,
+      status,
+      this.state.transactions
+    );
+  }
+  onConfirmedTransaction(transactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Processing confirmed transaction", transactionMeta.id);
+    this.markNonceDuplicatesDropped(transactionMeta.id);
+    this.messagingSystem.publish(
+      `${controllerName}:transactionConfirmed`,
+      transactionMeta
+    );
+    this.onTransactionStatusChange(transactionMeta);
+    this.updatePostBalance(transactionMeta);
+  }
+  async updatePostBalance(transactionMeta) {
+    try {
+      if (transactionMeta.type !== "swap" /* swap */) {
+        return;
+      }
+      const ethQuery = _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).getEthQuery({
+        networkClientId: transactionMeta.networkClientId,
+        chainId: transactionMeta.chainId
+      });
+      const { updatedTransactionMeta, approvalTransactionMeta } = await _chunk5OQ373JSjs.updatePostTransactionBalance.call(void 0, transactionMeta, {
+        ethQuery,
+        getTransaction: this.getTransaction.bind(this),
+        updateTransaction: this.updateTransaction.bind(this)
+      });
+      this.messagingSystem.publish(
+        `${controllerName}:postTransactionBalanceUpdated`,
+        {
+          transactionMeta: updatedTransactionMeta,
+          approvalTransactionMeta
+        }
+      );
+    } catch (error) {
+      _chunkS6VGOPUYjs.projectLogger.call(void 0, "Error while updating post transaction balance", error);
+    }
+  }
+  async publishTransactionForRetry(ethQuery, rawTx, transactionMeta) {
+    try {
+      const hash = await this.publishTransaction(ethQuery, rawTx);
+      return hash;
+    } catch (error) {
+      if (this.isTransactionAlreadyConfirmedError(error)) {
+        await this.pendingTransactionTracker.forceCheckTransaction(
+          transactionMeta
+        );
+        throw new Error("Previous transaction is already confirmed");
+      }
+      throw error;
+    }
+  }
+  /**
+   * Ensures that error is a nonce issue
+   *
+   * @param error - The error to check
+   * @returns Whether or not the error is a nonce issue
+   */
+  // TODO: Replace `any` with type
+  // Some networks are returning original error in the data field
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any
+  isTransactionAlreadyConfirmedError(error) {
+    return error?.message?.includes("nonce too low") || error?.data?.message?.includes("nonce too low");
+  }
+};
+_internalEvents = new WeakMap();
+_incomingTransactionOptions = new WeakMap();
+_pendingTransactionOptions = new WeakMap();
+_transactionHistoryLimit = new WeakMap();
+_isSimulationEnabled = new WeakMap();
+_multichainTrackingHelper = new WeakMap();
+_createNonceTracker = new WeakSet();
+createNonceTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  return new (0, _noncetracker.NonceTracker)({
+    // TODO: Replace `any` with type
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    provider,
+    blockTracker,
+    getPendingTransactions: _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getNonceTrackerPendingTransactions, getNonceTrackerPendingTransactions_fn).bind(
+      this,
+      chainId
+    ),
+    getConfirmedTransactions: this.getNonceTrackerTransactions.bind(
+      this,
+      "confirmed" /* confirmed */
+    )
+  });
+};
+_createIncomingTransactionHelper = new WeakSet();
+createIncomingTransactionHelper_fn = function({
+  blockTracker,
+  etherscanRemoteTransactionSource,
+  chainId
+}) {
+  const incomingTransactionHelper = new (0, _chunkDTDTOMTBjs.IncomingTransactionHelper)({
+    blockTracker,
+    getCurrentAccount: this.getSelectedAddress,
+    getLastFetchedBlockNumbers: () => this.state.lastFetchedBlockNumbers,
+    getChainId: chainId ? () => chainId : this.getChainId.bind(this),
+    isEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).isEnabled,
+    queryEntireHistory: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).queryEntireHistory,
+    remoteTransactionSource: etherscanRemoteTransactionSource,
+    transactionLimit: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _transactionHistoryLimit),
+    updateTransactions: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _incomingTransactionOptions).updateTransactions
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addIncomingTransactionHelperListeners, addIncomingTransactionHelperListeners_fn).call(this, incomingTransactionHelper);
+  return incomingTransactionHelper;
+};
+_createPendingTransactionTracker = new WeakSet();
+createPendingTransactionTracker_fn = function({
+  provider,
+  blockTracker,
+  chainId
+}) {
+  const ethQuery = new (0, _ethquery2.default)(provider);
+  const getChainId = chainId ? () => chainId : this.getChainId.bind(this);
+  const pendingTransactionTracker = new (0, _chunk5XBULBP2js.PendingTransactionTracker)({
+    approveTransaction: async (transactionId) => {
+      await this.approveTransaction(transactionId);
+    },
+    blockTracker,
+    getChainId,
+    getEthQuery: () => ethQuery,
+    getTransactions: () => this.state.transactions,
+    isResubmitEnabled: _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _pendingTransactionOptions).isResubmitEnabled,
+    getGlobalLock: () => _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).acquireNonceLockForChainIdKey({
+      chainId: getChainId()
+    }),
+    publishTransaction: this.publishTransaction.bind(this),
+    hooks: {
+      beforeCheckPendingTransaction: this.beforeCheckPendingTransaction.bind(this),
+      beforePublish: this.beforePublish.bind(this)
+    }
+  });
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _addPendingTransactionTrackerListeners, addPendingTransactionTrackerListeners_fn).call(this, pendingTransactionTracker);
+  return pendingTransactionTracker;
+};
+_checkForPendingTransactionAndStartPolling = new WeakMap();
+_stopAllTracking = new WeakSet();
+stopAllTracking_fn = function() {
+  this.pendingTransactionTracker.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removePendingTransactionTrackerListeners, removePendingTransactionTrackerListeners_fn).call(this, this.pendingTransactionTracker);
+  this.incomingTransactionHelper.stop();
+  _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _removeIncomingTransactionHelperListeners, removeIncomingTransactionHelperListeners_fn).call(this, this.incomingTransactionHelper);
+  _chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _multichainTrackingHelper).stopAllTracking();
+};
+_removeIncomingTransactionHelperListeners = new WeakSet();
+removeIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.removeAllListeners("transactions");
+  incomingTransactionHelper.hub.removeAllListeners(
+    "updatedLastFetchedBlockNumbers"
+  );
+};
+_addIncomingTransactionHelperListeners = new WeakSet();
+addIncomingTransactionHelperListeners_fn = function(incomingTransactionHelper) {
+  incomingTransactionHelper.hub.on(
+    "transactions",
+    this.onIncomingTransactions.bind(this)
+  );
+  incomingTransactionHelper.hub.on(
+    "updatedLastFetchedBlockNumbers",
+    this.onUpdatedLastFetchedBlockNumbers.bind(this)
+  );
+};
+_removePendingTransactionTrackerListeners = new WeakSet();
+removePendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.removeAllListeners("transaction-confirmed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-dropped");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-failed");
+  pendingTransactionTracker.hub.removeAllListeners("transaction-updated");
+};
+_addPendingTransactionTrackerListeners = new WeakSet();
+addPendingTransactionTrackerListeners_fn = function(pendingTransactionTracker) {
+  pendingTransactionTracker.hub.on(
+    "transaction-confirmed",
+    this.onConfirmedTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-dropped",
+    this.setTransactionStatusDropped.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-failed",
+    this.failTransaction.bind(this)
+  );
+  pendingTransactionTracker.hub.on(
+    "transaction-updated",
+    this.updateTransaction.bind(this)
+  );
+};
+_getNonceTrackerPendingTransactions = new WeakSet();
+getNonceTrackerPendingTransactions_fn = function(chainId, address) {
+  const standardPendingTransactions = this.getNonceTrackerTransactions(
+    "submitted" /* submitted */,
+    address,
+    chainId
+  );
+  const externalPendingTransactions = this.getExternalPendingTransactions(
+    address,
+    chainId
+  );
+  return [...standardPendingTransactions, ...externalPendingTransactions];
+};
+_getGasFeeFlows = new WeakSet();
+getGasFeeFlows_fn = function() {
+  return [new (0, _chunkUCY5PFZIjs.LineaGasFeeFlow)(), new (0, _chunk2AYEGKANjs.DefaultGasFeeFlow)()];
+};
+_getLayer1GasFeeFlows = new WeakSet();
+getLayer1GasFeeFlows_fn = function() {
+  return [];
+};
+_updateTransactionInternal = new WeakSet();
+updateTransactionInternal_fn = function(transactionMeta, { note, skipHistory }) {
+  const normalizedTransaction = {
+    ...transactionMeta,
+    txParams: _chunkUGFBA4GVjs.normalizeTransactionParams.call(void 0, transactionMeta.txParams)
+  };
+  _chunkVH47Q6TSjs.validateTxParams.call(void 0, normalizedTransaction.txParams);
+  const updatedTransactionParams = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _checkIfTransactionParamsUpdated, checkIfTransactionParamsUpdated_fn).call(this, normalizedTransaction);
+  const transactionWithUpdatedHistory = skipHistory === true ? normalizedTransaction : _chunkQP75SWIQjs.updateTransactionHistory.call(void 0, 
+    normalizedTransaction,
+    note ?? "Transaction updated"
+  );
+  this.update((state) => {
+    const index = state.transactions.findIndex(
+      ({ id }) => transactionMeta.id === id
+    );
+    state.transactions[index] = transactionWithUpdatedHistory;
+  });
+  if (updatedTransactionParams.length > 0) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _onTransactionParamsUpdated, onTransactionParamsUpdated_fn).call(this, normalizedTransaction, updatedTransactionParams);
+  }
+};
+_checkIfTransactionParamsUpdated = new WeakSet();
+checkIfTransactionParamsUpdated_fn = function(newTransactionMeta) {
+  const { id: transactionId, txParams: newParams } = newTransactionMeta;
+  const originalParams = this.getTransaction(transactionId)?.txParams;
+  if (!originalParams || _lodash.isEqual.call(void 0, originalParams, newParams)) {
+    return [];
+  }
+  const params = Object.keys(newParams);
+  const updatedProperties = params.filter(
+    (param) => newParams[param] !== originalParams[param]
+  );
+  _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+    "Transaction parameters have been updated",
+    transactionId,
+    updatedProperties,
+    originalParams,
+    newParams
+  );
+  return updatedProperties;
+};
+_onTransactionParamsUpdated = new WeakSet();
+onTransactionParamsUpdated_fn = function(transactionMeta, updatedParams) {
+  if (["to", "value", "data"].some(
+    (param) => updatedParams.includes(param)
+  )) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updating simulation data due to transaction parameter update");
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateSimulationData, updateSimulationData_fn).call(this, transactionMeta);
+  }
+};
+_updateSimulationData = new WeakSet();
+updateSimulationData_fn = async function(transactionMeta) {
+  const { id, chainId, txParams } = transactionMeta;
+  const { from, to, value, data } = txParams;
+  let simulationData = {
+    error: {
+      code: "disabled" /* Disabled */,
+      message: "Simulation disabled"
+    },
+    tokenBalanceChanges: []
+  };
+  if (_chunkZ4BLTVTBjs.__privateGet.call(void 0, this, _isSimulationEnabled).call(this)) {
+    _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _updateTransactionInternal, updateTransactionInternal_fn).call(this, { ...transactionMeta, simulationData: void 0 }, { skipHistory: true });
+    simulationData = await _chunkV5X6MZHNjs.getSimulationData.call(void 0, {
+      chainId,
+      from,
+      to,
+      value,
+      data
+    });
+  }
+  const finalTransactionMeta = this.getTransaction(id);
+  if (!finalTransactionMeta) {
+    _chunkS6VGOPUYjs.projectLogger.call(void 0, 
+      "Cannot update simulation data as transaction not found",
+      id,
+      simulationData
+    );
+    return;
+  }
+  this.updateTransaction(
+    { ...finalTransactionMeta, simulationData },
+    "TransactionController#updateSimulationData - Update simulation data"
+  );
+  _chunkS6VGOPUYjs.projectLogger.call(void 0, "Updated simulation data", id, simulationData);
+};
+
+
+
+
+
+
+
+exports.HARDFORK = HARDFORK; exports.CANCEL_RATE = CANCEL_RATE; exports.SPEED_UP_RATE = SPEED_UP_RATE; exports.ApprovalState = ApprovalState; exports.TransactionController = TransactionController;
+//# sourceMappingURL=chunk-IXIBW7YO.js.map
\ No newline at end of file
diff --git a/dist/chunk-KT6UAKBB.js b/dist/chunk-KT6UAKBB.js
new file mode 100644
index 0000000000000000000000000000000000000000..24ddd9d6cfbf6f78e48db60ab68fc00751403915
--- /dev/null
+++ b/dist/chunk-KT6UAKBB.js
@@ -0,0 +1,61 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+
+var _chunkHMOSP33Fjs = require('./chunk-HMOSP33F.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/simulation-api.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "simulation-api");
+var RPC_METHOD = "infura_simulateTransactions";
+var BASE_URL = "https://tx-sentinel-{0}.api.cx.metamask.io/";
+var ENDPOINT_NETWORKS = "networks";
+var requestIdCounter = 0;
+async function simulateTransactions(chainId, request) {
+  const url = await getSimulationUrl(chainId);
+  log("Sending request", url, request);
+  const requestId = requestIdCounter;
+  requestIdCounter += 1;
+  const response = await fetch(url, {
+    method: "POST",
+    body: JSON.stringify({
+      id: String(requestId),
+      jsonrpc: "2.0",
+      method: RPC_METHOD,
+      params: [request]
+    })
+  });
+  const responseJson = await response.json();
+  log("Received response", responseJson);
+  if (responseJson.error) {
+    const { code, message } = responseJson.error;
+    throw new (0, _chunkHMOSP33Fjs.SimulationError)(message, code);
+  }
+  return responseJson?.result;
+}
+async function getSimulationUrl(chainId) {
+  const networkData = await getNetworkData();
+  const chainIdDecimal = _controllerutils.convertHexToDecimal.call(void 0, chainId);
+  const network = networkData[chainIdDecimal];
+  if (!network?.confirmations) {
+    log("Chain is not supported", chainId);
+    throw new (0, _chunkHMOSP33Fjs.SimulationChainNotSupportedError)(chainId);
+  }
+  return getUrl(network.network);
+}
+async function getNetworkData() {
+  const url = `${getUrl("ethereum-mainnet")}${ENDPOINT_NETWORKS}`;
+  const response = await fetch(url);
+  return response.json();
+}
+function getUrl(subdomain) {
+  return BASE_URL.replace("{0}", subdomain);
+}
+
+
+
+exports.simulateTransactions = simulateTransactions;
+//# sourceMappingURL=chunk-KT6UAKBB.js.map
\ No newline at end of file
diff --git a/dist/chunk-L4S5SEV3.js b/dist/chunk-L4S5SEV3.js
new file mode 100644
index 0000000000000000000000000000000000000000..0b8995f5794675141c480bca0c555a6febffc494
--- /dev/null
+++ b/dist/chunk-L4S5SEV3.js
@@ -0,0 +1,62 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkHBNQEJEMjs = require('./chunk-HBNQEJEM.js');
+
+// src/utils/gas-flow.ts
+var _controllerutils = require('@metamask/controller-utils');
+
+
+var _gasfeecontroller = require('@metamask/gas-fee-controller');
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+  return gasFeeFlows.find(
+    (gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta)
+  );
+}
+function mergeGasFeeEstimates({
+  gasFeeControllerEstimateType,
+  gasFeeControllerEstimates,
+  transactionGasFeeEstimates
+}) {
+  if (gasFeeControllerEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+    return Object.values(_chunkHBNQEJEMjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: mergeFeeMarketEstimate(
+          gasFeeControllerEstimates[level],
+          transactionGasFeeEstimates[level]
+        )
+      }),
+      { ...gasFeeControllerEstimates }
+    );
+  }
+  if (gasFeeControllerEstimateType === _gasfeecontroller.GAS_ESTIMATE_TYPES.LEGACY) {
+    return Object.values(_chunkHBNQEJEMjs.GasFeeEstimateLevel).reduce(
+      (result, level) => ({
+        ...result,
+        [level]: getLegacyEstimate(transactionGasFeeEstimates[level])
+      }),
+      {}
+    );
+  }
+  return gasFeeControllerEstimates;
+}
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+  return {
+    ...gasFeeControllerEstimate,
+    suggestedMaxFeePerGas: _controllerutils.weiHexToGweiDec.call(void 0, 
+      transactionGasFeeEstimate.maxFeePerGas
+    ),
+    suggestedMaxPriorityFeePerGas: _controllerutils.weiHexToGweiDec.call(void 0, 
+      transactionGasFeeEstimate.maxPriorityFeePerGas
+    )
+  };
+}
+function getLegacyEstimate(transactionGasFeeEstimate) {
+  return _controllerutils.weiHexToGweiDec.call(void 0, transactionGasFeeEstimate.maxFeePerGas);
+}
+
+
+
+
+exports.getGasFeeFlow = getGasFeeFlow; exports.mergeGasFeeEstimates = mergeGasFeeEstimates;
+//# sourceMappingURL=chunk-L4S5SEV3.js.map
\ No newline at end of file
diff --git a/dist/chunk-UCY5PFZI.js b/dist/chunk-UCY5PFZI.js
new file mode 100644
index 0000000000000000000000000000000000000000..5d79b6d5ffd64fef6123c8451a2edc243e5d8ee9
--- /dev/null
+++ b/dist/chunk-UCY5PFZI.js
@@ -0,0 +1,121 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunk2AYEGKANjs = require('./chunk-2AYEGKAN.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+
+var _chunkHBNQEJEMjs = require('./chunk-HBNQEJEM.js');
+
+
+
+var _chunkZ4BLTVTBjs = require('./chunk-Z4BLTVTB.js');
+
+// src/gas-flows/LineaGasFeeFlow.ts
+var _controllerutils = require('@metamask/controller-utils');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "linea-gas-fee-flow");
+var LINEA_CHAIN_IDS = [
+  _controllerutils.ChainId["linea-mainnet"],
+  _controllerutils.ChainId["linea-goerli"],
+  _controllerutils.ChainId["linea-sepolia"]
+];
+var BASE_FEE_MULTIPLIERS = {
+  low: 1,
+  medium: 1.35,
+  high: 1.7
+};
+var PRIORITY_FEE_MULTIPLIERS = {
+  low: 1,
+  medium: 1.05,
+  high: 1.1
+};
+var _getLineaGasFees, getLineaGasFees_fn, _getLineaResponse, getLineaResponse_fn, _getValuesFromMultipliers, getValuesFromMultipliers_fn, _getMaxFees, getMaxFees_fn, _feesToString, feesToString_fn;
+var LineaGasFeeFlow = class {
+  constructor() {
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLineaGasFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getLineaResponse);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getValuesFromMultipliers);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _getMaxFees);
+    _chunkZ4BLTVTBjs.__privateAdd.call(void 0, this, _feesToString);
+  }
+  matchesTransaction(transactionMeta) {
+    return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+  }
+  async getGasFees(request) {
+    try {
+      return await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLineaGasFees, getLineaGasFees_fn).call(this, request);
+    } catch (error) {
+      log("Using default flow as fallback due to error", error);
+      return new (0, _chunk2AYEGKANjs.DefaultGasFeeFlow)().getGasFees(request);
+    }
+  }
+};
+_getLineaGasFees = new WeakSet();
+getLineaGasFees_fn = async function(request) {
+  const { ethQuery, transactionMeta } = request;
+  const lineaResponse = await _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getLineaResponse, getLineaResponse_fn).call(this, transactionMeta, ethQuery);
+  log("Received Linea response", lineaResponse);
+  const baseFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getValuesFromMultipliers, getValuesFromMultipliers_fn).call(this, lineaResponse.baseFeePerGas, BASE_FEE_MULTIPLIERS);
+  log("Generated base fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, baseFees));
+  const priorityFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getValuesFromMultipliers, getValuesFromMultipliers_fn).call(this, lineaResponse.priorityFeePerGas, PRIORITY_FEE_MULTIPLIERS);
+  log("Generated priority fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, priorityFees));
+  const maxFees = _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _getMaxFees, getMaxFees_fn).call(this, baseFees, priorityFees);
+  log("Generated max fees", _chunkZ4BLTVTBjs.__privateMethod.call(void 0, this, _feesToString, feesToString_fn).call(this, maxFees));
+  const estimates = Object.values(_chunkHBNQEJEMjs.GasFeeEstimateLevel).reduce(
+    (result, level) => ({
+      ...result,
+      [level]: {
+        maxFeePerGas: _controllerutils.toHex.call(void 0, maxFees[level]),
+        maxPriorityFeePerGas: _controllerutils.toHex.call(void 0, priorityFees[level])
+      }
+    }),
+    {}
+  );
+  return { estimates };
+};
+_getLineaResponse = new WeakSet();
+getLineaResponse_fn = function(transactionMeta, ethQuery) {
+  return _controllerutils.query.call(void 0, ethQuery, "linea_estimateGas", [
+    {
+      from: transactionMeta.txParams.from,
+      to: transactionMeta.txParams.to,
+      value: transactionMeta.txParams.value,
+      input: transactionMeta.txParams.data,
+      // Required in request but no impact on response.
+      gasPrice: "0x100000000"
+    }
+  ]);
+};
+_getValuesFromMultipliers = new WeakSet();
+getValuesFromMultipliers_fn = function(value, multipliers) {
+  const base = _controllerutils.hexToBN.call(void 0, value);
+  const low = base.muln(multipliers.low);
+  const medium = base.muln(multipliers.medium);
+  const high = base.muln(multipliers.high);
+  return {
+    low,
+    medium,
+    high
+  };
+};
+_getMaxFees = new WeakSet();
+getMaxFees_fn = function(baseFees, priorityFees) {
+  return {
+    low: baseFees.low.add(priorityFees.low),
+    medium: baseFees.medium.add(priorityFees.medium),
+    high: baseFees.high.add(priorityFees.high)
+  };
+};
+_feesToString = new WeakSet();
+feesToString_fn = function(fees) {
+  return Object.values(_chunkHBNQEJEMjs.GasFeeEstimateLevel).map(
+    (level) => fees[level].toString(10)
+  );
+};
+
+
+
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+//# sourceMappingURL=chunk-UCY5PFZI.js.map
\ No newline at end of file
diff --git a/dist/chunk-V5X6MZHN.js b/dist/chunk-V5X6MZHN.js
new file mode 100644
index 0000000000000000000000000000000000000000..5323886bb457c1d1aa097ed65c2fc784f7818501
--- /dev/null
+++ b/dist/chunk-V5X6MZHN.js
@@ -0,0 +1,273 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+var _chunkKT6UAKBBjs = require('./chunk-KT6UAKBB.js');
+
+
+
+
+var _chunkHMOSP33Fjs = require('./chunk-HMOSP33F.js');
+
+
+var _chunkS6VGOPUYjs = require('./chunk-S6VGOPUY.js');
+
+// src/utils/simulation.ts
+var _abi = require('@ethersproject/abi');
+var _controllerutils = require('@metamask/controller-utils');
+var _metamaskethabis = require('@metamask/metamask-eth-abis');
+var _utils = require('@metamask/utils');
+var log = _utils.createModuleLogger.call(void 0, _chunkS6VGOPUYjs.projectLogger, "simulation");
+var REVERTED_ERRORS = ["execution reverted", "insufficient funds for gas"];
+async function getSimulationData(request) {
+  const { chainId, from, to, value, data } = request;
+  log("Getting simulation data", request);
+  try {
+    const response = await _chunkKT6UAKBBjs.simulateTransactions.call(void 0, chainId, {
+      transactions: [
+        {
+          data,
+          from,
+          maxFeePerGas: "0x0",
+          maxPriorityFeePerGas: "0x0",
+          to,
+          value
+        }
+      ],
+      withCallTrace: true,
+      withLogs: true
+    });
+    const transactionError = response.transactions?.[0]?.error;
+    if (REVERTED_ERRORS.some((error) => transactionError?.includes(error))) {
+      throw new (0, _chunkHMOSP33Fjs.SimulationRevertedError)();
+    }
+    if (transactionError) {
+      throw new (0, _chunkHMOSP33Fjs.SimulationError)(transactionError);
+    }
+    const nativeBalanceChange = getNativeBalanceChange(request.from, response);
+    const events = getEvents(response);
+    log("Parsed events", events);
+    const tokenBalanceChanges = await getTokenBalanceChanges(request, events);
+    return {
+      nativeBalanceChange,
+      tokenBalanceChanges
+    };
+  } catch (error) {
+    log("Failed to get simulation data", error, request);
+    const rawError = error;
+    return {
+      tokenBalanceChanges: [],
+      error: {
+        code: rawError.code,
+        message: rawError.message
+      }
+    };
+  }
+}
+function getNativeBalanceChange(userAddress, response) {
+  const transactionResponse = response.transactions[0];
+  if (!transactionResponse) {
+    return void 0;
+  }
+  const { stateDiff } = transactionResponse;
+  const previousBalance = stateDiff?.pre?.[userAddress]?.balance;
+  const newBalance = stateDiff?.post?.[userAddress]?.balance;
+  if (!previousBalance || !newBalance) {
+    return void 0;
+  }
+  return getSimulationBalanceChange(previousBalance, newBalance);
+}
+function getEvents(response) {
+  const logs = extractLogs(
+    response.transactions[0]?.callTrace ?? {}
+  );
+  log("Extracted logs", logs);
+  const erc20Interface = new (0, _abi.Interface)(_metamaskethabis.abiERC20);
+  const erc721Interface = new (0, _abi.Interface)(_metamaskethabis.abiERC721);
+  const erc1155Interface = new (0, _abi.Interface)(_metamaskethabis.abiERC1155);
+  return logs.map((currentLog) => {
+    const event = parseLog(
+      currentLog,
+      erc20Interface,
+      erc721Interface,
+      erc1155Interface
+    );
+    if (!event) {
+      log("Failed to parse log", currentLog);
+      return void 0;
+    }
+    const inputs = event.abi.find((e) => e.name === event.name)?.inputs;
+    if (!inputs) {
+      log("Failed to find inputs for event", event);
+      return void 0;
+    }
+    const args = parseEventArgs(event.args, inputs);
+    return {
+      contractAddress: currentLog.address,
+      tokenStandard: event.standard,
+      name: event.name,
+      args,
+      abi: event.abi
+    };
+  }).filter((e) => e !== void 0);
+}
+function parseEventArgs(args, abiInputs) {
+  return args.reduce((result, arg, index) => {
+    const name = abiInputs[index].name.replace("_", "");
+    const value = parseEventArgValue(arg);
+    result[name] = value;
+    return result;
+  }, {});
+}
+function parseEventArgValue(value) {
+  if (Array.isArray(value)) {
+    return value.map(parseEventArgValue);
+  }
+  return (value.toHexString?.() ?? value).toLowerCase();
+}
+async function getTokenBalanceChanges(request, events) {
+  const balanceTransactionsByToken = getTokenBalanceTransactions(
+    request,
+    events
+  );
+  const balanceTransactions = [...balanceTransactionsByToken.values()];
+  log("Generated balance transactions", balanceTransactions);
+  if (!balanceTransactions.length) {
+    return [];
+  }
+  const response = await _chunkKT6UAKBBjs.simulateTransactions.call(void 0, request.chainId, {
+    transactions: [...balanceTransactions, request, ...balanceTransactions]
+  });
+  log("Balance simulation response", response);
+  if (response.transactions.length !== balanceTransactions.length * 2 + 1) {
+    throw new (0, _chunkHMOSP33Fjs.SimulationInvalidResponseError)();
+  }
+  return [...balanceTransactionsByToken.keys()].map((token, index) => {
+    const previousBalance = normalizeReturnValue(
+      response.transactions[index].return
+    );
+    const newBalance = normalizeReturnValue(
+      response.transactions[index + balanceTransactions.length + 1].return
+    );
+    const balanceChange = getSimulationBalanceChange(
+      previousBalance,
+      newBalance
+    );
+    if (!balanceChange) {
+      return void 0;
+    }
+    return {
+      ...token,
+      ...balanceChange
+    };
+  }).filter((change) => change !== void 0);
+}
+function getTokenBalanceTransactions(request, events) {
+  const tokenKeys = /* @__PURE__ */ new Set();
+  return events.reduce((result, event) => {
+    if (!["Transfer", "TransferSingle", "TransferBatch"].includes(event.name) || ![event.args.from, event.args.to].includes(request.from)) {
+      log("Ignoring event", event);
+      return result;
+    }
+    let tokenIds = [void 0];
+    if (event.tokenStandard === "erc721" /* erc721 */) {
+      tokenIds = [event.args.tokenId];
+    }
+    if (event.tokenStandard === "erc1155" /* erc1155 */ && event.name === "TransferSingle") {
+      tokenIds = [event.args.id];
+    }
+    if (event.tokenStandard === "erc1155" /* erc1155 */ && event.name === "TransferBatch") {
+      tokenIds = event.args.ids;
+    }
+    log("Extracted token ids", tokenIds);
+    for (const tokenId of tokenIds) {
+      const simulationToken = {
+        address: event.contractAddress,
+        standard: event.tokenStandard,
+        id: tokenId
+      };
+      const tokenKey = JSON.stringify(simulationToken);
+      if (tokenKeys.has(tokenKey)) {
+        log(
+          "Ignoring additional event with same contract and token ID",
+          simulationToken
+        );
+        continue;
+      }
+      tokenKeys.add(tokenKey);
+      const parameters = [request.from];
+      if (event.tokenStandard === "erc1155" /* erc1155 */) {
+        parameters.push(tokenId);
+      }
+      result.set(simulationToken, {
+        from: request.from,
+        to: event.contractAddress,
+        data: new (0, _abi.Interface)(event.abi).encodeFunctionData(
+          "balanceOf",
+          parameters
+        )
+      });
+    }
+    return result;
+  }, /* @__PURE__ */ new Map());
+}
+function parseLog(eventLog, erc20, erc721, erc1155) {
+  const abisByStandard = [
+    {
+      abi: _metamaskethabis.abiERC20,
+      contractInterface: erc20,
+      standard: "erc20" /* erc20 */
+    },
+    {
+      abi: _metamaskethabis.abiERC721,
+      contractInterface: erc721,
+      standard: "erc721" /* erc721 */
+    },
+    {
+      abi: _metamaskethabis.abiERC1155,
+      contractInterface: erc1155,
+      standard: "erc1155" /* erc1155 */
+    }
+  ];
+  for (const { abi, contractInterface, standard } of abisByStandard) {
+    try {
+      return {
+        ...contractInterface.parseLog(eventLog),
+        abi,
+        standard
+      };
+    } catch (e) {
+      continue;
+    }
+  }
+  return void 0;
+}
+function extractLogs(call) {
+  const logs = call.logs ?? [];
+  const nestedCalls = call.calls ?? [];
+  return [
+    ...logs,
+    ...nestedCalls.map((nestedCall) => extractLogs(nestedCall)).flat()
+  ];
+}
+function getSimulationBalanceChange(previousBalance, newBalance) {
+  const differenceBN = _controllerutils.hexToBN.call(void 0, newBalance).sub(_controllerutils.hexToBN.call(void 0, previousBalance));
+  const isDecrease = differenceBN.isNeg();
+  const difference = _controllerutils.toHex.call(void 0, differenceBN.abs());
+  if (differenceBN.isZero()) {
+    log("Balance change is zero");
+    return void 0;
+  }
+  return {
+    previousBalance,
+    newBalance,
+    difference,
+    isDecrease
+  };
+}
+function normalizeReturnValue(value) {
+  return _controllerutils.toHex.call(void 0, _controllerutils.hexToBN.call(void 0, value));
+}
+
+
+
+exports.getSimulationData = getSimulationData;
+//# sourceMappingURL=chunk-V5X6MZHN.js.map
\ No newline at end of file
diff --git a/dist/errors.js b/dist/errors.js
new file mode 100644
index 0000000000000000000000000000000000000000..d73e90b426ec1522c56da61c9fca6fd01dae5654
--- /dev/null
+++ b/dist/errors.js
@@ -0,0 +1,15 @@
+"use strict";Object.defineProperty(exports, "__esModule", {value: true});
+
+
+
+
+var _chunkHMOSP33Fjs = require('./chunk-HMOSP33F.js');
+require('./chunk-HBNQEJEM.js');
+require('./chunk-Z4BLTVTB.js');
+
+
+
+
+
+exports.SimulationChainNotSupportedError = _chunkHMOSP33Fjs.SimulationChainNotSupportedError; exports.SimulationError = _chunkHMOSP33Fjs.SimulationError; exports.SimulationInvalidResponseError = _chunkHMOSP33Fjs.SimulationInvalidResponseError; exports.SimulationRevertedError = _chunkHMOSP33Fjs.SimulationRevertedError;
+//# sourceMappingURL=errors.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
index 58706397823d60336d9458796f6cfbbe4ed5b6da..4a441e3b219896d354e771d646e9b7d6d5884c43 100644
--- a/dist/gas-flows/DefaultGasFeeFlow.js
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -1,15 +1,15 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkUS7NQPYEjs = require('../chunk-US7NQPYE.js');
-require('../chunk-SSYRMQ63.js');
+var _chunk2AYEGKANjs = require('../chunk-2AYEGKAN.js');
+require('../chunk-2JERLB6M.js');
 require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-GQYELPS3.js');
+require('../chunk-L4S5SEV3.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.DefaultGasFeeFlow = _chunkUS7NQPYEjs.DefaultGasFeeFlow;
+exports.DefaultGasFeeFlow = _chunk2AYEGKANjs.DefaultGasFeeFlow;
 //# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
index 04ca19fdf8457ec6e4068bf5c699c72235db7d54..d396e09b3ee7d4ed05a4b08ec57866fc885595a0 100644
--- a/dist/gas-flows/LineaGasFeeFlow.js
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -1,16 +1,16 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkCWJBSWH3js = require('../chunk-CWJBSWH3.js');
-require('../chunk-US7NQPYE.js');
-require('../chunk-SSYRMQ63.js');
+var _chunkUCY5PFZIjs = require('../chunk-UCY5PFZI.js');
+require('../chunk-2AYEGKAN.js');
+require('../chunk-2JERLB6M.js');
 require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-GQYELPS3.js');
+require('../chunk-L4S5SEV3.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.LineaGasFeeFlow = _chunkCWJBSWH3js.LineaGasFeeFlow;
+exports.LineaGasFeeFlow = _chunkUCY5PFZIjs.LineaGasFeeFlow;
 //# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/EtherscanRemoteTransactionSource.js b/dist/helpers/EtherscanRemoteTransactionSource.js
index 713ef817754a9d6f3c76026afc9823ccf7572265..2334ab0c566b46be2f86db55fefc8122c8d08eac 100644
--- a/dist/helpers/EtherscanRemoteTransactionSource.js
+++ b/dist/helpers/EtherscanRemoteTransactionSource.js
@@ -4,7 +4,7 @@ var _chunkF3CMU2DMjs = require('../chunk-F3CMU2DM.js');
 require('../chunk-CXXGL43K.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/helpers/GasFeePoller.js b/dist/helpers/GasFeePoller.js
index a14e08754c224fe6f282f0953cd191b581b7b6ae..f1cb7a6a9d29d3d005f33e5adef3bc9da89acf67 100644
--- a/dist/helpers/GasFeePoller.js
+++ b/dist/helpers/GasFeePoller.js
@@ -1,12 +1,12 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunk7YLATOE4js = require('../chunk-7YLATOE4.js');
+var _chunk5ZAGN3YFjs = require('../chunk-5ZAGN3YF.js');
+require('../chunk-L4S5SEV3.js');
 require('../chunk-R7NJVDWN.js');
-require('../chunk-GQYELPS3.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.GasFeePoller = _chunk7YLATOE4js.GasFeePoller;
+exports.GasFeePoller = _chunk5ZAGN3YFjs.GasFeePoller;
 //# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/dist/helpers/MultichainTrackingHelper.js b/dist/helpers/MultichainTrackingHelper.js
index 7d94c2f166909b5f6a250b3d99e9e7bc080bfca0..1f01f8ab587b0d40183d8dd47e18b04de5881260 100644
--- a/dist/helpers/MultichainTrackingHelper.js
+++ b/dist/helpers/MultichainTrackingHelper.js
@@ -5,7 +5,7 @@ require('../chunk-F3CMU2DM.js');
 require('../chunk-CXXGL43K.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/helpers/PendingTransactionTracker.js b/dist/helpers/PendingTransactionTracker.js
index 977269f8552cbce0e2ae2bb9bc33a910fea9979c..ee0c5b7ff8c81d1cf2bd501fc784b78802ea9b2a 100644
--- a/dist/helpers/PendingTransactionTracker.js
+++ b/dist/helpers/PendingTransactionTracker.js
@@ -2,7 +2,7 @@
 
 var _chunk5XBULBP2js = require('../chunk-5XBULBP2.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/index.js b/dist/index.js
index 8752fec7ed114585451db0212a4db90d2208d8fa..af35087d2d213d1cb32affa29c22d1c15408e6d8 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -2,25 +2,19 @@
 
 
 
-var _chunk7QOACSQUjs = require('./chunk-7QOACSQU.js');
-require('./chunk-VH47Q6TS.js');
-require('./chunk-RQKICZYP.js');
-require('./chunk-QP75SWIQ.js');
-require('./chunk-ZNZEJDOE.js');
-require('./chunk-GC77BSQZ.js');
-require('./chunk-GE57YNGX.js');
-
-
-var _chunkSD6CWFDFjs = require('./chunk-SD6CWFDF.js');
-require('./chunk-7YLATOE4.js');
-require('./chunk-R7NJVDWN.js');
+var _chunkIXIBW7YOjs = require('./chunk-IXIBW7YO.js');
 require('./chunk-DTDTOMTB.js');
 require('./chunk-NRWEI43Q.js');
 require('./chunk-5XBULBP2.js');
-require('./chunk-7LXE4KHV.js');
-require('./chunk-CWJBSWH3.js');
-require('./chunk-US7NQPYE.js');
-require('./chunk-SSYRMQ63.js');
+
+
+var _chunkSD6CWFDFjs = require('./chunk-SD6CWFDF.js');
+require('./chunk-VH47Q6TS.js');
+require('./chunk-UCY5PFZI.js');
+require('./chunk-2AYEGKAN.js');
+require('./chunk-F3CMU2DM.js');
+require('./chunk-5ZAGN3YF.js');
+require('./chunk-2JERLB6M.js');
 require('./chunk-5OQ373JS.js');
 
 
@@ -28,11 +22,18 @@ require('./chunk-5OQ373JS.js');
 var _chunkUGFBA4GVjs = require('./chunk-UGFBA4GV.js');
 
 
-var _chunkGQYELPS3js = require('./chunk-GQYELPS3.js');
-require('./chunk-F3CMU2DM.js');
+var _chunkL4S5SEV3js = require('./chunk-L4S5SEV3.js');
+require('./chunk-RQKICZYP.js');
+require('./chunk-QP75SWIQ.js');
+require('./chunk-R7NJVDWN.js');
+require('./chunk-ZNZEJDOE.js');
+require('./chunk-V5X6MZHN.js');
+require('./chunk-KT6UAKBB.js');
+require('./chunk-HMOSP33F.js');
 require('./chunk-CXXGL43K.js');
 require('./chunk-ITDY6AIZ.js');
 require('./chunk-S6VGOPUY.js');
+require('./chunk-7LXE4KHV.js');
 
 
 
@@ -40,7 +41,8 @@ require('./chunk-S6VGOPUY.js');
 
 
 
-var _chunkMXQLW52Bjs = require('./chunk-MXQLW52B.js');
+
+var _chunkHBNQEJEMjs = require('./chunk-HBNQEJEM.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -56,5 +58,6 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.CANCEL_RATE = _chunk7QOACSQUjs.CANCEL_RATE; exports.HARDFORK = _chunk7QOACSQUjs.HARDFORK; exports.SimulationTokenStandard = _chunkMXQLW52Bjs.SimulationTokenStandard; exports.TransactionController = _chunk7QOACSQUjs.TransactionController; exports.TransactionEnvelopeType = _chunkMXQLW52Bjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkMXQLW52Bjs.TransactionStatus; exports.TransactionType = _chunkMXQLW52Bjs.TransactionType; exports.UserFeeLevel = _chunkMXQLW52Bjs.UserFeeLevel; exports.WalletDevice = _chunkMXQLW52Bjs.WalletDevice; exports.determineTransactionType = _chunkSD6CWFDFjs.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkGQYELPS3js.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
+
+exports.CANCEL_RATE = _chunkIXIBW7YOjs.CANCEL_RATE; exports.HARDFORK = _chunkIXIBW7YOjs.HARDFORK; exports.SimulationErrorCode = _chunkHBNQEJEMjs.SimulationErrorCode; exports.SimulationTokenStandard = _chunkHBNQEJEMjs.SimulationTokenStandard; exports.TransactionController = _chunkIXIBW7YOjs.TransactionController; exports.TransactionEnvelopeType = _chunkHBNQEJEMjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkHBNQEJEMjs.TransactionStatus; exports.TransactionType = _chunkHBNQEJEMjs.TransactionType; exports.UserFeeLevel = _chunkHBNQEJEMjs.UserFeeLevel; exports.WalletDevice = _chunkHBNQEJEMjs.WalletDevice; exports.determineTransactionType = _chunkSD6CWFDFjs.determineTransactionType; exports.isEIP1559Transaction = _chunkUGFBA4GVjs.isEIP1559Transaction; exports.mergeGasFeeEstimates = _chunkL4S5SEV3js.mergeGasFeeEstimates; exports.normalizeTransactionParams = _chunkUGFBA4GVjs.normalizeTransactionParams;
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types/errors.d.ts b/dist/types/errors.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a608a032879ffce9bd8f230de2cf84ee2cdc7378
--- /dev/null
+++ b/dist/types/errors.d.ts
@@ -0,0 +1,15 @@
+import type { Hex } from '@metamask/utils';
+export declare class SimulationError extends Error {
+    code?: string | number;
+    constructor(message?: string, code?: string | number);
+}
+export declare class SimulationChainNotSupportedError extends SimulationError {
+    constructor(chainId: Hex);
+}
+export declare class SimulationInvalidResponseError extends SimulationError {
+    constructor();
+}
+export declare class SimulationRevertedError extends SimulationError {
+    constructor();
+}
+//# sourceMappingURL=errors.d.ts.map
\ No newline at end of file
diff --git a/dist/types/index.d.ts b/dist/types/index.d.ts
index dc15f5bc02197848f07db3c3f0a16bd70693336f..3f128d33fdfb8cfa309cd6e6635c2ad788b034d4 100644
--- a/dist/types/index.d.ts
+++ b/dist/types/index.d.ts
@@ -1,7 +1,7 @@
 export type { FeeMarketEIP1559Values, GasPriceValue, MethodData, Result, TransactionControllerActions, TransactionControllerEvents, TransactionControllerGetStateAction, TransactionControllerIncomingTransactionBlockReceivedEvent, TransactionControllerPostTransactionBalanceUpdatedEvent, TransactionControllerSpeedupTransactionAddedEvent, TransactionControllerState, TransactionControllerStateChangeEvent, TransactionControllerTransactionApprovedEvent, TransactionControllerTransactionConfirmedEvent, TransactionControllerTransactionDroppedEvent, TransactionControllerTransactionFailedEvent, TransactionControllerTransactionFinishedEvent, TransactionControllerTransactionNewSwapApprovalEvent, TransactionControllerTransactionNewSwapEvent, TransactionControllerTransactionPublishingSkipped, TransactionControllerTransactionRejectedEvent, TransactionControllerTransactionStatusUpdatedEvent, TransactionControllerTransactionSubmittedEvent, TransactionControllerUnapprovedTransactionAddedEvent, TransactionControllerMessenger, } from './TransactionController';
 export { HARDFORK, CANCEL_RATE, TransactionController, } from './TransactionController';
 export type { DappSuggestedGasFees, DefaultGasEstimates, InferTransactionTypeResult, Log, RemoteTransactionSource, RemoteTransactionSourceRequest, SavedGasFees, SecurityAlertResponse, SecurityProviderRequest, SendFlowHistoryEntry, SimulationBalanceChange, SimulationData, SimulationError, SimulationToken, SimulationTokenBalanceChange, TransactionError, TransactionHistory, TransactionHistoryEntry, TransactionMeta, TransactionParams, TransactionReceipt, } from './types';
-export { SimulationTokenStandard, TransactionEnvelopeType, TransactionStatus, TransactionType, UserFeeLevel, WalletDevice, } from './types';
+export { SimulationErrorCode, SimulationTokenStandard, TransactionEnvelopeType, TransactionStatus, TransactionType, UserFeeLevel, WalletDevice, } from './types';
 export type { EtherscanTransactionMeta } from './utils/etherscan';
 export { determineTransactionType } from './utils/transaction-type';
 export { mergeGasFeeEstimates } from './utils/gas-flow';
diff --git a/dist/types/types.d.ts b/dist/types/types.d.ts
index ff02d47732dfea777c1b05d39b1ad3fdb698e8c4..b98a3e533721ecaaf2a53636a317ead251518e65 100644
--- a/dist/types/types.d.ts
+++ b/dist/types/types.d.ts
@@ -887,14 +887,18 @@ export type SimulationToken = {
 };
 /** Simulation data concerning a change to the a token balance. */
 export type SimulationTokenBalanceChange = SimulationToken & SimulationBalanceChange;
+export declare enum SimulationErrorCode {
+    ChainNotSupported = "chain-not-supported",
+    Disabled = "disabled",
+    InvalidResponse = "invalid-response",
+    Reverted = "reverted"
+}
 /** Error data for a failed simulation. */
 export type SimulationError = {
     /** Error code to identify the error type. */
-    code?: number;
+    code?: string | number;
     /** Error message to describe the error. */
     message?: string;
-    /** Whether the error is due to the transaction being reverted. */
-    isReverted: boolean;
 };
 /** Simulation data for a transaction. */
 export type SimulationData = {
diff --git a/dist/types.js b/dist/types.js
index 1fe78f9114a1e9890570fd091e9bce7c4dd480de..040b5880481065e27112e91e299baea76c6181cc 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -6,7 +6,8 @@
 
 
 
-var _chunkMXQLW52Bjs = require('./chunk-MXQLW52B.js');
+
+var _chunkHBNQEJEMjs = require('./chunk-HBNQEJEM.js');
 require('./chunk-Z4BLTVTB.js');
 
 
@@ -16,5 +17,6 @@ require('./chunk-Z4BLTVTB.js');
 
 
 
-exports.GasFeeEstimateLevel = _chunkMXQLW52Bjs.GasFeeEstimateLevel; exports.SimulationTokenStandard = _chunkMXQLW52Bjs.SimulationTokenStandard; exports.TransactionEnvelopeType = _chunkMXQLW52Bjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkMXQLW52Bjs.TransactionStatus; exports.TransactionType = _chunkMXQLW52Bjs.TransactionType; exports.UserFeeLevel = _chunkMXQLW52Bjs.UserFeeLevel; exports.WalletDevice = _chunkMXQLW52Bjs.WalletDevice;
+
+exports.GasFeeEstimateLevel = _chunkHBNQEJEMjs.GasFeeEstimateLevel; exports.SimulationErrorCode = _chunkHBNQEJEMjs.SimulationErrorCode; exports.SimulationTokenStandard = _chunkHBNQEJEMjs.SimulationTokenStandard; exports.TransactionEnvelopeType = _chunkHBNQEJEMjs.TransactionEnvelopeType; exports.TransactionStatus = _chunkHBNQEJEMjs.TransactionStatus; exports.TransactionType = _chunkHBNQEJEMjs.TransactionType; exports.UserFeeLevel = _chunkHBNQEJEMjs.UserFeeLevel; exports.WalletDevice = _chunkHBNQEJEMjs.WalletDevice;
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/external-transactions.js b/dist/utils/external-transactions.js
index 7f664139e864863857fc3604945aee481e793d71..77a1beb42eb355eabfc93630e56fb7c610c218a0 100644
--- a/dist/utils/external-transactions.js
+++ b/dist/utils/external-transactions.js
@@ -1,7 +1,7 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 var _chunk7LXE4KHVjs = require('../chunk-7LXE4KHV.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index 7d583018f62b33b89064145970db604cec555db7..83362b53ff08eb91bb49a648ae545354c2ec1379 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -1,16 +1,16 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunkSSYRMQ63js = require('../chunk-SSYRMQ63.js');
+var _chunk2JERLB6Mjs = require('../chunk-2JERLB6M.js');
 require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-GQYELPS3.js');
+require('../chunk-L4S5SEV3.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.gweiDecimalToWeiHex = _chunkSSYRMQ63js.gweiDecimalToWeiHex; exports.updateGasFees = _chunkSSYRMQ63js.updateGasFees;
+exports.gweiDecimalToWeiHex = _chunk2JERLB6Mjs.gweiDecimalToWeiHex; exports.updateGasFees = _chunk2JERLB6Mjs.updateGasFees;
 //# sourceMappingURL=gas-fees.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.js b/dist/utils/gas-flow.js
index 7b46c9f9bb968f4ca723ac95603cd230185f25a0..6fcf4d5f8de70078e171d80bd17d960e3c9cca38 100644
--- a/dist/utils/gas-flow.js
+++ b/dist/utils/gas-flow.js
@@ -1,11 +1,11 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
 
-var _chunkGQYELPS3js = require('../chunk-GQYELPS3.js');
-require('../chunk-MXQLW52B.js');
+var _chunkL4S5SEV3js = require('../chunk-L4S5SEV3.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
 
-exports.getGasFeeFlow = _chunkGQYELPS3js.getGasFeeFlow; exports.mergeGasFeeEstimates = _chunkGQYELPS3js.mergeGasFeeEstimates;
+exports.getGasFeeFlow = _chunkL4S5SEV3js.getGasFeeFlow; exports.mergeGasFeeEstimates = _chunkL4S5SEV3js.mergeGasFeeEstimates;
 //# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation-api.js b/dist/utils/simulation-api.js
index 2ff34aaad1fec91752b3b7ddd7b5fccad022c7a7..51bdd4cbc37c6dc1c1178dd78ff4352b77e253e9 100644
--- a/dist/utils/simulation-api.js
+++ b/dist/utils/simulation-api.js
@@ -1,9 +1,11 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkGE57YNGXjs = require('../chunk-GE57YNGX.js');
+var _chunkKT6UAKBBjs = require('../chunk-KT6UAKBB.js');
+require('../chunk-HMOSP33F.js');
 require('../chunk-S6VGOPUY.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.simulateTransactions = _chunkGE57YNGXjs.simulateTransactions;
+exports.simulateTransactions = _chunkKT6UAKBBjs.simulateTransactions;
 //# sourceMappingURL=simulation-api.js.map
\ No newline at end of file
diff --git a/dist/utils/simulation.js b/dist/utils/simulation.js
index aa68d924bce51079810831deaf2f2825936e437a..ac3037b0db7044fb25c8843fd3e2139db08a2d42 100644
--- a/dist/utils/simulation.js
+++ b/dist/utils/simulation.js
@@ -1,11 +1,12 @@
 "use strict";Object.defineProperty(exports, "__esModule", {value: true});
 
-var _chunkGC77BSQZjs = require('../chunk-GC77BSQZ.js');
-require('../chunk-GE57YNGX.js');
+var _chunkV5X6MZHNjs = require('../chunk-V5X6MZHN.js');
+require('../chunk-KT6UAKBB.js');
+require('../chunk-HMOSP33F.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
-exports.getSimulationData = _chunkGC77BSQZjs.getSimulationData;
+exports.getSimulationData = _chunkV5X6MZHNjs.getSimulationData;
 //# sourceMappingURL=simulation.js.map
\ No newline at end of file
diff --git a/dist/utils/swaps.js b/dist/utils/swaps.js
index d55cd9ccf4746c491a46fd76982ab2dd81a41fa0..208da1ed175c1809455d053fdbf9cd04c4b7a343 100644
--- a/dist/utils/swaps.js
+++ b/dist/utils/swaps.js
@@ -10,7 +10,7 @@ var _chunk5OQ373JSjs = require('../chunk-5OQ373JS.js');
 require('../chunk-UGFBA4GV.js');
 require('../chunk-ITDY6AIZ.js');
 require('../chunk-S6VGOPUY.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/transaction-type.js b/dist/utils/transaction-type.js
index 698be8ebabee915501ef9f9660da8597dabd56bb..434c6da29bd21fe99c42fd4b9f1c74152dc17357 100644
--- a/dist/utils/transaction-type.js
+++ b/dist/utils/transaction-type.js
@@ -2,7 +2,7 @@
 
 
 var _chunkSD6CWFDFjs = require('../chunk-SD6CWFDF.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/utils.js b/dist/utils/utils.js
index e46464baded4b650ded76d69d90bf63ee2da69fa..0c023c4ecedabb1425a39759d0f2c3cce897dc60 100644
--- a/dist/utils/utils.js
+++ b/dist/utils/utils.js
@@ -13,7 +13,7 @@
 
 
 var _chunkUGFBA4GVjs = require('../chunk-UGFBA4GV.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
diff --git a/dist/utils/validation.js b/dist/utils/validation.js
index 88878fcaf6c26edb4dc430afd491f8bcfb9d0cff..b0a97cc3eaa7d38cd21b65380d84e1533abd0506 100644
--- a/dist/utils/validation.js
+++ b/dist/utils/validation.js
@@ -3,7 +3,7 @@
 
 var _chunkVH47Q6TSjs = require('../chunk-VH47Q6TS.js');
 require('../chunk-UGFBA4GV.js');
-require('../chunk-MXQLW52B.js');
+require('../chunk-HBNQEJEM.js');
 require('../chunk-Z4BLTVTB.js');
 
 
