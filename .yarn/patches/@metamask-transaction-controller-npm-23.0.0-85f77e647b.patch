diff --git a/dist/TransactionController.d.ts b/dist/TransactionController.d.ts
index 0fc012d6fd08b788fd7ba6af645aec1106bdeea7..2433d4ce827cc90a1c6321214fdb7250356126d2 100644
--- a/dist/TransactionController.d.ts
+++ b/dist/TransactionController.d.ts
@@ -174,6 +174,7 @@ export declare class TransactionController extends BaseControllerV1<TransactionC
     private readonly nonceTracker;
     private readonly registry;
     private readonly mutex;
+    private readonly gasFeeFlows;
     private readonly getSavedGasFees;
     private readonly getNetworkState;
     private readonly getCurrentAccountEIP1559Compatibility;
diff --git a/dist/TransactionController.js b/dist/TransactionController.js
index 0422c3747a35eed684f6cf8731d150867705cafc..c536570222652460359e2aad6678e4242688d457 100644
--- a/dist/TransactionController.js
+++ b/dist/TransactionController.js
@@ -22,7 +22,7 @@ var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (
 var __importDefault = (this && this.__importDefault) || function (mod) {
     return (mod && mod.__esModule) ? mod : { "default": mod };
 };
-var _TransactionController_instances, _TransactionController_incomingTransactionOptions, _TransactionController_pendingTransactionOptions, _TransactionController_multichainTrackingHelper, _TransactionController_createNonceTracker, _TransactionController_createIncomingTransactionHelper, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_removeIncomingTransactionHelperListeners, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions;
+var _TransactionController_instances, _TransactionController_incomingTransactionOptions, _TransactionController_pendingTransactionOptions, _TransactionController_multichainTrackingHelper, _TransactionController_createNonceTracker, _TransactionController_createIncomingTransactionHelper, _TransactionController_createPendingTransactionTracker, _TransactionController_checkForPendingTransactionAndStartPolling, _TransactionController_stopAllTracking, _TransactionController_removeIncomingTransactionHelperListeners, _TransactionController_addIncomingTransactionHelperListeners, _TransactionController_removePendingTransactionTrackerListeners, _TransactionController_addPendingTransactionTrackerListeners, _TransactionController_getNonceTrackerPendingTransactions, _TransactionController_getGasFeeFlows, _TransactionController_updateTransactionInternal;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.HARDFORK = void 0;
 const common_1 = require("@ethereumjs/common");
@@ -39,7 +39,10 @@ const events_1 = require("events");
 const lodash_1 = require("lodash");
 const nonce_tracker_1 = require("nonce-tracker");
 const uuid_1 = require("uuid");
+const DefaultGasFeeFlow_1 = require("./gas-flows/DefaultGasFeeFlow");
+const LineaGasFeeFlow_1 = require("./gas-flows/LineaGasFeeFlow");
 const EtherscanRemoteTransactionSource_1 = require("./helpers/EtherscanRemoteTransactionSource");
+const GasFeePoller_1 = require("./helpers/GasFeePoller");
 const IncomingTransactionHelper_1 = require("./helpers/IncomingTransactionHelper");
 const MultichainTrackingHelper_1 = require("./helpers/MultichainTrackingHelper");
 const PendingTransactionTracker_1 = require("./helpers/PendingTransactionTracker");
@@ -172,6 +175,21 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
             provider,
             blockTracker,
         });
+        this.gasFeeFlows = __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_getGasFeeFlows).call(this);
+        const gasFeePoller = new GasFeePoller_1.GasFeePoller({
+            // Default gas fee polling is not yet supported by the clients
+            gasFeeFlows: this.gasFeeFlows.slice(0, -1),
+            getEthQuery: (chainId, networkClientId) => __classPrivateFieldGet(this, _TransactionController_multichainTrackingHelper, "f").getEthQuery({
+                networkClientId,
+                chainId,
+            }),
+            getGasFeeControllerEstimates: this.getGasFeeEstimates,
+            getTransactions: () => this.state.transactions,
+            onStateChange: (listener) => {
+                this.subscribe(listener);
+            },
+        });
+        gasFeePoller.hub.on('transaction-updated', (transactionMeta) => __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_updateTransactionInternal).call(this, transactionMeta, { skipHistory: true }));
         // when transactionsController state changes
         // check for pending transactions and start polling if there are any
         this.subscribe(__classPrivateFieldGet(this, _TransactionController_checkForPendingTransactionAndStartPolling, "f"));
@@ -595,15 +613,10 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
      * @param note - A note or update reason to include in the transaction history.
      */
     updateTransaction(transactionMeta, note) {
-        const { transactions } = this.state;
-        transactionMeta.txParams = (0, utils_1.normalizeTxParams)(transactionMeta.txParams);
-        (0, validation_1.validateTxParams)(transactionMeta.txParams);
-        if (!this.isHistoryDisabled) {
-            (0, history_1.updateTransactionHistory)(transactionMeta, note);
-        }
-        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
-        transactions[index] = transactionMeta;
-        this.update({ transactions: this.trimTransactionsForState(transactions) });
+        __classPrivateFieldGet(this, _TransactionController_instances, "m", _TransactionController_updateTransactionInternal).call(this, transactionMeta, {
+            note,
+            skipHistory: this.isHistoryDisabled,
+        });
     }
     /**
      * Update the security alert response for a transaction.
@@ -1123,8 +1136,9 @@ class TransactionController extends base_controller_1.BaseControllerV1 {
                     networkClientId,
                     chainId,
                 }),
+                gasFeeFlows: this.gasFeeFlows,
+                getGasFeeEstimates: this.getGasFeeEstimates,
                 getSavedGasFees: this.getSavedGasFees.bind(this),
-                getGasFeeEstimates: this.getGasFeeEstimates.bind(this),
                 txMeta: transactionMeta,
             });
         });
@@ -1786,5 +1800,17 @@ _TransactionController_incomingTransactionOptions = new WeakMap(), _TransactionC
     const standardPendingTransactions = this.getNonceTrackerTransactions(types_1.TransactionStatus.submitted, address, chainId);
     const externalPendingTransactions = this.getExternalPendingTransactions(address, chainId);
     return [...standardPendingTransactions, ...externalPendingTransactions];
+}, _TransactionController_getGasFeeFlows = function _TransactionController_getGasFeeFlows() {
+    return [new LineaGasFeeFlow_1.LineaGasFeeFlow(), new DefaultGasFeeFlow_1.DefaultGasFeeFlow()];
+}, _TransactionController_updateTransactionInternal = function _TransactionController_updateTransactionInternal(transactionMeta, { note, skipHistory }) {
+    const { transactions } = this.state;
+    transactionMeta.txParams = (0, utils_1.normalizeTxParams)(transactionMeta.txParams);
+    (0, validation_1.validateTxParams)(transactionMeta.txParams);
+    if (skipHistory !== true) {
+        (0, history_1.updateTransactionHistory)(transactionMeta, note !== null && note !== void 0 ? note : 'Transaction updated');
+    }
+    const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
+    transactions[index] = transactionMeta;
+    this.update({ transactions: this.trimTransactionsForState(transactions) });
 };
 //# sourceMappingURL=TransactionController.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.d.ts b/dist/gas-flows/DefaultGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..325802b3bdecba22343ebacc0c07d0ea087bce52
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.d.ts
@@ -0,0 +1,10 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+export declare class DefaultGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(_transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=DefaultGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/DefaultGasFeeFlow.js b/dist/gas-flows/DefaultGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..8e38b2711c6636e2776bd8ff4cd89a2468a45aa4
--- /dev/null
+++ b/dist/gas-flows/DefaultGasFeeFlow.js
@@ -0,0 +1,78 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _DefaultGasFeeFlow_instances, _DefaultGasFeeFlow_getEstimateLevel, _DefaultGasFeeFlow_getFeeMarketLevel, _DefaultGasFeeFlow_getLegacyLevel;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DefaultGasFeeFlow = void 0;
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_fees_1 = require("../utils/gas-fees");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'default-gas-fee-flow');
+/**
+ * The standard implementation of a gas fee flow that obtains gas fee estimates using only the GasFeeController.
+ */
+class DefaultGasFeeFlow {
+    constructor() {
+        _DefaultGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(_transactionMeta) {
+        return true;
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const { getGasFeeControllerEstimates, transactionMeta } = request;
+            const { networkClientId } = transactionMeta;
+            const { gasEstimateType, gasFeeEstimates } = yield getGasFeeControllerEstimates({ networkClientId });
+            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+                log('Using fee market estimates', gasFeeEstimates);
+            }
+            else if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+                log('Using legacy estimates', gasFeeEstimates);
+            }
+            else {
+                throw new Error(`'No gas fee estimates available`);
+            }
+            const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getEstimateLevel).call(this, {
+                    gasEstimateType,
+                    gasFeeEstimates,
+                    level,
+                }) })), {});
+            return { estimates };
+        });
+    }
+}
+exports.DefaultGasFeeFlow = DefaultGasFeeFlow;
+_DefaultGasFeeFlow_instances = new WeakSet(), _DefaultGasFeeFlow_getEstimateLevel = function _DefaultGasFeeFlow_getEstimateLevel({ gasEstimateType, gasFeeEstimates, level, }) {
+    if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getFeeMarketLevel).call(this, gasFeeEstimates, level);
+    }
+    return __classPrivateFieldGet(this, _DefaultGasFeeFlow_instances, "m", _DefaultGasFeeFlow_getLegacyLevel).call(this, gasFeeEstimates, level);
+}, _DefaultGasFeeFlow_getFeeMarketLevel = function _DefaultGasFeeFlow_getFeeMarketLevel(gasFeeEstimates, level) {
+    const maxFeePerGas = (0, gas_fees_1.gweiDecimalToWeiHex)(gasFeeEstimates[level].suggestedMaxFeePerGas);
+    const maxPriorityFeePerGas = (0, gas_fees_1.gweiDecimalToWeiHex)(gasFeeEstimates[level].suggestedMaxPriorityFeePerGas);
+    return {
+        maxFeePerGas,
+        maxPriorityFeePerGas,
+    };
+}, _DefaultGasFeeFlow_getLegacyLevel = function _DefaultGasFeeFlow_getLegacyLevel(gasFeeEstimates, level) {
+    const gasPrice = (0, gas_fees_1.gweiDecimalToWeiHex)(gasFeeEstimates[level]);
+    return {
+        maxFeePerGas: gasPrice,
+        maxPriorityFeePerGas: gasPrice,
+    };
+};
+//# sourceMappingURL=DefaultGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.d.ts b/dist/gas-flows/LineaGasFeeFlow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..69f2e71643131a073dd87eafedbea2520b989506
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.d.ts
@@ -0,0 +1,12 @@
+import type { GasFeeFlow, GasFeeFlowRequest, GasFeeFlowResponse, TransactionMeta } from '../types';
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - The GasFeeController to provide the priority fee deltas based on recent block analysis.
+ */
+export declare class LineaGasFeeFlow implements GasFeeFlow {
+    #private;
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    getGasFees(request: GasFeeFlowRequest): Promise<GasFeeFlowResponse>;
+}
+//# sourceMappingURL=LineaGasFeeFlow.d.ts.map
\ No newline at end of file
diff --git a/dist/gas-flows/LineaGasFeeFlow.js b/dist/gas-flows/LineaGasFeeFlow.js
new file mode 100644
index 0000000000000000000000000000000000000000..5d957f6da3225a76b229c98e29244e7a84c216d8
--- /dev/null
+++ b/dist/gas-flows/LineaGasFeeFlow.js
@@ -0,0 +1,134 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var _LineaGasFeeFlow_instances, _LineaGasFeeFlow_getLineaGasFees, _LineaGasFeeFlow_getLineaResponse, _LineaGasFeeFlow_getBaseFees, _LineaGasFeeFlow_getPriorityFees, _LineaGasFeeFlow_getPriorityLevelDifference, _LineaGasFeeFlow_getMaxFees, _LineaGasFeeFlow_logDifferencesToGasFeeController;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.LineaGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const utils_1 = require("@metamask/utils");
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const DefaultGasFeeFlow_1 = require("./DefaultGasFeeFlow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'linea-gas-fee-flow');
+const ONE_GWEI_IN_WEI = 1e9;
+const LINEA_CHAIN_IDS = [
+    controller_utils_1.ChainId['linea-mainnet'],
+    controller_utils_1.ChainId['linea-goerli'],
+];
+const BASE_FEE_MULTIPLIERS = {
+    low: 1,
+    medium: 1.35,
+    high: 1.7,
+};
+/**
+ * Implementation of a gas fee flow specific to Linea networks that obtains gas fee estimates using:
+ * - The `linea_estimateGas` RPC method to obtain the base fee and lowest priority fee.
+ * - The GasFeeController to provide the priority fee deltas based on recent block analysis.
+ */
+class LineaGasFeeFlow {
+    constructor() {
+        _LineaGasFeeFlow_instances.add(this);
+    }
+    matchesTransaction(transactionMeta) {
+        return LINEA_CHAIN_IDS.includes(transactionMeta.chainId);
+    }
+    getGasFees(request) {
+        return __awaiter(this, void 0, void 0, function* () {
+            try {
+                return yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaGasFees).call(this, request);
+            }
+            catch (error) {
+                log('Using default flow as fallback due to error', error);
+                return new DefaultGasFeeFlow_1.DefaultGasFeeFlow().getGasFees(request);
+            }
+        });
+    }
+}
+exports.LineaGasFeeFlow = LineaGasFeeFlow;
+_LineaGasFeeFlow_instances = new WeakSet(), _LineaGasFeeFlow_getLineaGasFees = function _LineaGasFeeFlow_getLineaGasFees(request) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { ethQuery, getGasFeeControllerEstimates, transactionMeta } = request;
+        const { networkClientId } = transactionMeta;
+        const lineaResponse = yield __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getLineaResponse).call(this, transactionMeta, ethQuery);
+        log('Received Linea response', lineaResponse);
+        const gasFeeControllerEstimates = yield getGasFeeControllerEstimates({
+            networkClientId,
+        });
+        log('Received gas fee controller estimates', gasFeeControllerEstimates);
+        if (gasFeeControllerEstimates.gasEstimateType !==
+            gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+            throw new Error('No gas fee estimates available');
+        }
+        const baseFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getBaseFees).call(this, lineaResponse);
+        const priorityFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getPriorityFees).call(this, lineaResponse, gasFeeControllerEstimates.gasFeeEstimates);
+        const maxFees = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getMaxFees).call(this, baseFees, priorityFees);
+        __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_logDifferencesToGasFeeController).call(this, maxFees, gasFeeControllerEstimates.gasFeeEstimates);
+        const estimates = Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: {
+                maxFeePerGas: (0, controller_utils_1.toHex)(maxFees[level]),
+                maxPriorityFeePerGas: (0, controller_utils_1.toHex)(priorityFees[level]),
+            } })), {});
+        return { estimates };
+    });
+}, _LineaGasFeeFlow_getLineaResponse = function _LineaGasFeeFlow_getLineaResponse(transactionMeta, ethQuery) {
+    return (0, controller_utils_1.query)(ethQuery, 'linea_estimateGas', [
+        {
+            from: transactionMeta.txParams.from,
+            to: transactionMeta.txParams.to,
+            value: transactionMeta.txParams.value,
+            input: transactionMeta.txParams.data,
+            gasPrice: '0x100000000',
+        },
+    ]);
+}, _LineaGasFeeFlow_getBaseFees = function _LineaGasFeeFlow_getBaseFees(lineaResponse) {
+    const baseFeeLow = (0, controller_utils_1.hexToBN)(lineaResponse.baseFeePerGas);
+    const baseFeeMedium = baseFeeLow.muln(BASE_FEE_MULTIPLIERS.medium);
+    const baseFeeHigh = baseFeeLow.muln(BASE_FEE_MULTIPLIERS.high);
+    return {
+        low: baseFeeLow,
+        medium: baseFeeMedium,
+        high: baseFeeHigh,
+    };
+}, _LineaGasFeeFlow_getPriorityFees = function _LineaGasFeeFlow_getPriorityFees(lineaResponse, gasFeeEstimates) {
+    const mediumPriorityIncrease = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getPriorityLevelDifference).call(this, gasFeeEstimates, types_1.GasFeeEstimateLevel.medium, types_1.GasFeeEstimateLevel.low);
+    const highPriorityIncrease = __classPrivateFieldGet(this, _LineaGasFeeFlow_instances, "m", _LineaGasFeeFlow_getPriorityLevelDifference).call(this, gasFeeEstimates, types_1.GasFeeEstimateLevel.high, types_1.GasFeeEstimateLevel.medium);
+    const priorityFeeLow = (0, controller_utils_1.hexToBN)(lineaResponse.priorityFeePerGas);
+    const priorityFeeMedium = priorityFeeLow.add(mediumPriorityIncrease);
+    const priorityFeeHigh = priorityFeeMedium.add(highPriorityIncrease);
+    return {
+        low: priorityFeeLow,
+        medium: priorityFeeMedium,
+        high: priorityFeeHigh,
+    };
+}, _LineaGasFeeFlow_getPriorityLevelDifference = function _LineaGasFeeFlow_getPriorityLevelDifference(gasFeeEstimates, firstLevel, secondLevel) {
+    return (0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates[firstLevel].suggestedMaxPriorityFeePerGas).sub((0, controller_utils_1.gweiDecToWEIBN)(gasFeeEstimates[secondLevel].suggestedMaxPriorityFeePerGas));
+}, _LineaGasFeeFlow_getMaxFees = function _LineaGasFeeFlow_getMaxFees(baseFees, priorityFees) {
+    return {
+        low: baseFees.low.add(priorityFees.low),
+        medium: baseFees.medium.add(priorityFees.medium),
+        high: baseFees.high.add(priorityFees.high),
+    };
+}, _LineaGasFeeFlow_logDifferencesToGasFeeController = function _LineaGasFeeFlow_logDifferencesToGasFeeController(maxFees, gasFeeControllerEstimates) {
+    const calculateDifference = (level) => {
+        const newMaxFeeWeiDec = maxFees[level].toNumber();
+        const newMaxFeeGweiDec = newMaxFeeWeiDec / ONE_GWEI_IN_WEI;
+        const oldMaxFeeGweiDec = parseFloat(gasFeeControllerEstimates[level].suggestedMaxFeePerGas);
+        const percentDifference = (newMaxFeeGweiDec / oldMaxFeeGweiDec - 1) * 100;
+        /* istanbul ignore next */
+        return `${percentDifference > 0 ? '+' : ''}${percentDifference.toFixed(2)}%`;
+    };
+    log('Difference to gas fee controller', calculateDifference(types_1.GasFeeEstimateLevel.low), calculateDifference(types_1.GasFeeEstimateLevel.medium), calculateDifference(types_1.GasFeeEstimateLevel.high));
+};
+//# sourceMappingURL=LineaGasFeeFlow.js.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.d.ts b/dist/helpers/GasFeePoller.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..95bb979bdfd5109e604d409e0708659deaf85840
--- /dev/null
+++ b/dist/helpers/GasFeePoller.d.ts
@@ -0,0 +1,32 @@
+/// <reference types="node" />
+import type EthQuery from '@metamask/eth-query';
+import type { GasFeeState } from '@metamask/gas-fee-controller';
+import type { Hex } from '@metamask/utils';
+import EventEmitter from 'events';
+import type { NetworkClientId } from '../../../network-controller/src';
+import type { GasFeeFlow } from '../types';
+import { type TransactionMeta } from '../types';
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+export declare class GasFeePoller {
+    #private;
+    hub: EventEmitter;
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }: {
+        gasFeeFlows: GasFeeFlow[];
+        getEthQuery: (chainId: Hex, networkClientId?: NetworkClientId) => EthQuery;
+        getGasFeeControllerEstimates: () => Promise<GasFeeState>;
+        getTransactions: () => TransactionMeta[];
+        onStateChange: (listener: () => void) => void;
+    });
+}
+//# sourceMappingURL=GasFeePoller.d.ts.map
\ No newline at end of file
diff --git a/dist/helpers/GasFeePoller.js b/dist/helpers/GasFeePoller.js
new file mode 100644
index 0000000000000000000000000000000000000000..405977b17a567b987c9b97d0698e8d455b28996a
--- /dev/null
+++ b/dist/helpers/GasFeePoller.js
@@ -0,0 +1,136 @@
+"use strict";
+var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
+    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
+    return new (P || (P = Promise))(function (resolve, reject) {
+        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
+        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
+        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
+        step((generator = generator.apply(thisArg, _arguments || [])).next());
+    });
+};
+var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
+    if (kind === "m") throw new TypeError("Private method is not writable");
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
+    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
+};
+var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
+    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
+    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
+    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
+};
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+var _GasFeePoller_instances, _GasFeePoller_gasFeeFlows, _GasFeePoller_getEthQuery, _GasFeePoller_getGasFeeControllerEstimates, _GasFeePoller_getTransactions, _GasFeePoller_timeout, _GasFeePoller_running, _GasFeePoller_start, _GasFeePoller_stop, _GasFeePoller_onTimeout, _GasFeePoller_updateUnapprovedTransactions, _GasFeePoller_updateTransactionSuggestedFees, _GasFeePoller_getUnapprovedTransactions;
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GasFeePoller = void 0;
+const utils_1 = require("@metamask/utils");
+const events_1 = __importDefault(require("events"));
+const logger_1 = require("../logger");
+const types_1 = require("../types");
+const gas_flow_1 = require("../utils/gas-flow");
+const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fee-poller');
+const INTERVAL_MILLISECONDS = 10000;
+/**
+ * Automatically polls and updates suggested gas fees on unapproved transactions.
+ */
+class GasFeePoller {
+    /**
+     * Constructs a new instance of the GasFeePoller.
+     * @param options - The options for this instance.
+     * @param options.gasFeeFlows - The gas fee flows to use to obtain suitable gas fees.
+     * @param options.getEthQuery - Callback to obtain an EthQuery instance.
+     * @param options.getGasFeeControllerEstimates - Callback to obtain the default fee estimates.
+     * @param options.getTransactions - Callback to obtain the transaction data.
+     * @param options.onStateChange - Callback to register a listener for controller state changes.
+     */
+    constructor({ gasFeeFlows, getEthQuery, getGasFeeControllerEstimates, getTransactions, onStateChange, }) {
+        _GasFeePoller_instances.add(this);
+        this.hub = new events_1.default();
+        _GasFeePoller_gasFeeFlows.set(this, void 0);
+        _GasFeePoller_getEthQuery.set(this, void 0);
+        _GasFeePoller_getGasFeeControllerEstimates.set(this, void 0);
+        _GasFeePoller_getTransactions.set(this, void 0);
+        _GasFeePoller_timeout.set(this, void 0);
+        _GasFeePoller_running.set(this, false);
+        __classPrivateFieldSet(this, _GasFeePoller_gasFeeFlows, gasFeeFlows, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getEthQuery, getEthQuery, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getGasFeeControllerEstimates, getGasFeeControllerEstimates, "f");
+        __classPrivateFieldSet(this, _GasFeePoller_getTransactions, getTransactions, "f");
+        onStateChange(() => {
+            const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+            if (unapprovedTransactions.length) {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_start).call(this);
+            }
+            else {
+                __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_stop).call(this);
+            }
+        });
+    }
+}
+exports.GasFeePoller = GasFeePoller;
+_GasFeePoller_gasFeeFlows = new WeakMap(), _GasFeePoller_getEthQuery = new WeakMap(), _GasFeePoller_getGasFeeControllerEstimates = new WeakMap(), _GasFeePoller_getTransactions = new WeakMap(), _GasFeePoller_timeout = new WeakMap(), _GasFeePoller_running = new WeakMap(), _GasFeePoller_instances = new WeakSet(), _GasFeePoller_start = function _GasFeePoller_start() {
+    if (__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    // Intentionally not awaiting since this starts the timeout chain.
+    // eslint-disable-next-line @typescript-eslint/no-floating-promises
+    __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this);
+    __classPrivateFieldSet(this, _GasFeePoller_running, true, "f");
+    log('Started polling');
+}, _GasFeePoller_stop = function _GasFeePoller_stop() {
+    if (!__classPrivateFieldGet(this, _GasFeePoller_running, "f")) {
+        return;
+    }
+    clearTimeout(__classPrivateFieldGet(this, _GasFeePoller_timeout, "f"));
+    __classPrivateFieldSet(this, _GasFeePoller_timeout, undefined, "f");
+    __classPrivateFieldSet(this, _GasFeePoller_running, false, "f");
+    log('Stopped polling');
+}, _GasFeePoller_onTimeout = function _GasFeePoller_onTimeout() {
+    return __awaiter(this, void 0, void 0, function* () {
+        yield __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateUnapprovedTransactions).call(this);
+        // eslint-disable-next-line @typescript-eslint/no-misused-promises
+        __classPrivateFieldSet(this, _GasFeePoller_timeout, setTimeout(() => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_onTimeout).call(this), INTERVAL_MILLISECONDS), "f");
+    });
+}, _GasFeePoller_updateUnapprovedTransactions = function _GasFeePoller_updateUnapprovedTransactions() {
+    return __awaiter(this, void 0, void 0, function* () {
+        const unapprovedTransactions = __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_getUnapprovedTransactions).call(this);
+        log('Found unapproved transactions', {
+            count: unapprovedTransactions.length,
+        });
+        yield Promise.all(unapprovedTransactions.map((tx) => __classPrivateFieldGet(this, _GasFeePoller_instances, "m", _GasFeePoller_updateTransactionSuggestedFees).call(this, tx)));
+    });
+}, _GasFeePoller_updateTransactionSuggestedFees = function _GasFeePoller_updateTransactionSuggestedFees(transactionMeta) {
+    return __awaiter(this, void 0, void 0, function* () {
+        const { chainId, networkClientId } = transactionMeta;
+        const ethQuery = __classPrivateFieldGet(this, _GasFeePoller_getEthQuery, "f").call(this, chainId, networkClientId);
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(transactionMeta, __classPrivateFieldGet(this, _GasFeePoller_gasFeeFlows, "f"));
+        if (!gasFeeFlow) {
+            log('Skipping update as no gas fee flow found', transactionMeta.id);
+            return;
+        }
+        log('Found gas fee flow', gasFeeFlow.constructor.name, transactionMeta.id);
+        const request = {
+            ethQuery,
+            getGasFeeControllerEstimates: __classPrivateFieldGet(this, _GasFeePoller_getGasFeeControllerEstimates, "f"),
+            transactionMeta,
+        };
+        try {
+            const response = yield gasFeeFlow.getGasFees(request);
+            transactionMeta.gasFeeEstimates = response.estimates;
+        }
+        catch (error) {
+            log('Failed to get suggested gas fees', transactionMeta.id, error);
+            return;
+        }
+        this.hub.emit('transaction-updated', transactionMeta);
+        log('Updated suggested gas fees', {
+            gasFeeEstimates: transactionMeta.gasFeeEstimates,
+            transaction: transactionMeta.id,
+        });
+    });
+}, _GasFeePoller_getUnapprovedTransactions = function _GasFeePoller_getUnapprovedTransactions() {
+    return __classPrivateFieldGet(this, _GasFeePoller_getTransactions, "f").call(this).filter((tx) => tx.status === types_1.TransactionStatus.unapproved);
+};
+//# sourceMappingURL=GasFeePoller.js.map
\ No newline at end of file
diff --git a/dist/index.d.ts b/dist/index.d.ts
index 365c05b9c144b70bd2d52b568fb377e32d427c36..b1319a340c03e201f8f19715d591988b538bc794 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -3,4 +3,5 @@ export type { EtherscanTransactionMeta } from './utils/etherscan';
 export { isEIP1559Transaction } from './utils/utils';
 export * from './types';
 export { determineTransactionType } from './utils/transaction-type';
+export { mergeGasFeeEstimates } from './utils/gas-flow';
 //# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/dist/index.js b/dist/index.js
index ab09b74aed5d901cb106652da553935a35ac1b47..b48c4bbdad703206b9d5ce3df1bc2d7d174cdf6f 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -14,11 +14,13 @@ var __exportStar = (this && this.__exportStar) || function(m, exports) {
     for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
+exports.mergeGasFeeEstimates = exports.determineTransactionType = exports.isEIP1559Transaction = void 0;
 __exportStar(require("./TransactionController"), exports);
 var utils_1 = require("./utils/utils");
 Object.defineProperty(exports, "isEIP1559Transaction", { enumerable: true, get: function () { return utils_1.isEIP1559Transaction; } });
 __exportStar(require("./types"), exports);
 var transaction_type_1 = require("./utils/transaction-type");
 Object.defineProperty(exports, "determineTransactionType", { enumerable: true, get: function () { return transaction_type_1.determineTransactionType; } });
+var gas_flow_1 = require("./utils/gas-flow");
+Object.defineProperty(exports, "mergeGasFeeEstimates", { enumerable: true, get: function () { return gas_flow_1.mergeGasFeeEstimates; } });
 //# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/dist/types.d.ts b/dist/types.d.ts
index 16294f0525f6a94f1cc30eb905104874aec56a60..2d99910fbeafba6a88e39344a2dc316bb2e61948 100644
--- a/dist/types.d.ts
+++ b/dist/types.d.ts
@@ -1,4 +1,6 @@
 import type { AccessList } from '@ethereumjs/tx';
+import type EthQuery from '@metamask/eth-query';
+import type { FetchGasFeeEstimateOptions, GasFeeState } from '@metamask/gas-fee-controller';
 import type { NetworkClientId } from '@metamask/network-controller';
 import type { Hex } from '@metamask/utils';
 import type { Operation } from 'fast-json-patch';
@@ -290,6 +292,8 @@ declare type TransactionMetaBase = {
      * The time the transaction was submitted to the network, in Unix epoch time (ms).
      */
     submittedTime?: number;
+    /** Alternate EIP-1559 gas fee estimates for multiple priority levels. */
+    gasFeeEstimates?: GasFeeEstimates;
     /**
      * The symbol of the token being swapped.
      */
@@ -804,5 +808,56 @@ export declare type SecurityAlertResponse = {
     result_type: string;
     providerRequestsCount?: Record<string, number>;
 };
+/** Gas fee estimates for a specific priority level. */
+export declare type GasFeeEstimatesForLevel = {
+    /** Maximum amount to pay per gas. */
+    maxFeePerGas: Hex;
+    /** Maximum amount per gas to give to the validator as an incentive. */
+    maxPriorityFeePerGas: Hex;
+};
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+export declare enum GasFeeEstimateLevel {
+    low = "low",
+    medium = "medium",
+    high = "high"
+}
+/** Gas fee estimates for a transaction. */
+export declare type GasFeeEstimates = {
+    /** The gas fee estimate for a low priority transaction. */
+    [GasFeeEstimateLevel.low]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a medium priority transaction. */
+    [GasFeeEstimateLevel.medium]: GasFeeEstimatesForLevel;
+    /** The gas fee estimate for a high priority transaction. */
+    [GasFeeEstimateLevel.high]: GasFeeEstimatesForLevel;
+};
+/** Request to a gas fee flow to obtain gas fee estimates. */
+export declare type GasFeeFlowRequest = {
+    /** An EthQuery instance to enable queries to the associated RPC provider. */
+    ethQuery: EthQuery;
+    /** Callback to get the GasFeeController estimates. */
+    getGasFeeControllerEstimates: (options: FetchGasFeeEstimateOptions) => Promise<GasFeeState>;
+    /** The metadata of the transaction to obtain estimates for. */
+    transactionMeta: TransactionMeta;
+};
+/** Response from a gas fee flow containing gas fee estimates. */
+export declare type GasFeeFlowResponse = {
+    /** The gas fee estimates for the transaction. */
+    estimates: GasFeeEstimates;
+};
+/** A method of obtaining gas fee estimates for a specific transaction. */
+export declare type GasFeeFlow = {
+    /**
+     * Determine if the gas fee flow supports the specified transaction.
+     * @param transactionMeta - The transaction metadata.
+     * @returns Whether the gas fee flow supports the transaction.
+     */
+    matchesTransaction(transactionMeta: TransactionMeta): boolean;
+    /**
+     * Get gas fee estimates for a specific transaction.
+     * @param request - The gas fee flow request.
+     * @returns The gas fee flow response containing the gas fee estimates.
+     */
+    getGasFees: (request: GasFeeFlowRequest) => Promise<GasFeeFlowResponse>;
+};
 export {};
 //# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/dist/types.js b/dist/types.js
index 639f911e10b4c9092ad7a77f5dcba2c3a0c2f783..0cb707952150f6db340491b03209c66234ecb8ef 100644
--- a/dist/types.js
+++ b/dist/types.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
+exports.GasFeeEstimateLevel = exports.UserFeeLevel = exports.TransactionEnvelopeType = exports.TransactionType = exports.WalletDevice = exports.TransactionStatus = void 0;
 /**
  * The status of the transaction. Each status represents the state of the transaction internally
  * in the wallet. Some of these correspond with the state of the transaction on the network, but
@@ -161,4 +161,11 @@ var UserFeeLevel;
     UserFeeLevel["DAPP_SUGGESTED"] = "dappSuggested";
     UserFeeLevel["MEDIUM"] = "medium";
 })(UserFeeLevel = exports.UserFeeLevel || (exports.UserFeeLevel = {}));
+/** Alternate priority levels for which values are provided in gas fee estimates. */
+var GasFeeEstimateLevel;
+(function (GasFeeEstimateLevel) {
+    GasFeeEstimateLevel["low"] = "low";
+    GasFeeEstimateLevel["medium"] = "medium";
+    GasFeeEstimateLevel["high"] = "high";
+})(GasFeeEstimateLevel = exports.GasFeeEstimateLevel || (exports.GasFeeEstimateLevel = {}));
 //# sourceMappingURL=types.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.d.ts b/dist/utils/gas-fees.d.ts
index 1ec1b5a8908a6d73092fb0ac6726bee6ad707ce9..29031bd9e8ecc2659cca41f850f838cd072e74ea 100644
--- a/dist/utils/gas-fees.d.ts
+++ b/dist/utils/gas-fees.d.ts
@@ -1,32 +1,26 @@
 import type EthQuery from '@metamask/eth-query';
 import type { FetchGasFeeEstimateOptions, GasFeeState } from '@metamask/gas-fee-controller';
 import type { Hex } from '@metamask/utils';
-import type { SavedGasFees, TransactionParams, TransactionMeta } from '../types';
+import type { SavedGasFees, TransactionParams, TransactionMeta, GasFeeFlow } from '../types';
 export declare type UpdateGasFeesRequest = {
     eip1559: boolean;
     ethQuery: EthQuery;
-    getSavedGasFees: (chainId: Hex) => SavedGasFees | undefined;
+    gasFeeFlows: GasFeeFlow[];
     getGasFeeEstimates: (options: FetchGasFeeEstimateOptions) => Promise<GasFeeState>;
+    getSavedGasFees: (chainId: Hex) => SavedGasFees | undefined;
     txMeta: TransactionMeta;
 };
 export declare type GetGasFeeRequest = UpdateGasFeesRequest & {
-    savedGasFees?: SavedGasFees;
     initialParams: TransactionParams;
-    suggestedGasFees: Awaited<ReturnType<typeof getSuggestedGasFees>>;
+    savedGasFees?: SavedGasFees;
+    suggestedGasFees: SuggestedGasFees;
+};
+declare type SuggestedGasFees = {
+    maxFeePerGas?: string;
+    maxPriorityFeePerGas?: string;
+    gasPrice?: string;
 };
 export declare function updateGasFees(request: UpdateGasFeesRequest): Promise<void>;
-declare function getSuggestedGasFees(request: UpdateGasFeesRequest): Promise<{
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-    gasPrice?: undefined;
-} | {
-    maxFeePerGas: `0x${string}`;
-    maxPriorityFeePerGas: `0x${string}`;
-    gasPrice?: undefined;
-} | {
-    gasPrice: string | undefined;
-    maxFeePerGas?: undefined;
-    maxPriorityFeePerGas?: undefined;
-}>;
+export declare function gweiDecimalToWeiHex(value: string): `0x${string}`;
 export {};
 //# sourceMappingURL=gas-fees.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-fees.js b/dist/utils/gas-fees.js
index 3ec6b63c7fd70ba653eec332757daed3c7868944..0fdef2cca3660defcff034308f3149faf77dc24e 100644
--- a/dist/utils/gas-fees.js
+++ b/dist/utils/gas-fees.js
@@ -10,13 +10,13 @@ var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, ge
     });
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.updateGasFees = void 0;
+exports.gweiDecimalToWeiHex = exports.updateGasFees = void 0;
 const controller_utils_1 = require("@metamask/controller-utils");
-const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
 const utils_1 = require("@metamask/utils");
 const ethereumjs_util_1 = require("ethereumjs-util");
 const logger_1 = require("../logger");
 const types_1 = require("../types");
+const gas_flow_1 = require("./gas-flow");
 const swaps_1 = require("./swaps");
 const log = (0, utils_1.createModuleLogger)(logger_1.projectLogger, 'gas-fees');
 function updateGasFees(request) {
@@ -29,8 +29,8 @@ function updateGasFees(request) {
             : request.getSavedGasFees(txMeta.chainId);
         const suggestedGasFees = yield getSuggestedGasFees(request);
         log('Suggested gas fees', suggestedGasFees);
-        const getGasFeeRequest = Object.assign(Object.assign({}, request), { savedGasFees,
-            initialParams,
+        const getGasFeeRequest = Object.assign(Object.assign({}, request), { initialParams,
+            savedGasFees,
             suggestedGasFees });
         txMeta.txParams.maxFeePerGas = getMaxFeePerGas(getGasFeeRequest);
         txMeta.txParams.maxPriorityFeePerGas =
@@ -53,6 +53,10 @@ function updateGasFees(request) {
     });
 }
 exports.updateGasFees = updateGasFees;
+function gweiDecimalToWeiHex(value) {
+    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(value));
+}
+exports.gweiDecimalToWeiHex = gweiDecimalToWeiHex;
 function getMaxFeePerGas(request) {
     const { savedGasFees, eip1559, initialParams, suggestedGasFees } = request;
     if (!eip1559) {
@@ -120,6 +124,10 @@ function getGasPrice(request) {
         log('Using gasPrice from request', initialParams.gasPrice);
         return initialParams.gasPrice;
     }
+    if (suggestedGasFees.maxFeePerGas) {
+        log('Using suggested maxFeePerGas', suggestedGasFees.maxFeePerGas);
+        return suggestedGasFees.maxFeePerGas;
+    }
     if (suggestedGasFees.gasPrice) {
         log('Using suggested gasPrice', suggestedGasFees.gasPrice);
         return suggestedGasFees.gasPrice;
@@ -165,40 +173,21 @@ function updateDefaultGasEstimates(txMeta) {
 }
 function getSuggestedGasFees(request) {
     return __awaiter(this, void 0, void 0, function* () {
-        const { eip1559, ethQuery, getGasFeeEstimates, txMeta } = request;
+        const { eip1559, ethQuery, gasFeeFlows, getGasFeeEstimates, txMeta } = request;
         if ((!eip1559 && txMeta.txParams.gasPrice) ||
             (eip1559 &&
                 txMeta.txParams.maxFeePerGas &&
                 txMeta.txParams.maxPriorityFeePerGas)) {
             return {};
         }
+        const gasFeeFlow = (0, gas_flow_1.getGasFeeFlow)(txMeta, gasFeeFlows);
         try {
-            const { gasFeeEstimates, gasEstimateType } = yield getGasFeeEstimates({
-                networkClientId: txMeta.networkClientId,
+            const response = yield gasFeeFlow.getGasFees({
+                ethQuery,
+                getGasFeeControllerEstimates: getGasFeeEstimates,
+                transactionMeta: txMeta,
             });
-            if (eip1559 && gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
-                const { medium: { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = {}, } = gasFeeEstimates;
-                if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {
-                    return {
-                        maxFeePerGas: gweiDecimalToWeiHex(suggestedMaxFeePerGas),
-                        maxPriorityFeePerGas: gweiDecimalToWeiHex(suggestedMaxPriorityFeePerGas),
-                    };
-                }
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
-                // The LEGACY type includes low, medium and high estimates of
-                // gas price values.
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.medium),
-                };
-            }
-            if (gasEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
-                // The ETH_GASPRICE type just includes a single gas price property,
-                // which we can assume was retrieved from eth_gasPrice
-                return {
-                    gasPrice: gweiDecimalToWeiHex(gasFeeEstimates.gasPrice),
-                };
-            }
+            return response.estimates.medium;
         }
         catch (error) {
             log('Failed to get suggested gas fees', error);
@@ -210,7 +199,4 @@ function getSuggestedGasFees(request) {
         return { gasPrice };
     });
 }
-function gweiDecimalToWeiHex(value) {
-    return (0, controller_utils_1.toHex)((0, controller_utils_1.gweiDecToWEIBN)(value));
-}
 //# sourceMappingURL=gas-fees.js.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.d.ts b/dist/utils/gas-flow.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..31b8760327437dde4b9d454ec9f88504dba456e0
--- /dev/null
+++ b/dist/utils/gas-flow.d.ts
@@ -0,0 +1,32 @@
+import type { GasFeeEstimates, LegacyGasPriceEstimate } from '@metamask/gas-fee-controller';
+import { type GasFeeState } from '@metamask/gas-fee-controller';
+import { type GasFeeEstimates as TransactionGasFeeEstimates, type GasFeeFlow, type TransactionMeta } from '../types';
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+export declare function getGasFeeFlow(transactionMeta: TransactionMeta, gasFeeFlows: GasFeeFlow[]): GasFeeFlow | undefined;
+declare type FeeMarketMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'fee-market';
+    gasFeeControllerEstimates: GasFeeEstimates;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+declare type LegacyMergeGasFeeEstimatesRequest = {
+    gasFeeControllerEstimateType: 'legacy';
+    gasFeeControllerEstimates: LegacyGasPriceEstimate;
+    transactionGasFeeEstimates: TransactionGasFeeEstimates;
+};
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+export declare function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }: FeeMarketMergeGasFeeEstimatesRequest | LegacyMergeGasFeeEstimatesRequest): GasFeeState['gasFeeEstimates'];
+export {};
+//# sourceMappingURL=gas-flow.d.ts.map
\ No newline at end of file
diff --git a/dist/utils/gas-flow.js b/dist/utils/gas-flow.js
new file mode 100644
index 0000000000000000000000000000000000000000..1657d027cae24ef7d1b314a39c755d56fd86bc22
--- /dev/null
+++ b/dist/utils/gas-flow.js
@@ -0,0 +1,53 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.mergeGasFeeEstimates = exports.getGasFeeFlow = void 0;
+const controller_utils_1 = require("@metamask/controller-utils");
+const gas_fee_controller_1 = require("@metamask/gas-fee-controller");
+const types_1 = require("../types");
+/**
+ * Returns the first gas fee flow that matches the transaction.
+ *
+ * @param transactionMeta - The transaction metadata to find a gas fee flow for.
+ * @param gasFeeFlows - The gas fee flows to search.
+ * @returns The first gas fee flow that matches the transaction, or undefined if none match.
+ */
+function getGasFeeFlow(transactionMeta, gasFeeFlows) {
+    return gasFeeFlows.find((gasFeeFlow) => gasFeeFlow.matchesTransaction(transactionMeta));
+}
+exports.getGasFeeFlow = getGasFeeFlow;
+/**
+ * Merge the gas fee estimates from the gas fee controller with the gas fee estimates from a transaction.
+ * @param request - Data required to merge gas fee estimates.
+ * @param request.gasFeeControllerEstimateType - Gas fee estimate type from the gas fee controller.
+ * @param request.gasFeeControllerEstimates - Gas fee estimates from the GasFeeController.
+ * @param request.transactionGasFeeEstimates - Gas fee estimates from the transaction.
+ * @returns The merged gas fee estimates.
+ */
+function mergeGasFeeEstimates({ gasFeeControllerEstimateType, gasFeeControllerEstimates, transactionGasFeeEstimates, }) {
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.FEE_MARKET) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: mergeFeeMarketEstimate(gasFeeControllerEstimates[level], transactionGasFeeEstimates[level]) })), Object.assign({}, gasFeeControllerEstimates));
+    }
+    if (gasFeeControllerEstimateType === gas_fee_controller_1.GAS_ESTIMATE_TYPES.LEGACY) {
+        return Object.values(types_1.GasFeeEstimateLevel).reduce((result, level) => (Object.assign(Object.assign({}, result), { [level]: getLegacyEstimate(transactionGasFeeEstimates[level]) })), {});
+    }
+    return gasFeeControllerEstimates;
+}
+exports.mergeGasFeeEstimates = mergeGasFeeEstimates;
+/**
+ * Merge a specific priority level of EIP-1559 gas fee estimates.
+ * @param gasFeeControllerEstimate - The gas fee estimate from the gas fee controller.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The merged gas fee estimate.
+ */
+function mergeFeeMarketEstimate(gasFeeControllerEstimate, transactionGasFeeEstimate) {
+    return Object.assign(Object.assign({}, gasFeeControllerEstimate), { suggestedMaxFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas), suggestedMaxPriorityFeePerGas: (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxPriorityFeePerGas) });
+}
+/**
+ * Generate a specific priority level for a legacy gas fee estimate.
+ * @param transactionGasFeeEstimate - The gas fee estimate from the transaction.
+ * @returns The legacy gas fee estimate.
+ */
+function getLegacyEstimate(transactionGasFeeEstimate) {
+    return (0, controller_utils_1.weiHexToGweiDec)(transactionGasFeeEstimate.maxFeePerGas);
+}
+//# sourceMappingURL=gas-flow.js.map
\ No newline at end of file
