{"version":3,"file":"etherscan.js","sourceRoot":"","sources":["../../src/providers/etherscan.ts"],"names":[],"mappings":"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","sourcesContent":["import { Mutex } from 'async-mutex';\n\nimport { ETHERSCAN_SUPPORTED_NETWORKS } from '../constants';\nimport { createModuleLogger, projectLogger } from '../logger';\nimport type {\n  NameProvider,\n  NameProviderMetadata,\n  NameProviderRequest,\n  NameProviderResult,\n} from '../types';\nimport { NameType } from '../types';\nimport { handleFetch } from '../util';\n\nconst ID = 'etherscan';\nconst LABEL = 'Etherscan (Verified Contract Name)';\nconst RATE_LIMIT_INTERVAL = 5; // 5 seconds\n\nconst log = createModuleLogger(projectLogger, 'etherscan');\n\ntype EtherscanGetSourceCodeResponse = {\n  status: '1' | '0';\n  message: string;\n  result: [\n    {\n      SourceCode: string;\n      ABI: string;\n      ContractName: string;\n      CompilerVersion: string;\n      OptimizationUsed: string;\n      Runs: string;\n      ConstructorArguments: string;\n      Library: string;\n      LicenseType: string;\n      Proxy: string;\n      Implementation: string;\n      SwarmSource: string;\n    },\n  ];\n};\n\nexport class EtherscanNameProvider implements NameProvider {\n  #apiKey?: string;\n\n  #lastRequestTime = 0;\n\n  #mutex = new Mutex();\n\n  constructor({ apiKey }: { apiKey?: string } = {}) {\n    this.#apiKey = apiKey;\n  }\n\n  getMetadata(): NameProviderMetadata {\n    return {\n      sourceIds: { [NameType.ETHEREUM_ADDRESS]: [ID] },\n      sourceLabels: { [ID]: LABEL },\n    };\n  }\n\n  async getProposedNames(\n    request: NameProviderRequest,\n  ): Promise<NameProviderResult> {\n    const releaseLock = await this.#mutex.acquire();\n\n    try {\n      const { value, chainId } = request;\n\n      const time = Date.now();\n      const timeSinceLastRequest = time - this.#lastRequestTime;\n\n      if (timeSinceLastRequest < RATE_LIMIT_INTERVAL) {\n        log('Skipping request to avoid rate limit');\n        return this.#buildResult([], RATE_LIMIT_INTERVAL);\n      }\n\n      const url = this.#getUrl(chainId, {\n        module: 'contract',\n        action: 'getsourcecode',\n        address: value,\n        apikey: this.#apiKey,\n      });\n\n      const { responseData, error } = await this.#sendRequest(url);\n\n      if (error) {\n        log('Request failed', error);\n        throw error;\n      }\n\n      if (responseData?.message === 'NOTOK') {\n        log('Request warning', responseData.result);\n        return this.#buildResult([], RATE_LIMIT_INTERVAL);\n      }\n\n      const results = responseData?.result ?? [];\n      const proposedNames = results.map((result) => result.ContractName);\n\n      log('New proposed names', proposedNames);\n\n      return this.#buildResult(proposedNames);\n    } finally {\n      releaseLock();\n    }\n  }\n\n  async #sendRequest(url: string) {\n    try {\n      log('Sending request', url);\n\n      const responseData = (await handleFetch(\n        url,\n      )) as EtherscanGetSourceCodeResponse;\n\n      return { responseData };\n    } catch (error) {\n      return { error };\n    } finally {\n      this.#lastRequestTime = Date.now();\n    }\n  }\n\n  #buildResult(proposedNames: string[], retryDelay?: number) {\n    return {\n      results: {\n        [ID]: {\n          proposedNames,\n          retryDelay,\n        },\n      },\n    };\n  }\n\n  #getUrl(chainId: string, params: Record<string, string | undefined>): string {\n    type SupportedChainId = keyof typeof ETHERSCAN_SUPPORTED_NETWORKS;\n\n    const networkInfo =\n      ETHERSCAN_SUPPORTED_NETWORKS[chainId as SupportedChainId];\n\n    if (!networkInfo) {\n      throw new Error(`Etherscan does not support chain with ID: ${chainId}`);\n    }\n\n    let url = `https://${networkInfo.subdomain}.${networkInfo.domain}/api`;\n\n    Object.keys(params).forEach((key, index) => {\n      const value = params[key];\n\n      if (!value) {\n        return;\n      }\n\n      url += `${index === 0 ? '?' : '&'}${key}=${value}`;\n    });\n\n    return url;\n  }\n}\n"]}