/* eslint-disable guard-for-in */
/* eslint-disable camelcase */
import log from 'loglevel';
import type { UserStorage } from '../../user-storage/types/types';
import { createSHA256Hash } from '../../user-storage/encryption/encryption';
import type { OnChainRawNotification } from '../types/on-chain-notification/on-chain-notification';
import { PlatformNotificationUtils } from '../utils/utils';
import type { TRIGGER_TYPES } from '../../../../../shared/constants/platform-notifications';
import type { components } from '../types/on-chain-notification/schema';

export type NotificationTrigger = {
  id: string;
  chainId: string;
  kind: string;
  address: string;
};

export class OnChainNotificationsService {
  private TRIGGER_API = process.env.TRIGGERS_SERVICE_URL;

  private NOTIFICATION_API = process.env.NOTIFICATIONS_SERVICE_URL;

  private BATCH_ENDPOINT = `${this.TRIGGER_API}/api/v1/triggers/batch`;

  private LIST_NOTIFICATIONS_ENDPOINT = (page: number) =>
    `${this.NOTIFICATION_API}/api/v1/notifications?page=${page}&per_page=100`;

  private MARK_ALL_AS_READ_ENDPOINT = `${this.NOTIFICATION_API}/api/v1/notifications/mark-as-read`;

  /**
   * Creates on-chain triggers based on the provided notification triggers.
   * This method generates a unique token for each trigger using the trigger ID and storage key,
   * proving ownership of the trigger being updated. It then makes an API call to create these triggers.
   * Upon successful creation, it updates the userStorage to reflect the new trigger status.
   *
   * @param userStorage - The user's storage object where triggers and their statuses are stored.
   * @param storageKey - A key used along with the trigger ID to generate a unique token for each trigger.
   * @param jwt - The JSON Web Token used for authentication in the API call.
   * @param triggers - An array of notification triggers to be created. Each trigger includes an ID, chain ID, kind, and address.
   * @returns A promise that resolves to void. Throws an error if the API call fails or if there's an issue creating the triggers.
   */
  public async createOnChainTriggers(
    userStorage: UserStorage,
    storageKey: string,
    jwt: string,
    triggers: NotificationTrigger[],
  ): Promise<void> {
    type RequestPayloadTrigger = {
      id: string;
      // this is the trigger token, generated by using the uuid + storage key. It proves you own the trigger you are updating
      token: string;
      config: {
        kind: string;
        chain_id: number;
        address: string;
      };
    };
    const triggersToCreate: RequestPayloadTrigger[] = triggers.map((t) => ({
      id: t.id,
      token: createSHA256Hash(t.id + storageKey),
      config: {
        kind: t.kind,
        chain_id: Number(t.chainId),
        address: t.address,
      },
    }));

    if (triggersToCreate.length === 0) {
      return;
    }

    const response = await PlatformNotificationUtils.makeApiCall(
      jwt,
      this.BATCH_ENDPOINT,
      'POST',
      triggersToCreate,
    );

    if (!response.ok) {
      const errorData = await response.json().catch(() => undefined);
      log.error('Error creating triggers:', errorData);
      throw new Error();
    }

    // If the trigger creation was fine
    // then update the userStorage
    for (const trigger of triggersToCreate) {
      PlatformNotificationUtils.toggleUserStorageTriggerStatus(
        userStorage,
        trigger.config.address,
        String(trigger.config.chain_id),
        trigger.id,
        true,
      );
    }
  }

  /**
   * Deletes on-chain triggers based on the provided UUIDs.
   * This method generates a unique token for each trigger using the UUID and storage key,
   * proving ownership of the trigger being deleted. It then makes an API call to delete these triggers.
   * Upon successful deletion, it updates the userStorage to remove the deleted trigger statuses.
   *
   * @param userStorage - The user's storage object where triggers and their statuses are stored.
   * @param storageKey - A key used along with the UUID to generate a unique token for each trigger.
   * @param jwt - The JSON Web Token used for authentication in the API call.
   * @param uuids - An array of UUIDs representing the triggers to be deleted.
   * @returns A promise that resolves to the updated UserStorage object. Throws an error if the API call fails or if there's an issue deleting the triggers.
   */
  public async deleteOnChainTriggers(
    userStorage: UserStorage,
    storageKey: string,
    jwt: string,
    uuids: string[],
  ): Promise<UserStorage> {
    const triggersToDelete = uuids.map((uuid) => ({
      id: uuid,
      token: createSHA256Hash(uuid + storageKey),
    }));

    try {
      const response = await PlatformNotificationUtils.makeApiCall(
        jwt,
        this.BATCH_ENDPOINT,
        'DELETE',
        triggersToDelete,
      );

      if (!response.ok) {
        throw new Error(
          `Failed to delete HAL notifications for uuids ${uuids.join(', ')}`,
        );
      }

      // Update the state of the deleted trigger to false
      for (const uuid of uuids) {
        for (const address in userStorage) {
          for (const chain_id in userStorage[address]) {
            if (userStorage?.[address]?.[chain_id]?.[uuid]) {
              delete userStorage[address][chain_id][uuid];
            }
          }
        }
      }

      // Follow-up cleanup, if an address had no triggers whatsoever, then we can delete the address
      const isEmpty = (obj = {}) => Object.keys(obj).length === 0;
      for (const address in userStorage) {
        for (const chain_id in userStorage[address]) {
          // Chain isEmpty Check
          if (isEmpty(userStorage?.[address]?.[chain_id])) {
            delete userStorage[address][chain_id];
          }
        }

        // Address isEmpty Check
        if (isEmpty(userStorage?.[address])) {
          delete userStorage[address];
        }
      }
    } catch (err) {
      console.error(
        `Error deleting HAL notifications for uuids ${uuids.join(', ')}:`,
        err,
      );
      throw err;
    }

    return userStorage;
  }

  /**
   * Fetches on-chain notifications for the given user storage and JWT.
   * This method iterates through the userStorage to find enabled triggers and fetches notifications for those triggers.
   * It makes paginated API calls to the notifications service, transforming and aggregating the notifications into a single array.
   * The process stops either when all pages have been fetched or when a page has less than 100 notifications, indicating the end of the data.
   *
   * @param userStorage - The user's storage object containing trigger information.
   * @param jwt - The JSON Web Token used for authentication in the API call.
   * @returns A promise that resolves to an array of OnChainRawNotification objects. If no triggers are enabled or an error occurs, it may return an empty array.
   */
  public async getOnChainNotifications(
    userStorage: UserStorage,
    jwt: string,
  ): Promise<OnChainRawNotification[]> {
    const triggerIds = [];

    for (const address in userStorage) {
      if (address !== 'v') {
        for (const chain_id in userStorage[address]) {
          for (const uuid in userStorage[address][chain_id]) {
            const trigger = userStorage[address][chain_id][uuid];
            const isEnabled = trigger.e;
            if (isEnabled) {
              triggerIds.push(uuid);
            }
          }
        }
      }
    }

    if (triggerIds.length === 0) {
      return [];
    }

    const onChainNotifications: OnChainRawNotification[] = [];
    const PAGE_LIMIT = 2;
    for (let page = 1; page <= PAGE_LIMIT; page++) {
      try {
        const response = await PlatformNotificationUtils.makeApiCall(
          jwt,
          this.LIST_NOTIFICATIONS_ENDPOINT(page),
          'POST',
          { trigger_ids: triggerIds },
        );

        const notifications =
          (await response.json()) as OnChainRawNotification[];

        // Transform and sort notifications
        const transformedNotifications = notifications
          .map(
            (
              n: components['schemas']['Notification'],
            ): OnChainRawNotification | undefined => {
              if (!n.data?.kind) {
                return undefined;
              }

              return {
                ...n,
                type: n.data.kind as TRIGGER_TYPES,
              } as OnChainRawNotification;
            },
          )
          .filter((n): n is OnChainRawNotification => Boolean(n));

        onChainNotifications.push(...transformedNotifications);

        // if less than 100 notifications on page, then means we reached end
        if (notifications.length < 100) {
          page = PAGE_LIMIT + 1;
          break;
        }
      } catch (err) {
        log.error(
          `Error fetching HAL notifications for trigger IDs ${triggerIds.join(
            ', ',
          )}:`,
          err,
        );
        // do nothing
      }
    }

    return onChainNotifications;
  }

  /**
   * Marks the specified notifications as read.
   * This method sends a POST request to the notifications service to mark the provided notification IDs as read.
   * If the operation is successful, it completes without error. If the operation fails, it throws an error with details.
   *
   * @param jwt - The JSON Web Token used for authentication in the API call.
   * @param notificationIds - An array of notification IDs to be marked as read.
   * @returns A promise that resolves to void. The promise will reject if there's an error during the API call or if the response status is not 200.
   */
  public async markNotificationsAsRead(
    jwt: string,
    notificationIds: string[],
  ): Promise<void> {
    if (notificationIds.length === 0) {
      return;
    }

    try {
      const response = await PlatformNotificationUtils.makeApiCall(
        jwt,
        this.MARK_ALL_AS_READ_ENDPOINT,
        'POST',
        { ids: notificationIds },
      );

      if (response.status !== 200) {
        const errorData = await response.json().catch(() => undefined);
        throw new Error(
          `Error marking notifications as read: ${errorData?.message}`,
        );
      }
    } catch (err) {
      console.error('Error marking notifications as read:', err);
      throw err;
    }
  }
}
