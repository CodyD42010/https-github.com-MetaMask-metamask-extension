import EventEmitter from 'events';

import { SINGLE_CALL_BALANCES_ADDRESSES } from '../constants/contracts';

import { createTestProviderTools } from '../../../test/stub/provider';
import AccountTracker from './account-tracker';

const noop = () => true;
const currentNetworkId = '5';
const currentChainId = '0x5';
const VALID_ADDRESS = '0x0000000000000000000000000000000000000000';
const VALID_ADDRESS_TWO = '0x0000000000000000000000000000000000000001';

const INITIAL_BALANCE_1 = '0x1';
const INITIAL_BALANCE_2 = '0x2';
const UPDATE_BALANCE = '0xabc';

// The below three values were generated by running MetaMask in the browser
// The response to eth_call, which is called via `ethContract.balances`
// in `_updateAccountsViaBalanceChecker` of account-tracker.js, needs to be properly
// formatted or else ethers will throw an error.
const ETHERS_CONTRACT_BALANCES_ETH_CALL_RETURN =
  '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000038d7ea4c6800600000000000000000000000000000000000000000000000000000000000186a0';
const EXPECTED_CONTRACT_BALANCE_1 = '0x038d7ea4c68006';
const EXPECTED_CONTRACT_BALANCE_2 = '0x0186a0';

const mockAccounts = {
  [VALID_ADDRESS]: { address: VALID_ADDRESS, balance: INITIAL_BALANCE_1 },
  [VALID_ADDRESS_TWO]: {
    address: VALID_ADDRESS_TWO,
    balance: INITIAL_BALANCE_2,
  },
};

describe('Account Tracker', () => {
  let provider,
    blockTrackerStub,
    blockTrackerFromHookStub,
    providerResultStub,
    useMultiAccountBalanceChecker,
    accountTracker,
    accountRemovedListener,
    getNetworkClientByIdStub;

  beforeEach(() => {
    providerResultStub = {
      eth_getBalance: UPDATE_BALANCE,
      eth_call: ETHERS_CONTRACT_BALANCES_ETH_CALL_RETURN,
    };
    provider = createTestProviderTools({
      scaffold: providerResultStub,
      networkId: currentNetworkId,
      chainId: currentNetworkId,
    }).provider;

    blockTrackerStub = new EventEmitter();
    blockTrackerStub.getCurrentBlock = noop;
    blockTrackerStub.getLatestBlock = noop;

    blockTrackerFromHookStub = new EventEmitter();
    blockTrackerFromHookStub.getCurrentBlock = noop;
    blockTrackerFromHookStub.getLatestBlock = noop;

    getNetworkClientByIdStub = jest.fn().mockReturnValue({
      configuration: {
        chainId: '0x1',
      },
      blockTracker: blockTrackerFromHookStub,
    });

    accountTracker = new AccountTracker({
      provider,
      blockTracker: blockTrackerStub,
      getNetworkClientById: getNetworkClientByIdStub,
      getNetworkIdentifier: jest.fn(),
      preferencesController: {
        store: {
          getState: () => ({
            useMultiAccountBalanceChecker,
          }),
          subscribe: noop,
        },
      },
      onboardingController: {
        store: {
          subscribe: noop,
          getState: noop,
        },
      },
      onAccountRemoved: (callback) => {
        accountRemovedListener = callback;
      },
      getCurrentChainId: () => currentChainId,
    });
  });

  describe('start', () => {
    it('restarts the subscription to the block tracker and update accounts', async () => {
      jest.spyOn(blockTrackerStub, 'addListener').mockImplementation();
      jest.spyOn(blockTrackerStub, 'removeListener').mockImplementation();
      const updateAccountsWithNetworkClientIdSpy = jest
        .spyOn(accountTracker, '_updateAccountsWithNetworkClientId')
        .mockResolvedValue();

      accountTracker.start();

      expect(blockTrackerStub.removeListener).toHaveBeenNthCalledWith(
        1,
        'latest',
        accountTracker._updateForBlock,
      );
      expect(blockTrackerStub.addListener).toHaveBeenNthCalledWith(
        1,
        'latest',
        accountTracker._updateForBlock,
      );
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenNthCalledWith(1); // called first time with no args

      accountTracker.start();

      expect(blockTrackerStub.removeListener).toHaveBeenNthCalledWith(
        2,
        'latest',
        accountTracker._updateForBlock,
      );
      expect(blockTrackerStub.addListener).toHaveBeenNthCalledWith(
        2,
        'latest',
        accountTracker._updateForBlock,
      );
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenNthCalledWith(2); // called second time with no args

      accountTracker.stop();
    });
  });

  describe('stop', () => {
    it('ends the subscription to the block tracker', async () => {
      jest.spyOn(blockTrackerStub, 'removeListener').mockImplementation();

      accountTracker.stop();

      expect(blockTrackerStub.removeListener).toHaveBeenNthCalledWith(
        1,
        'latest',
        accountTracker._updateForBlock,
      );
    });
  });

  describe('startPollingByNetworkClientId', () => {
    it('should subscribe to the block tracker and update accounts if not already using the networkClientId', async () => {
      jest.spyOn(blockTrackerFromHookStub, 'addListener').mockImplementation();
      const updateAccountsWithNetworkClientIdSpy = jest
        .spyOn(accountTracker, '_updateAccountsWithNetworkClientId')
        .mockResolvedValue();

      accountTracker.startPollingByNetworkClientId('mainnet');

      expect(blockTrackerFromHookStub.addListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenCalledWith(
        'mainnet',
      );

      accountTracker.startPollingByNetworkClientId('mainnet');

      expect(blockTrackerFromHookStub.addListener).toHaveBeenCalledTimes(1);
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenCalledTimes(1);

      accountTracker.stopAllPolling();
    });

    it('should subscribe to the block tracker and update accounts for each networkClientId', async () => {
      const blockTrackerFromHookStub1 = new EventEmitter();
      blockTrackerFromHookStub1.getCurrentBlock = noop;
      blockTrackerFromHookStub1.getLatestBlock = noop;
      jest.spyOn(blockTrackerFromHookStub1, 'addListener').mockImplementation();

      const blockTrackerFromHookStub2 = new EventEmitter();
      blockTrackerFromHookStub2.getCurrentBlock = noop;
      blockTrackerFromHookStub2.getLatestBlock = noop;
      jest.spyOn(blockTrackerFromHookStub2, 'addListener').mockImplementation();

      const blockTrackerFromHookStub3 = new EventEmitter();
      blockTrackerFromHookStub3.getCurrentBlock = noop;
      blockTrackerFromHookStub3.getLatestBlock = noop;
      jest.spyOn(blockTrackerFromHookStub3, 'addListener').mockImplementation();

      getNetworkClientByIdStub = jest
        .fn()
        .mockImplementation((networkClientId) => {
          switch (networkClientId) {
            case 'mainnet':
              return {
                configuration: {
                  chainId: '0x1',
                },
                blockTracker: blockTrackerFromHookStub1,
              };
            case 'goerli':
              return {
                configuration: {
                  chainId: '0x5',
                },
                blockTracker: blockTrackerFromHookStub2,
              };
            case 'networkClientId1':
              return {
                configuration: {
                  chainId: '0xa',
                },
                blockTracker: blockTrackerFromHookStub3,
              };
            default:
              throw new Error('unexpected networkClientId');
          }
        });

      accountTracker = new AccountTracker({
        provider,
        blockTracker: blockTrackerStub,
        getNetworkClientById: getNetworkClientByIdStub,
        getNetworkIdentifier: jest.fn(),
        preferencesController: {
          store: {
            getState: () => ({
              useMultiAccountBalanceChecker,
            }),
            subscribe: noop,
          },
        },
        onboardingController: {
          store: {
            subscribe: noop,
            getState: noop,
          },
        },
        onAccountRemoved: (callback) => {
          accountRemovedListener = callback;
        },
        getCurrentChainId: () => currentChainId,
      });

      const updateAccountsWithNetworkClientIdSpy = jest
        .spyOn(accountTracker, '_updateAccountsWithNetworkClientId')
        .mockResolvedValue();

      accountTracker.startPollingByNetworkClientId('mainnet');

      expect(blockTrackerFromHookStub1.addListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenCalledWith(
        'mainnet',
      );

      accountTracker.startPollingByNetworkClientId('goerli');

      expect(blockTrackerFromHookStub2.addListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenCalledWith(
        'goerli',
      );

      accountTracker.startPollingByNetworkClientId('networkClientId1');

      expect(blockTrackerFromHookStub3.addListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
      expect(updateAccountsWithNetworkClientIdSpy).toHaveBeenCalledWith(
        'networkClientId1',
      );

      accountTracker.stopAllPolling();
    });
  });

  describe('stopPollingByPollingToken', () => {
    it('should unsubscribe from the block tracker when called with a valid polling that was the only active pollingToken for a given networkClient', async () => {
      jest
        .spyOn(blockTrackerFromHookStub, 'removeListener')
        .mockImplementation();
      jest
        .spyOn(accountTracker, '_updateAccountsWithNetworkClientId')
        .mockResolvedValue();

      const pollingToken =
        accountTracker.startPollingByNetworkClientId('mainnet');

      accountTracker.stopPollingByPollingToken(pollingToken);

      expect(blockTrackerFromHookStub.removeListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
    });

    it('should not unsubscribe from the block tracker if called with one of multiple active polling tokens for a given networkClient', async () => {
      jest
        .spyOn(blockTrackerFromHookStub, 'removeListener')
        .mockImplementation();
      jest
        .spyOn(accountTracker, '_updateAccountsWithNetworkClientId')
        .mockResolvedValue();

      const pollingToken1 =
        accountTracker.startPollingByNetworkClientId('mainnet');
      accountTracker.startPollingByNetworkClientId('mainnet');

      accountTracker.stopPollingByPollingToken(pollingToken1);

      expect(blockTrackerFromHookStub.removeListener).not.toHaveBeenCalled();

      accountTracker.stopAllPolling();
    });
    it('should error if no pollingToken is passed', () => {
      expect(() => {
        accountTracker.stopPollingByPollingToken(undefined);
      }).toThrow('pollingToken required');
    });

    it('should error if no matching pollingToken is found', () => {
      expect(() => {
        accountTracker.stopPollingByPollingToken('potato');
      }).toThrow('pollingToken not found');
    });
  });

  describe('stopAll', () => {
    it('should end all subscriptions', async () => {
      jest.spyOn(blockTrackerStub, 'removeListener').mockImplementation();

      const blockTrackerFromHookStub1 = new EventEmitter();
      blockTrackerFromHookStub1.getCurrentBlock = noop;
      blockTrackerFromHookStub1.getLatestBlock = noop;
      jest
        .spyOn(blockTrackerFromHookStub1, 'removeListener')
        .mockImplementation();

      const blockTrackerFromHookStub2 = new EventEmitter();
      blockTrackerFromHookStub2.getCurrentBlock = noop;
      blockTrackerFromHookStub2.getLatestBlock = noop;
      jest
        .spyOn(blockTrackerFromHookStub2, 'removeListener')
        .mockImplementation();

      getNetworkClientByIdStub = jest
        .fn()
        .mockImplementation((networkClientId) => {
          switch (networkClientId) {
            case 'mainnet':
              return {
                configuration: {
                  chainId: '0x1',
                },
                blockTracker: blockTrackerFromHookStub1,
              };
            case 'goerli':
              return {
                configuration: {
                  chainId: '0x5',
                },
                blockTracker: blockTrackerFromHookStub2,
              };
            default:
              throw new Error('unexpected networkClientId');
          }
        });

      accountTracker = new AccountTracker({
        provider,
        blockTracker: blockTrackerStub,
        getNetworkClientById: getNetworkClientByIdStub,
        getNetworkIdentifier: jest.fn(),
        preferencesController: {
          store: {
            getState: () => ({
              useMultiAccountBalanceChecker,
            }),
            subscribe: noop,
          },
        },
        onboardingController: {
          store: {
            subscribe: noop,
            getState: noop,
          },
        },
        onAccountRemoved: (callback) => {
          accountRemovedListener = callback;
        },
        getCurrentChainId: () => currentChainId,
      });

      jest
        .spyOn(accountTracker, '_updateAccountsWithNetworkClientId')
        .mockResolvedValue();

      accountTracker.startPollingByNetworkClientId('mainnet');

      accountTracker.startPollingByNetworkClientId('goerli');

      accountTracker.stopAllPolling();

      expect(blockTrackerStub.removeListener).toHaveBeenCalledWith(
        'latest',
        accountTracker._updateForBlock,
      );
      expect(blockTrackerFromHookStub1.removeListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
      expect(blockTrackerFromHookStub2.removeListener).toHaveBeenCalledWith(
        'latest',
        expect.any(Function),
      );
    });
  });

  describe('_updateAccount', () => {
    it('should update the passed address account balance, and leave other balances unchanged, if useMultiAccountBalanceChecker is true', async () => {
      useMultiAccountBalanceChecker = true;
      accountTracker.store.updateState({
        accounts: { ...mockAccounts },
        accountsByChainId: {
          [currentChainId]: {
            ...mockAccounts,
          },
        },
      });

      await accountTracker._updateAccount(
        VALID_ADDRESS,
        accountTracker._provider,
        currentChainId,
      );

      const newState = accountTracker.store.getState();

      const accounts = {
        [VALID_ADDRESS]: { address: VALID_ADDRESS, balance: UPDATE_BALANCE },
        [VALID_ADDRESS_TWO]: {
          address: VALID_ADDRESS_TWO,
          balance: INITIAL_BALANCE_2,
        },
      };

      expect(newState).toStrictEqual({
        accounts,
        accountsByChainId: {
          [currentChainId]: accounts,
        },
        currentBlockGasLimit: '',
        currentBlockGasLimitByChainId: {},
      });
    });

    it('should not change accounts if the passed address is not in accounts', async () => {
      accountTracker.store.updateState({
        accounts: { ...mockAccounts },
        accountsByChainId: {
          [currentChainId]: {
            ...mockAccounts,
          },
        },
      });

      await accountTracker._updateAccount(
        'fake address',
        accountTracker._provider,
        currentChainId,
      );

      const newState = accountTracker.store.getState();

      const accounts = {
        [VALID_ADDRESS]: {
          address: VALID_ADDRESS,
          balance: INITIAL_BALANCE_1,
        },
        [VALID_ADDRESS_TWO]: {
          address: VALID_ADDRESS_TWO,
          balance: INITIAL_BALANCE_2,
        },
      };

      expect(newState).toStrictEqual({
        accounts,
        accountsByChainId: {
          [currentChainId]: accounts,
        },
        currentBlockGasLimit: '',
        currentBlockGasLimitByChainId: {},
      });
    });

    it('should update the passed address account balance, and set other balances to null, if useMultiAccountBalanceChecker is false', async () => {
      useMultiAccountBalanceChecker = false;
      accountTracker.store.updateState({
        accounts: { ...mockAccounts },
        accountsByChainId: {
          [currentChainId]: {
            ...mockAccounts,
          },
        },
      });

      await accountTracker._updateAccount(
        VALID_ADDRESS,
        accountTracker._provider,
        currentChainId,
      );

      const newState = accountTracker.store.getState();

      const accounts = {
        [VALID_ADDRESS]: { address: VALID_ADDRESS, balance: UPDATE_BALANCE },
        [VALID_ADDRESS_TWO]: { address: VALID_ADDRESS_TWO, balance: null },
      };

      expect(newState).toStrictEqual({
        accounts,
        accountsByChainId: {
          [currentChainId]: accounts,
        },
        currentBlockGasLimit: '',
        currentBlockGasLimitByChainId: {},
      });
    });
  });

  describe('onAccountRemoved', () => {
    it('should remove an account from state', () => {
      accountTracker.store.updateState({
        accounts: { ...mockAccounts },
        accountsByChainId: {
          [currentChainId]: {
            ...mockAccounts,
          },
          '0x1': {
            ...mockAccounts,
          },
          '0x2': {
            ...mockAccounts,
          },
        },
      });

      accountRemovedListener(VALID_ADDRESS);

      const newState = accountTracker.store.getState();

      const accounts = {
        [VALID_ADDRESS_TWO]: mockAccounts[VALID_ADDRESS_TWO],
      };

      expect(newState).toStrictEqual({
        accounts,
        accountsByChainId: {
          [currentChainId]: accounts,
          '0x1': accounts,
          '0x2': accounts,
        },
        currentBlockGasLimit: '',
        currentBlockGasLimitByChainId: {},
      });
    });
  });

  describe('_updateAccountsViaBalanceChecker', () => {
    it('should update the passed address account balance, and set other balances to null, if useMultiAccountBalanceChecker is false', async () => {
      useMultiAccountBalanceChecker = true;
      accountTracker.store.updateState({
        accounts: { ...mockAccounts },
        accountsByChainId: {
          [currentChainId]: {
            ...mockAccounts,
          },
        },
      });

      await accountTracker._updateAccountsViaBalanceChecker(
        [VALID_ADDRESS],
        SINGLE_CALL_BALANCES_ADDRESSES[currentChainId],
        accountTracker._provider,
        currentChainId,
      );

      const newState = accountTracker.store.getState();

      const accounts = {
        [VALID_ADDRESS]: {
          address: VALID_ADDRESS,
          balance: EXPECTED_CONTRACT_BALANCE_1,
        },
        [VALID_ADDRESS_TWO]: { address: VALID_ADDRESS_TWO, balance: null },
      };

      expect(newState).toStrictEqual({
        accounts,
        accountsByChainId: {
          [currentChainId]: accounts,
        },
        currentBlockGasLimit: '',
        currentBlockGasLimitByChainId: {},
      });
    });

    it('should update all balances if useMultiAccountBalanceChecker is true', async () => {
      useMultiAccountBalanceChecker = true;
      accountTracker.store.updateState({
        accounts: { ...mockAccounts },
        accountsByChainId: {
          [currentChainId]: {
            ...mockAccounts,
          },
        },
      });

      await accountTracker._updateAccountsViaBalanceChecker(
        [VALID_ADDRESS, VALID_ADDRESS_TWO],
        SINGLE_CALL_BALANCES_ADDRESSES[currentChainId],
        accountTracker._provider,
        currentChainId,
      );

      const newState = accountTracker.store.getState();

      const accounts = {
        [VALID_ADDRESS]: {
          address: VALID_ADDRESS,
          balance: EXPECTED_CONTRACT_BALANCE_1,
        },
        [VALID_ADDRESS_TWO]: {
          address: VALID_ADDRESS_TWO,
          balance: EXPECTED_CONTRACT_BALANCE_2,
        },
      };

      expect(newState).toStrictEqual({
        accounts,
        accountsByChainId: {
          [currentChainId]: accounts,
        },
        currentBlockGasLimit: '',
        currentBlockGasLimitByChainId: {},
      });
    });
  });
});
